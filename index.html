<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elliot Lee - Portfolio</title>
    <!-- Cache bust: 2025-07-18 -->
    <meta name="description" content="Interactive portfolio showcasing generative art and creative coding">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/Flip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/TextPlugin.min.js"></script>
    <link rel="stylesheet" href="css/conversation.css?v=4">
    <script src="js/conversation/claude-client.js?v=4"></script>
    <script src="js/conversation/avatar-generator.js?v=3"></script>
    <script src="js/conversation/chat-ui.js?v=5"></script>
    <script src="js/conversation/conversation-manager.js?v=4"></script>
    <link rel="stylesheet" href="css/main.css">
    <link rel="stylesheet" href="css/trait-selector.css">
    <link rel="stylesheet" href="css/museum-cards.css?v=1.5">
    <link href="https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500;600;700;900&display=swap" rel="stylesheet">

</head>
<body>
    <div class="loading-screen" id="loadingScreen">
        <div class="loader">Loading Experience...</div>
    </div>

    <nav class="nav-bar">
        <div class="nav-logo">
            EL
        </div>
        
        <div class="nav-center">
            <a href="#home" class="nav-item">HOME</a>
            <a href="#projects" class="nav-item">PROJECTS</a>
            <a href="#contact" class="nav-item">CONTACT</a>
        </div>
    </nav>

    <div class="hero-container" id="home">
        <!-- Artifact containers -->
        <div class="artifact-container">
            <!-- Artifact 1: HankiesInTheWind (Three.js interference patterns) -->
            <div class="artifact active" id="artifact-1"></div>
            
            <!-- Artifact 2: AsciiBinaryFlow -->
            <div class="artifact" id="artifact-2">
                <div class="ascii-container"></div>
            </div>
            
            <!-- Artifact 3: ParticleVessel (Three.js particles) -->
            <div class="artifact" id="artifact-3"></div>
            
            <!-- Artifact 4: Metamorphosis (Canvas 3D forms) -->
            <div class="artifact" id="artifact-4">
                <div class="canvas-container">
                    <canvas width="550" height="550"></canvas>
                </div>
            </div>
            
            <!-- Artifact 5: LayeredSineWaves (Canvas sine waves) -->
            <div class="artifact" id="artifact-5">
                <div class="canvas-container">
                    <canvas width="550" height="550"></canvas>
                </div>
            </div>
        </div>
        
        <div class="hero-content">
            <h1 class="glitch-title" 
                onclick="changeEverything()" 
                onkeydown="handleKeyPress(event)"
                role="button" 
                tabindex="0"
                aria-label="Click to cycle through titles and change background art">
                ELLIOT LEE
            </h1>
            
            <div class="spark-magic" 
                 onclick="changeEverything()"
                 onkeydown="handleKeyPress(event)"
                 role="button"
                 tabindex="0"
                 aria-label="Change experience">
                <span>[click me]</span>
            </div>
        </div>
    </div>

    <div class="terminal-section">
        <div class="museum-container">
            <!-- Left Panel - Museum Card Style with Flip -->
            <div class="terminal-panel">
                <div class="trait-panel-accent"></div>
                
                <!-- Card Flip Container -->
                <div class="card-flip-container" id="cardFlipContainer">
                    <div class="card-flip-inner">
                        <!-- Front of Card (Original Content) -->
                        <div class="card-flip-front">
                            <!-- Museum Card Header -->
                            <div class="terminal-header">
                                <div class="toggle-header">
                                    <span class="toggle-title">Select Traits</span>
                                    <span class="trait-counter" id="traitCounter">4/18</span>
                                </div>
                            </div>
                            
                            <!-- Card Content -->
                            <div class="terminal-content">
                                <!-- Trait Toggle Section -->
                                <div class="trait-toggle-section">
                                    <div class="trait-toggles">
                                        <div class="trait-row">
                                            <span class="trait-label">
                                                <span class="trait-emoji">‚ö°</span>
                                                High Energy
                                            </span>
                                            <div class="toggle-switch active" data-trait="energy"></div>
                                        </div>
                                        
                                        <div class="trait-row">
                                            <span class="trait-label">
                                                <span class="trait-emoji">üéØ</span>
                                                Intense Focus
                                            </span>
                                            <div class="toggle-switch" data-trait="intensity"></div>
                                        </div>
                                        
                                        <div class="trait-row">
                                            <span class="trait-label">
                                                <span class="trait-emoji">üöÄ</span>
                                                Innovation
                                            </span>
                                            <div class="toggle-switch" data-trait="innovation"></div>
                                        </div>
                                        
                                        <div class="trait-row">
                                            <span class="trait-label">
                                                <span class="trait-emoji">ü§ù</span>
                                                Cooperative
                                            </span>
                                            <div class="toggle-switch" data-trait="collaborative"></div>
                                        </div>
                                        
                                        <div class="trait-row">
                                            <span class="trait-label">
                                                <span class="trait-emoji">üßò</span>
                                                Calm Under Pressure
                                            </span>
                                            <div class="toggle-switch" data-trait="calm"></div>
                                        </div>
                                    </div>
                                </div>

                                <!-- Soundbar Visualization - BACK TO ORIGINAL POSITION -->
                                <div class="soundbar-container" id="soundbarContainer">
                                    <div class="soundbar active" data-trait="energy"></div>
                                    <div class="soundbar" data-trait="intensity"></div>
                                    <div class="soundbar" data-trait="innovation"></div>
                                    <div class="soundbar" data-trait="collaborative"></div>
                                    <div class="soundbar" data-trait="calm"></div>
                                    <div class="soundbar" data-trait="analytical"></div>
                                    <div class="soundbar active" data-trait="creative"></div>
                                    <div class="soundbar active" data-trait="leadership"></div>
                                    <div class="soundbar active" data-trait="technical"></div>
                                    <div class="soundbar" data-trait="mystery"></div>
                                    <div class="soundbar" data-trait="discipline"></div>
                                    <div class="soundbar" data-trait="curiosity"></div>
                                    <div class="soundbar" data-trait="hustle"></div>
                                    <div class="soundbar" data-trait="paranoia"></div>
                                    <div class="soundbar" data-trait="speed"></div>
                                    <div class="soundbar" data-trait="experimental"></div>
                                    <div class="soundbar" data-trait="futuristic"></div>
                                    <div class="soundbar" data-trait="procrastination"></div>
                                </div>

                                <!-- Trait Grid Section -->
                                <div class="trait-grid" id="traitGrid">
                                    <div class="trait-option" data-trait="analytical" data-tooltip="Analytical">üî¨</div>
                                    <div class="trait-option selected" data-trait="creative" data-tooltip="Creative">üé®</div>
                                    <div class="trait-option selected" data-trait="leadership" data-tooltip="Leadership">üëë</div>
                                    <div class="trait-option selected" data-trait="technical" data-tooltip="Technical">üîß</div>
                                    <div class="trait-option" data-trait="mystery" data-tooltip="Mystery">üïµÔ∏è</div>
                                    <div class="trait-option" data-trait="discipline" data-tooltip="Discipline">üí™</div>
                                    <div class="trait-option" data-trait="curiosity" data-tooltip="Curiosity">üîç</div>
                                    <div class="trait-option" data-trait="hustle" data-tooltip="Hustle">üî•</div>
                                    <div class="trait-option" data-trait="paranoia" data-tooltip="Paranoia">üëÄ</div>
                                    <div class="trait-option" data-trait="speed" data-tooltip="Speed">üí®</div>
                                    <div class="trait-option" data-trait="experimental" data-tooltip="Experimental">üß™</div>
                                    <div class="trait-option" data-trait="futuristic" data-tooltip="Futuristic">ü§ñ</div>
                                    <div class="trait-option" data-trait="procrastination" data-tooltip="Procrastination">üò¥</div>
                                    <div class="trait-option" data-trait="empathy" data-tooltip="Empathy">üíù</div>
                                    <div class="trait-option" data-trait="calm-detailed" data-tooltip="Calm">üíé</div>
                                    <div class="trait-option" data-trait="intensity-alt" data-tooltip="Intensity">‚ö°</div>
                                    <div class="trait-option" data-trait="flexibility" data-tooltip="Flexibility">üåø</div>
                                    <div class="trait-option" data-trait="writing" data-tooltip="Writing">‚úèÔ∏è</div>
                                </div>

                                <!-- Advanced Section -->
                                <div class="advanced-section">
                                    <div class="advanced-toggle" id="advancedToggle">
                                        <span>‚ñ∂ Advanced</span>
                                    </div>
                                    <div class="advanced-content" id="advancedContent">
                                        <p>Access the experimental terminal interface for advanced personality analysis.</p>
                                        
                                        <!-- Terminal Mode Button -->
                                        <button class="terminal-mode-btn" id="terminalModeBtn">
                                            <span>üñ•Ô∏è Enter Terminal Mode</span>
                                            <div class="button-subtitle">Flip Card</div>
                                        </button>
                                    </div>
                                </div>

                                <!-- Generation Status (hidden by default) -->
                                <div class="generation-status" id="generationStatus">
                                    Analyzing trait patterns and generating persona...
                                </div>

                                <!-- Command Buttons -->
                                <div class="command-grid">
                                    <div class="button-row">
                                        <button class="terminal-button secondary" id="randomBtn">
                                            Random
                                            <div class="button-subtitle">R</div>
                                        </button>
                                        <button class="terminal-button secondary" id="resetBtn">
                                            Reset
                                            <div class="button-subtitle">ESC</div>
                                        </button>
                                        <button class="terminal-button secondary" id="saveBtn">
                                            Save
                                            <div class="button-subtitle">S</div>
                                        </button>
                                    </div>
                                    <button class="terminal-button primary button-generate" id="generateBtn">
                                        Generate
                                        <div class="button-subtitle">G</div>
                                    </button>
                                </div>
                            </div>
                        </div>

                        <!-- Back of Card (Mac-Style Terminal Interface) -->
                        <div class="card-flip-back">
                            <div class="terminal-interface">
                                <div class="terminal-header-bar">
                                    <span>üñ•Ô∏è Neural Terminal</span>
                                    <button class="terminal-close-btn" id="terminalCloseBtn">BACK</button>
                                </div>
                                <div class="terminal-output" id="terminalOutput">
                                    <!-- Terminal content will be populated by JavaScript -->
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Right Panel - Museum Card Display -->
            <div class="museum-display">
                <div class="museum-card" id="museumCard">
                    <div class="blue-accent"></div>
                    <div class="hover-effect"></div>
                    <div class="blue-accent"></div>
                    <div class="hover-effect"></div>
                    
                    <!-- Museum Card Header -->
                    <div class="museum-card-header">
                        <div class="toggle-header">
                            <span class="toggle-title">Digital Persona</span>
                            <span class="trait-counter" id="displayTraitCounter">4/18</span>
                        </div>
                    </div>
                    
                    <div class="card-header">
                        <div class="image-container">
                            <div>CONSPIRACYEL PORTRAIT</div>
                        </div>
                        
                        <div class="header-radars">
                            <div class="header-radar-section">
                                <h4 class="header-chart-title">YOUR PROFILE</h4>
                                <svg class="header-radar-chart" viewBox="0 0 120 120" width="60" height="60">
                                    <!-- Background grid -->
                                    <g stroke="rgba(51, 51, 51, 0.2)" stroke-width="0.5" fill="none" opacity="0.3">
                                        <polygon points="60,10 95,35 85,75 35,75 25,35" />
                                        <polygon points="60,25 80,42.5 75,62.5 45,62.5 40,42.5" />
                                        <polygon points="60,40 65,50 65,50 55,50 55,50" />
                                    </g>
                                    <!-- Axes -->
                                    <g stroke="rgba(51, 51, 51, 0.2)" stroke-width="0.5" opacity="0.5">
                                        <line x1="60" y1="60" x2="60" y2="10" />
                                        <line x1="60" y1="60" x2="95" y2="35" />
                                        <line x1="60" y1="60" x2="85" y2="75" />
                                        <line x1="60" y1="60" x2="35" y2="75" />
                                        <line x1="60" y1="60" x2="25" y2="35" />
                                    </g>
                                    <!-- Data polygon -->
                                    <polygon points="60,15 87,40 80,70 45,70 35,40" 
                                             fill="rgba(204, 122, 0, 0.2)" 
                                             stroke="#CC7A00" 
                                             stroke-width="1.5" />
                                    <!-- Data points -->
                                    <g fill="#CC7A00" stroke="#CC7A00" stroke-width="1">
                                        <circle cx="60" cy="15" r="2" />
                                        <circle cx="87" cy="40" r="2" />
                                        <circle cx="80" cy="70" r="2" />
                                        <circle cx="45" cy="70" r="2" />
                                        <circle cx="35" cy="40" r="2" />
                                    </g>
                                    <!-- Labels -->
                                    <g font-size="8" font-weight="600" text-anchor="middle" fill="#333">
                                        <text x="60" y="8">O</text>
                                        <text x="98" y="38">C</text>
                                        <text x="88" y="78">E</text>
                                        <text x="32" y="78">A</text>
                                        <text x="22" y="38">N</text>
                                    </g>
                                </svg>
                            </div>
                            
                            <div class="header-radar-section">
                                <h4 class="header-chart-title">CHARACTER</h4>
                                <svg class="header-radar-chart" viewBox="0 0 120 120" width="60" height="60">
                                    <!-- Background grid -->
                                    <g stroke="rgba(51, 51, 51, 0.2)" stroke-width="0.5" fill="none" opacity="0.3">
                                        <polygon points="60,10 95,35 85,75 35,75 25,35" />
                                        <polygon points="60,25 80,42.5 75,62.5 45,62.5 40,42.5" />
                                        <polygon points="60,40 65,50 65,50 55,50 55,50" />
                                    </g>
                                    <!-- Axes -->
                                    <g stroke="rgba(51, 51, 51, 0.2)" stroke-width="0.5" opacity="0.5">
                                        <line x1="60" y1="60" x2="60" y2="10" />
                                        <line x1="60" y1="60" x2="95" y2="35" />
                                        <line x1="60" y1="60" x2="85" y2="75" />
                                        <line x1="60" y1="60" x2="35" y2="75" />
                                        <line x1="60" y1="60" x2="25" y2="35" />
                                    </g>
                                    <!-- Data polygon -->
                                    <polygon points="60,12 93,36 82,73 40,73 27,37" 
                                             fill="rgba(212, 175, 55, 0.3)" 
                                             stroke="#D4AF37" 
                                             stroke-width="1.5" />
                                    <!-- Data points -->
                                    <g fill="#D4AF37" stroke="#D4AF37" stroke-width="1">
                                        <circle cx="60" cy="12" r="2" />
                                        <circle cx="93" cy="36" r="2" />
                                        <circle cx="82" cy="73" r="2" />
                                        <circle cx="40" cy="73" r="2" />
                                        <circle cx="27" cy="37" r="2" />
                                    </g>
                                    <!-- Labels -->
                                    <g font-size="8" font-weight="600" text-anchor="middle" fill="#333">
                                        <text x="60" y="8">O</text>
                                        <text x="98" y="38">C</text>
                                        <text x="88" y="78">E</text>
                                        <text x="32" y="78">A</text>
                                        <text x="22" y="38">N</text>
                                    </g>
                                </svg>
                            </div>
                        </div>
                    </div>
                    
                    <div class="card-content" style="padding: 12px 25px 150px 25px;">
                        <h1 class="artwork-title" id="personaName">CONSPIRACYEL</h1>
                        <h2 class="artwork-subtitle" id="personaTitle">Paranoid Problem Investigator</h2>
                        
                        <p class="artwork-details" id="personaDescription">
                            Nothing is a coincidence. Every bug is connected. The code is trying to tell us something...
                        </p>
                        
                        <p class="collection-info" id="personaTraits" style="margin-bottom: 200px; padding-bottom: 100px;">
                            Paranoid, pattern-seeking, suspicious, deep-thinking.<br>
                            An expert in pattern recognition, system thinking, uncovering hidden issues.
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <section class="projects-section" id="projects">
        <div class="projects-header">
            <h2 class="projects-title">Projects</h2>
        </div>

        <ul class="projects-list">
            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">The Daoist Sage AI Agent <span class="project-status status-case-study">Case Study</span></span>
                    <span class="project-year">2025</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>AI Development & RAG Systems</h3>
                                <p>A case study on grounding AI memory using a dedicated RAG (Retrieval-Augmented Generation) system to solve challenges of hallucination and unreliable memory in AI trading agents.</p>
                                <p>The core challenge emerged from developing an AI crypto trading agent where memory issues and hallucination severely limited reliability. AI hallucination causes confident generation of factually incorrect information, while fickle memory creates inability to recall crucial details from knowledge bases or maintain coherent context.</p>
                                <p>The solution involved building a Daoist Sage Agent using RAG as its foundational memory and accuracy mechanism. As Product Manager and Lead Developer, I handled the full process from ideation to conceptual deployment.</p>
                                <p>The future vision includes processing complex internal documentation and providing specialized, fact-checked assistance in regulated industries where precision and verifiability are crucial.</p>
                                <p><a href="https://github.com/el-fuegoso/daobot" class="project-link" target="_blank" rel="noopener noreferrer">‚ñ∂ View Code</a></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/daobot/agent-interface.jpg')">Agent Interface</div>
                                <div class="project-image" style="background-image: url('./images/daobot/rag-architecture.jpg')">RAG Architecture</div>
                                <div class="project-image" style="background-image: url('./images/daobot/memory-system.jpg')">Memory System</div>
                                <div class="project-image" style="background-image: url('./images/daobot/testing-results.jpg')">Testing Results</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>

            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">Eliza Trading Agent <span class="project-status status-pivoted">Pivoted</span></span>
                    <span class="project-year">2025</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>AI-Powered Memecoin Trading</h3>
                                <p>An attempt to develop an AI-powered memecoin trading bot to capitalize on Solana's volatility while managing risk.</p>
                                <p>The approach involved training Mistral 7B on Pump.fun launch patterns combined with Twitter sentiment analysis. Integration with 3Commas API as a provider allowed testing of hybrid DEX/CEX strategy through paper trading on the 3Commas platform.</p>
                                <p>The outcome was clear: the system was inconsistent and kept hallucinating on the signals being fed to it. The project was pivoted due to inability to achieve reliable trading consistency.</p>
                                <p>This failure led to valuable insights about AI reliability in financial applications and directly informed the development of the Daoist Sage Agent with its focus on grounded memory systems.</p>
                                <p><em>Project documentation available upon request</em></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/eliza/eliza-banner.jpg')">Eliza Banner</div>
                                <div class="project-image" style="background-image: url('./images/eliza/trading-interface.jpg')">Trading Interface</div>
                                <div class="project-image" style="background-image: url('./images/eliza/performance-metrics.jpg')">Performance Metrics</div>
                                <div class="project-image" style="background-image: url('./images/eliza/lessons-learned.jpg')">Lessons Learned</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>

            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">Kaiawhina Auckland</span>
                    <span class="project-year">2023 ‚Äì 2024</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>Activism & Social Justice</h3>
                                <p>In 2023, as global calls for a Free Palestine grew louder, I realized my skills and privilege needed redirecting. Joining Kaiawhina Auckland, I committed to honoring MƒÅori sovereignty, supporting Palestinian freedom, and advancing climate justice.</p>
                                <p>The work involves weekly marshal duties for activations, disrupting "business as usual" at corporate complicity sites, and learning that actions matter more than hashtags. The experience taught crucial lessons: data is power (using Signal to track police or counter protestors movements at demonstrations), access is activism (always providing wheelchair routes and live captions), and joy is resistance (singing waiata at 5am blockades).</p>
                                <p>This work reinforced that technology doesn't exist in a vacuum and provided hands-on experience in using tech skills for social justice organizing.</p>
                                <p><a href="https://www.instagram.com/kaiawhina_tamaki/" class="project-link" target="_blank" rel="noopener noreferrer">‚ñ∂ Learn About Kaiawhina</a></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/kaiawhina/demonstration-photography.jpg')">Demonstration Photography</div>
                                <div class="project-image" style="background-image: url('./images/kaiawhina/community-organizing.jpg')">Community Organizing</div>
                                <div class="project-image" style="background-image: url('./images/kaiawhina/marshall-training.jpg')">Marshall Training</div>
                                <div class="project-image" style="background-image: url('./images/kaiawhina/solidarity-actions.jpg')">Solidarity Actions</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>

            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">Drama School 202: The Illusion</span>
                    <span class="project-year">2023</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>Black Box Theatre Performance</h3>
                                <p>A reimagining of Tony Kushner's baroque meta-theatrical fantasy as a contemporary meditation on love, artifice, and the transformative power of storytelling under director Leo Gene Peters.</p>
                                <p>Our approach centered on staging the unreal by building a 1:1 cave to bring the audience into the world. We performed costume quick-changes in full view to highlight theatrical artifice and projected text fragments from Kushner's stage directions onto actors' bodies. The production challenged actors to master 17th-century verse while finding modern emotional truth.</p>
                                <p>As Theogenes - The Lover, I connected with the verbs that brought the character to life and genuinely fell in love on stage. I also taught yoga to the company every other day, helping connect with breath and body.</p>
                                <p><em>Performance archived in personal collection</em></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/drama/performance-photography.jpg')">Performance Photography</div>
                                <div class="project-image" style="background-image: url('./images/drama/behind-the-scenes.jpg')">Behind-the-Scenes</div>
                                <div class="project-image" style="background-image: url('./images/drama/cast-images.jpg')">Cast Images</div>
                                <div class="project-image" style="background-image: url('./images/drama/set-design.jpg')">Set Design</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>

            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">Vipassana Journey <span class="project-status status-ongoing">Ongoing</span></span>
                    <span class="project-year">2022 ‚Äì Present</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>Personal Practice & Mindfulness</h3>
                                <p>After burning out from building startups, I needed something no algorithm could provide. A way to sit with myself.</p>
                                <p>The practice involves 10 day silent retreats completed at Dhamma Medini, NZ, with an intention of twice daily meditation sits. The approach eschews apps and hacks in favor of just the breath, the body, and whatever arises.</p>
                                <p>The key insight: "It's not about achieving some perfect mental state, it's about seeing what's already there." This ongoing practice provides grounding and perspective that informs all other work.</p>
                                <p>This foundation of mindfulness and presence has become integral to my approach to technology, bringing intention and awareness to how I build and interact with digital systems.</p>
                                <p><a href="https://www.dhamma.org/en/index" class="project-link" target="_blank" rel="noopener noreferrer">‚ñ∂ Learn More</a></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/vipassana/retreat-photography.jpg')">Retreat Photography</div>
                                <div class="project-image" style="background-image: url('./images/vipassana/meditation-hall.jpg')">Meditation Hall</div>
                                <div class="project-image" style="background-image: url('./images/vipassana/dhamma-medini.jpg')">Dhamma Medini</div>
                                <div class="project-image" style="background-image: url('./images/vipassana/silent-reflection.jpg')">Silent Reflection</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>

            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">Talent Army <span class="project-status status-award">Award Winner</span></span>
                    <span class="project-year">2022</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>Best UX Design, NZ Tech Innovation | Psychoactive</h3>
                                <p>A reimagining of tech recruitment as a dynamic growth journey, replacing sterile job boards with living stories of career transformation.</p>
                                <p>The narrative-driven web experience featured claymation-style 3D animations, spontaneous "Easter egg" movements, and visual storytelling for both employers and candidates. The intelligent job board included custom API syncing between Webflow and JobAdder in real-time, JetBoost filtering that felt like Tinder for dream jobs, and Kiwi-tech coded icons replacing generic briefcase symbols.</p>
                                <p>As Account Manager, I won the pitch against 4 agencies by demonstrating how storytelling reduces candidate drop-off. As Conductor, I managed 6 specialists across 3 timezones, and as Bridge Builder, I translated recruiter pain points into playful interactions.</p>
                                <p>The project was shortlisted for 2023 Webby Awards and became Talent Army's flagship client acquisition tool.</p>
                                <p><a href="https://www.talent.army/" class="project-link" target="_blank" rel="noopener noreferrer">‚ñ∂ View Live Site</a></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/talent-army/homepage-design.jpg')">Homepage Design</div>
                                <div class="project-image" style="background-image: url('./images/talent-army/job-board-interface.jpg')">Job Board Interface</div>
                                <div class="project-image" style="background-image: url('./images/talent-army/3d-animation-examples.jpg')">3D Animation Examples</div>
                                <div class="project-image" style="background-image: url('./images/talent-army/awards-recognition.jpg')">Awards Recognition</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>

            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">Blackbird VC</span>
                    <span class="project-year">2022</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>Australia | Psychoactive</h3>
                                <p>Blackbird VC needed a digital presence as bold as their investments. One that would make founders feel seen, not just pitched to.</p>
                                <p>We abandoned the tired "suits shaking hands" aesthetic and built an electric visual language featuring handmade documentary photography of real founders and bespoke animations mimicking startup momentum. The functional artistry organized content like a gallery with no buried decks, and interactive founder stories triggered by scroll velocity.</p>
                                <p>My role as Deal Maker involved working with the development team and Blackbird to envision a website that was both achievable and visually stunning, creating a rebellion against traditional VC digital clich√©s.</p>
                                <p><a href="https://www.blackbird.vc/home-hub" class="project-link" target="_blank" rel="noopener noreferrer">‚ñ∂ View Project</a></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/blackbird/homepage-design.jpg')">Homepage Design</div>
                                <div class="project-image" style="background-image: url('./images/blackbird/portfolio-layout.jpg')">Portfolio Layout</div>
                                <div class="project-image" style="background-image: url('./images/blackbird/founder-stories-interface.jpg')">Founder Stories Interface</div>
                                <div class="project-image" style="background-image: url('./images/blackbird/interactive-elements.jpg')">Interactive Elements</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>

            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">121 Festival</span>
                    <span class="project-year">2021</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>Entertainment Technology | Psychoactive</h3>
                                <p>Wellington's legendary Club 121 needed a website that could bottle their underground energy and pour it across screens nationwide. A digital mainstage for their debut festival.</p>
                                <p>The project featured psychedelic Kiwi immersion with native flora and fauna illustrations pulsing to ambient basslines, hover-triggered soundwave animations, and lineup reveals that felt like uncovering secret set times at the venue. The technical backbone included an Airtable/Zapier CMS allowing real-time vendor applications and volunteer coordination.</p>
                                <p>As Project Manager, I pitched the "digital doof" concept after attending 3 club nights for research. As Systems Architect, I streamlined 14 stakeholder workflows into one unified backend while balancing festival chaos with UX clarity.</p>
                                <p><em>Festival concluded - site archived</em></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/121-festival/homepage-design.jpg')">Homepage Design</div>
                                <div class="project-image" style="background-image: url('./images/121-festival/content-management-interface.jpg')">Content Management Interface</div>
                                <div class="project-image" style="background-image: url('./images/121-festival/interactive-elements.jpg')">Interactive Elements</div>
                                <div class="project-image" style="background-image: url('./images/121-festival/festival-branding.jpg')">Festival Branding</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>
        </ul>
    </section>

    <section class="contact-section" id="contact">
        <div class="contact-header">
            <h2 class="contact-title">Contact</h2>
        </div>
        
        <div class="contact-buttons">
            <a href="https://github.com/el-fuegoso" class="contact-button" target="_blank" rel="noopener noreferrer">
                <span>GitHub</span>
            </a>
            <a href="https://www.linkedin.com/in/elliot-james-lee" class="contact-button" target="_blank" rel="noopener noreferrer">
                <span>LinkedIn</span>
            </a>
            <a href="mailto:elliotjameslee8@gmail.com" class="contact-button">
                <span>Email</span>
            </a>
            <a href="https://www.instagram.com/elliot.james.lee/" class="contact-button" target="_blank" rel="noopener noreferrer">
                <span>Instagram</span>
            </a>
        </div>
    </section>

    <div class="performance-info" id="performanceInfo">
        Performance: Optimized
    </div>

    <!-- Configuration and main application scripts now in js/main.js -->
    <script>
        const CONFIG = {
            artifacts: {
                hankies: { 
                    resolution: window.innerWidth < 768 ? 16 : 32, 
                    animationSpeed: 0.0013 
                },
                particles: { 
                    count: window.innerWidth < 768 ? 15000 : 45000, 
                    opacity: 0.4 
                },
                ascii: {
                    width: window.innerWidth < 768 ? 45 : 65,
                    height: window.innerWidth < 768 ? 45 : 65
                },
                metamorphosis: {
                    numLines: window.innerWidth < 768 ? 60 : 120,
                    lineSegments: window.innerWidth < 768 ? 90 : 180
                },
                sineWaves: {
                    layers: window.innerWidth < 768 ? 40 : 80,
                    points: window.innerWidth < 768 ? 100 : 200
                }
            },
            transitions: { duration: 1200, delay: 150 },
            titles: ["ELLIOT LEE", "PRODUCT MANAGER", "BUILDER", "ACCOUNT MANAGER", "HUMAN"]
        };

        // Performance monitoring configuration
        const PERFORMANCE_CONFIG = {
            battery: {
                lowThreshold: 0.2,
                criticalThreshold: 0.1
            },
            thermal: {
                throttleTemp: 45, // Celsius
                shutdownTemp: 55
            },
            network: {
                slowConnection: ['slow-2g', '2g'],
                fastConnection: ['4g', '5g']
            },
            performance: {
                targetFPS: 60,
                minFPS: 30
            }
        };

        // Mobile Performance Manager
        class MobilePerformanceManager {
            constructor() {
                this.isLowPower = false;
                this.isCriticalMode = false;
                this.currentFPS = 60;
                this.frameCount = 0;
                this.lastFPSUpdate = Date.now();
                this.originalConfig = this.backupConfig();
                this.setupMonitoring();
            }
            
            backupConfig() {
                return JSON.parse(JSON.stringify(CONFIG.artifacts));
            }
            
            async setupMonitoring() {
                // Battery API monitoring
                if ('getBattery' in navigator) {
                    try {
                        const battery = await navigator.getBattery();
                        this.monitorBattery(battery);
                    } catch (e) {
                        console.log('Battery API not available');
                    }
                }
                
                // Network connection monitoring
                if ('connection' in navigator) {
                    this.monitorConnection();
                }
                
                // Frame rate monitoring
                this.startFPSMonitoring();
                
                // Visibility change optimization
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        this.pauseHeavyAnimations();
                    } else {
                        this.resumeAnimations();
                    }
                });
                
                // Device memory monitoring (if available)
                if ('deviceMemory' in navigator && navigator.deviceMemory < 4) {
                    this.enableLowMemoryMode();
                }
            }
            
            monitorBattery(battery) {
                const checkBattery = () => {
                    const batteryInfo = {
                        level: battery.level,
                        charging: battery.charging,
                        chargingTime: battery.chargingTime,
                        dischargingTime: battery.dischargingTime
                    };
                    
                    if (battery.level < PERFORMANCE_CONFIG.battery.criticalThreshold) {
                        this.enableCriticalMode(batteryInfo);
                    } else if (battery.level < PERFORMANCE_CONFIG.battery.lowThreshold) {
                        this.enableLowPowerMode(batteryInfo);
                    } else if (!battery.charging && this.isLowPower) {
                        // Only disable low power if we're not charging and battery is good
                        this.disableLowPowerMode();
                    }
                };
                
                battery.addEventListener('levelchange', checkBattery);
                battery.addEventListener('chargingchange', checkBattery);
                checkBattery();
            }
            
            monitorConnection() {
                const connection = navigator.connection;
                const checkConnection = () => {
                    if (PERFORMANCE_CONFIG.network.slowConnection.includes(connection.effectiveType)) {
                        this.enableLowBandwidthMode();
                    } else if (PERFORMANCE_CONFIG.network.fastConnection.includes(connection.effectiveType)) {
                        this.disableLowBandwidthMode();
                    }
                };
                
                connection.addEventListener('change', checkConnection);
                checkConnection();
            }
            
            startFPSMonitoring() {
                const measureFPS = () => {
                    this.frameCount++;
                    const now = Date.now();
                    
                    if (now - this.lastFPSUpdate >= 1000) {
                        this.currentFPS = this.frameCount;
                        this.frameCount = 0;
                        this.lastFPSUpdate = now;
                        
                        // Adjust performance based on FPS
                        if (this.currentFPS < PERFORMANCE_CONFIG.performance.minFPS && !this.isLowPower) {
                            this.enablePerformanceMode();
                        }
                        
                        this.updatePerformanceIndicator();
                    }
                    
                    requestAnimationFrame(measureFPS);
                };
                measureFPS();
            }
            
            enableLowPowerMode(batteryInfo = null) {
                if (this.isLowPower) return;
                this.isLowPower = true;
                
                // Reduce particle counts by 75%
                CONFIG.artifacts.particles.count = Math.floor(this.originalConfig.particles.count * 0.25);
                CONFIG.artifacts.hankies.resolution = Math.floor(this.originalConfig.hankies.resolution * 0.5);
                CONFIG.artifacts.ascii.width = Math.floor(this.originalConfig.ascii.width * 0.7);
                CONFIG.artifacts.ascii.height = Math.floor(this.originalConfig.ascii.height * 0.7);
                CONFIG.artifacts.metamorphosis.numLines = Math.floor(this.originalConfig.metamorphosis.numLines * 0.5);
                CONFIG.artifacts.metamorphosis.lineSegments = Math.floor(this.originalConfig.metamorphosis.lineSegments * 0.5);
                CONFIG.artifacts.sineWaves.layers = Math.floor(this.originalConfig.sineWaves.layers * 0.5);
                CONFIG.artifacts.sineWaves.points = Math.floor(this.originalConfig.sineWaves.points * 0.5);
                
                // Reduce animation speeds
                CONFIG.artifacts.hankies.animationSpeed *= 0.5;
                
                // Show low power indicator
                const message = batteryInfo ? 
                    `Low Power Mode: ${Math.round(batteryInfo.level * 100)}% battery` : 
                    'Low Power Mode Active';
                this.showPowerModeIndicator(message, '#ff9500');
                
                // Restart current artifact with new settings
                this.restartCurrentArtifact();
                
                console.log('Low power mode enabled', batteryInfo);
            }
            
            enableCriticalMode(batteryInfo) {
                if (this.isCriticalMode) return;
                this.isCriticalMode = true;
                this.isLowPower = true;
                
                // Stop all animations except essential UI
                this.pauseAllArtifacts();
                this.showPowerModeIndicator(
                    `Critical Battery: ${Math.round(batteryInfo.level * 100)}% - Animations Paused`, 
                    '#ff3300'
                );
                console.log('Critical battery mode enabled', batteryInfo);
            }
            
            enablePerformanceMode() {
                // Automatically reduce settings when FPS drops
                CONFIG.artifacts.particles.count = Math.floor(CONFIG.artifacts.particles.count * 0.8);
                CONFIG.artifacts.hankies.resolution = Math.max(8, Math.floor(CONFIG.artifacts.hankies.resolution * 0.8));
                
                this.showPowerModeIndicator(`Performance Mode: ${this.currentFPS}fps`, '#ffa500');
                this.restartCurrentArtifact();
            }
            
            enableLowMemoryMode() {
                CONFIG.artifacts.particles.count = Math.floor(CONFIG.artifacts.particles.count * 0.6);
                CONFIG.artifacts.ascii.width = Math.floor(CONFIG.artifacts.ascii.width * 0.8);
                CONFIG.artifacts.ascii.height = Math.floor(CONFIG.artifacts.ascii.height * 0.8);
                
                this.showPowerModeIndicator('Low Memory Mode', '#ff6600');
                console.log('Low memory mode enabled');
            }
            
            enableLowBandwidthMode() {
                // Reduce update frequencies for network-dependent features
                CONFIG.transitions.duration = Math.min(CONFIG.transitions.duration * 1.5, 2000);
                this.showPowerModeIndicator('Slow Connection Detected', '#666666');
            }
            
            disableLowPowerMode() {
                if (!this.isLowPower) return;
                this.isLowPower = false;
                this.isCriticalMode = false;
                
                // Restore original settings
                CONFIG.artifacts = JSON.parse(JSON.stringify(this.originalConfig));
                
                this.hidePowerModeIndicator();
                this.restartCurrentArtifact();
                console.log('Low power mode disabled');
            }
            
            disableLowBandwidthMode() {
                CONFIG.transitions.duration = 1200; // Reset to default
            }
            
            pauseHeavyAnimations() {
                // Pause current artifact animations
                if (window.currentArtifactAnimation) {
                    cancelAnimationFrame(window.currentArtifactAnimation);
                }
                
                // Pause Three.js rendering
                Object.values(threeScenes).forEach(scene => {
                    if (scene.renderer && scene.renderer.setAnimationLoop) {
                        scene.renderer.setAnimationLoop(null);
                    }
                });
            }
            
            pauseAllArtifacts() {
                this.pauseHeavyAnimations();
                // Set black background to save energy
                document.body.style.background = '#000000';
            }
            
            resumeAnimations() {
                if (!this.isCriticalMode && !document.hidden) {
                    // Restart current artifact if not in critical mode
                    if (typeof artifacts !== 'undefined' && artifacts[currentArtifact]) {
                        artifacts[currentArtifact]();
                    }
                    
                    // Restore background
                    document.body.style.background = '';
                }
            }
            
            restartCurrentArtifact() {
                if (this.isCriticalMode) return;
                
                // Clean up current artifact
                if (threeScenes[`artifact-${currentArtifact + 1}`]?.cleanup) {
                    threeScenes[`artifact-${currentArtifact + 1}`].cleanup();
                }
                
                // Restart with new settings
                setTimeout(() => {
                    if (artifacts[currentArtifact]) {
                        artifacts[currentArtifact]();
                    }
                }, 100);
            }
            
            showPowerModeIndicator(message, color = '#ff9500') {
                let indicator = document.getElementById('powerModeIndicator');
                if (!indicator) {
                    indicator = document.createElement('div');
                    indicator.id = 'powerModeIndicator';
                    indicator.style.cssText = `
                        position: fixed;
                        top: 80px;
                        right: 20px;
                        background: ${color};
                        color: white;
                        padding: 8px 12px;
                        border-radius: 4px;
                        font-size: 12px;
                        z-index: 1002;
                        font-family: 'Roboto Mono', monospace;
                        max-width: 200px;
                        text-align: center;
                        animation: slideInRight 0.3s ease-out;
                    `;
                    document.body.appendChild(indicator);
                    
                    // Add animation
                    const style = document.createElement('style');
                    style.textContent = `
                        @keyframes slideInRight {
                            from { transform: translateX(100%); opacity: 0; }
                            to { transform: translateX(0); opacity: 1; }
                        }
                    `;
                    document.head.appendChild(style);
                } else {
                    indicator.style.background = color;
                }
                indicator.textContent = message;
            }
            
            hidePowerModeIndicator() {
                const indicator = document.getElementById('powerModeIndicator');
                if (indicator) {
                    indicator.style.animation = 'slideInRight 0.3s ease-out reverse';
                    setTimeout(() => indicator.remove(), 300);
                }
            }
            
            updatePerformanceIndicator() {
                const perfInfo = document.getElementById('performanceInfo');
                if (perfInfo) {
                    let status = 'Optimized';
                    let color = '#00ff00';
                    
                    if (this.isCriticalMode) {
                        status = 'Critical Battery';
                        color = '#ff3300';
                    } else if (this.isLowPower) {
                        status = 'Low Power';
                        color = '#ff9500';
                    } else if (this.currentFPS < PERFORMANCE_CONFIG.performance.minFPS) {
                        status = `${this.currentFPS}fps`;
                        color = '#ffa500';
                    }
                    
                    perfInfo.textContent = `Performance: ${status}`;
                    perfInfo.style.color = color;
                }
            }
        }

        // Enhanced Mobile Accessibility Manager
        class MobileAccessibilityManager {
            constructor() {
                this.setupMobileA11y();
                this.setupScreenReaderSupport();
                this.setupVoiceOverSupport();
                this.setupTalkBackSupport();
                this.addLiveRegions();
            }
            
            setupMobileA11y() {
                // Enhanced focus management for mobile
                document.addEventListener('focusin', (e) => {
                    const target = e.target;
                    
                    // Ensure focused element is visible on mobile
                    if (target.classList.contains('glitch-title') || 
                        target.classList.contains('spark-magic') ||
                        target.classList.contains('chat-control-btn')) {
                        target.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'center',
                            inline: 'nearest'
                        });
                    }
                    
                    // Add focus announcement for screen readers
                    if (target.hasAttribute('aria-label')) {
                        this.announceToScreenReader(`Focused: ${target.getAttribute('aria-label')}`);
                    }
                });
                
                // Enhanced keyboard navigation
                document.addEventListener('keydown', (e) => {
                    // Handle escape key to close modals
                    if (e.key === 'Escape') {
                        this.handleEscapeKey();
                    }
                    
                    // Handle arrow keys for artifact navigation
                    if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                        const activeElement = document.activeElement;
                        if (activeElement.classList.contains('glitch-title') || 
                            activeElement.classList.contains('spark-magic')) {
                            e.preventDefault();
                            
                            if (e.key === 'ArrowRight') {
                                changeEverything();
                                this.announceToScreenReader('Next experience loaded');
                            } else if (window.gestureManager?.previousArtifact) {
                                window.gestureManager.previousArtifact();
                                this.announceToScreenReader('Previous experience loaded');
                            }
                        }
                    }
                });
            }
            
            addLiveRegions() {
                // Create ARIA live region for dynamic announcements
                const liveRegion = document.createElement('div');
                liveRegion.setAttribute('aria-live', 'polite');
                liveRegion.setAttribute('aria-atomic', 'true');
                liveRegion.setAttribute('id', 'liveRegion');
                liveRegion.className = 'sr-only';
                liveRegion.style.cssText = `
                    position: absolute;
                    width: 1px;
                    height: 1px;
                    padding: 0;
                    margin: -1px;
                    overflow: hidden;
                    clip: rect(0, 0, 0, 0);
                    white-space: nowrap;
                    border: 0;
                `;
                document.body.appendChild(liveRegion);
                
                // Create assertive live region for urgent announcements
                const assertiveRegion = document.createElement('div');
                assertiveRegion.setAttribute('aria-live', 'assertive');
                assertiveRegion.setAttribute('aria-atomic', 'true');
                assertiveRegion.setAttribute('id', 'assertiveRegion');
                assertiveRegion.className = 'sr-only';
                assertiveRegion.style.cssText = liveRegion.style.cssText;
                document.body.appendChild(assertiveRegion);
            }
            
            setupScreenReaderSupport() {
                // Enhance artifact change announcements
                const originalChangeEverything = window.changeEverything;
                window.changeEverything = () => {
                    originalChangeEverything.call(window);
                    
                    setTimeout(() => {
                        const currentTitle = CONFIG.titles[currentTitleIndex];
                        const experienceNumber = currentArtifact + 1;
                        this.announceToScreenReader(
                            `Now showing experience ${experienceNumber}: ${currentTitle} with interactive artwork`
                        );
                    }, 500);
                };
                
                // Add landmarks and structure
                this.addLandmarkRoles();
                this.enhanceFormAccessibility();
            }
            
            addLandmarkRoles() {
                // Add main landmark
                const heroContainer = document.querySelector('.hero-container');
                if (heroContainer) {
                    heroContainer.setAttribute('role', 'main');
                    heroContainer.setAttribute('aria-label', 'Portfolio showcase with interactive art');
                }
                
                // Add navigation landmark
                const navBar = document.querySelector('.nav-bar');
                if (navBar) {
                    navBar.setAttribute('role', 'navigation');
                    navBar.setAttribute('aria-label', 'Main navigation');
                }
                
                // Add complementary landmarks for sections
                const contactSection = document.querySelector('.contact-section');
                if (contactSection) {
                    contactSection.setAttribute('role', 'complementary');
                    contactSection.setAttribute('aria-label', 'Contact information');
                }
                
                const projectsSection = document.querySelector('.projects-section');
                if (projectsSection) {
                    projectsSection.setAttribute('role', 'region');
                    projectsSection.setAttribute('aria-label', 'Featured projects');
                }
            }
            
            enhanceFormAccessibility() {
                // Enhance chat input
                const messageInput = document.getElementById('messageInput');
                if (messageInput) {
                    messageInput.setAttribute('aria-describedby', 'messageInputDesc');
                    
                    const description = document.createElement('div');
                    description.id = 'messageInputDesc';
                    description.className = 'sr-only';
                    description.textContent = 'Type your message and press Enter to send';
                    messageInput.parentNode.insertBefore(description, messageInput);
                }
                
                // Enhance project items
                document.querySelectorAll('.project-item').forEach((item, index) => {
                    item.setAttribute('role', 'button');
                    item.setAttribute('aria-expanded', 'false');
                    item.setAttribute('aria-describedby', `project-desc-${index}`);
                    item.setAttribute('tabindex', '0');
                    
                    const originalToggle = item.onclick;
                    item.onclick = function() {
                        originalToggle.call(this);
                        const isOpen = this.classList.contains('open');
                        this.setAttribute('aria-expanded', isOpen.toString());
                        
                        const action = isOpen ? 'expanded' : 'collapsed';
                        window.accessibilityManager.announceToScreenReader(
                            `Project ${this.querySelector('.project-header').textContent} ${action}`
                        );
                    };
                    
                    // Add keyboard support
                    item.addEventListener('keydown', (e) => {
                        if (e.key === ' ' || e.key === 'Enter') {
                            e.preventDefault();
                            item.click();
                        }
                    });
                });
            }
            
            setupVoiceOverSupport() {
                // Enhanced VoiceOver navigation for iOS
                document.querySelector('.glitch-title').setAttribute(
                    'aria-description', 
                    'Interactive title that cycles through different professional identities and changes the background artwork. Swipe or use arrow keys to navigate.'
                );
                
                document.querySelector('.spark-magic').setAttribute(
                    'aria-description',
                    'Alternative control to cycle through visual experiences'
                );
                
                // Add VoiceOver-specific hint text
                if (this.isIOSDevice()) {
                    const voiceOverHints = document.createElement('div');
                    voiceOverHints.className = 'sr-only';
                    voiceOverHints.textContent = 'VoiceOver users: Use flick gestures to navigate between elements, and double-tap to activate. Swipe left or right on the main area to change experiences.';
                    document.body.appendChild(voiceOverHints);
                }
            }
            
            setupTalkBackSupport() {
                // Enhanced TalkBack support for Android
                if (this.isAndroidDevice()) {
                    // Add content descriptions for TalkBack
                    document.querySelectorAll('[role="button"]').forEach(button => {
                        if (!button.hasAttribute('aria-description')) {
                            const label = button.getAttribute('aria-label') || button.textContent;
                            button.setAttribute('aria-description', `Button: ${label}`);
                        }
                    });
                    
                    // Add TalkBack-specific instructions
                    const talkBackHints = document.createElement('div');
                    talkBackHints.className = 'sr-only';
                    talkBackHints.textContent = 'TalkBack users: Use explore by touch to navigate, and double-tap to activate elements. Swipe gestures change the visual experience.';
                    document.body.appendChild(talkBackHints);
                }
            }
            
            announceToScreenReader(message, urgent = false) {
                const regionId = urgent ? 'assertiveRegion' : 'liveRegion';
                const region = document.getElementById(regionId);
                if (region) {
                    // Clear first to ensure the announcement triggers
                    region.textContent = '';
                    setTimeout(() => {
                        region.textContent = message;
                    }, 100);
                    
                    // Clear after announcement
                    setTimeout(() => {
                        region.textContent = '';
                    }, 3000);
                }
            }
            
            handleEscapeKey() {
                // Close any open modals or overlays
                const chatOverlay = document.querySelector('.chat-overlay.active');
                if (chatOverlay) {
                    chatOverlay.classList.remove('active');
                    this.announceToScreenReader('Chat closed');
                    return;
                }
                
                const terminalOverlay = document.getElementById('terminalOverlay');
                if (terminalOverlay && terminalOverlay.style.display === 'block') {
                    terminalOverlay.style.display = 'none';
                    this.announceToScreenReader('Terminal closed');
                    return;
                }
                
                // Close any expanded project items
                const openProjects = document.querySelectorAll('.project-item.open');
                if (openProjects.length > 0) {
                    openProjects.forEach(project => {
                        project.classList.remove('open');
                        project.setAttribute('aria-expanded', 'false');
                    });
                    this.announceToScreenReader('All projects collapsed');
                }
            }
            
            isIOSDevice() {
                return /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                       (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            }
            
            isAndroidDevice() {
                return /Android/.test(navigator.userAgent);
            }
            
            // Performance mode accessibility adjustments
            adjustForPerformanceMode() {
                if (window.performanceManager?.isLowPower) {
                    // Reduce animation announcements in low power mode
                    this.announceToScreenReader('Low power mode active - reduced animations for better battery life');
                }
                
                if (window.performanceManager?.isCriticalMode) {
                    this.announceToScreenReader('Critical battery mode - animations paused to conserve power', true);
                }
            }
        }

        // Global state
        let currentArtifact = 0;
        let currentTheme = 'light';
        let currentTitleIndex = 0;
        let isTweening = false;
        let artifacts = [];
        let threeScenes = {};
        let isTransitioning = false;
        let resizeTimeout;
        let performanceMonitor = { fps: 0, lastTime: 0, frameCount: 0 };

        // Performance monitoring
        function updatePerformanceInfo() {
            performanceMonitor.frameCount++;
            const currentTime = performance.now();
            
            if (currentTime > performanceMonitor.lastTime + 1000) {
                performanceMonitor.fps = Math.round((performanceMonitor.frameCount * 1000) / (currentTime - performanceMonitor.lastTime));
                performanceMonitor.frameCount = 0;
                performanceMonitor.lastTime = currentTime;
                
                const perfInfo = document.getElementById('performanceInfo');
                if (perfInfo) {
                    const quality = performanceMonitor.fps > 45 ? 'Excellent' : 
                                   performanceMonitor.fps > 30 ? 'Good' : 'Basic';
                    perfInfo.textContent = `Performance: ${quality} (${performanceMonitor.fps} FPS)`;
                }
            }
        }

        // Error handling wrapper
        function safeInitArtifact(artifactFunction, artifactId, fallback = null) {
            try {
                artifactFunction();
            } catch (error) {
                console.warn(`Artifact ${artifactId} initialization failed:`, error);
                if (fallback) {
                    fallback();
                } else {
                    // Show error fallback
                    const container = document.getElementById(artifactId);
                    if (container) {
                        container.innerHTML = '<div class="error-fallback">Unable to load visualization</div>';
                    }
                }
            }
        }

        // Enhanced cleanup function
        function enhancedCleanup(scene, renderer, container, animationFrameId) {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            
            if (scene) {
                scene.traverse((object) => {
                    if (object.geometry) {
                        object.geometry.dispose();
                    }
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(material => material.dispose());
                        } else {
                            object.material.dispose();
                        }
                    }
                });
            }
            
            if (renderer) {
                renderer.dispose();
                if (renderer.domElement && container && container.contains(renderer.domElement)) {
                    container.removeChild(renderer.domElement);
                }
            }
        }

        // Accessibility: Keyboard event handler
        function handleKeyPress(event) {
            if (event.key === ' ' || event.key === 'Enter') {
                event.preventDefault();
                changeEverything();
            }
        }

        // Title cycling system
        function cycleTitle() {
            const titleElement = document.querySelector('.glitch-title');
            
            currentTitleIndex = (currentTitleIndex + 1) % CONFIG.titles.length;
            const newTitle = CONFIG.titles[currentTitleIndex];
            
            gsap.to(titleElement, {
                duration: 1.2,
                text: {
                    value: newTitle,
                    delimiter: ""
                },
                ease: "none"
            });
        }

        // Combined function that changes both title and artifact
        function changeEverything() {
            if (isTransitioning) return;
            isTransitioning = true;
            
            // Trigger title glitch
            cycleTitle();
            
            // Change artifact with slight delay for dramatic effect
            setTimeout(() => {
                changeArtifact();
                setTimeout(() => {
                    isTransitioning = false;
                }, CONFIG.transitions.duration);
            }, CONFIG.transitions.delay);
            
            // Visual feedback for buttons
            const activeElement = document.activeElement;
            if (activeElement.classList.contains('spark-magic') || activeElement.classList.contains('glitch-title')) {
                activeElement.style.transform = 'scale(1.2)';
                setTimeout(() => {
                    activeElement.style.transform = '';
                }, 200);
            }
        }

        // Initialize artifacts
        function initializeArtifacts() {
            artifacts = [
                () => safeInitArtifact(initHankiesInTheWind, 'artifact-1'),
                () => safeInitArtifact(initAsciiBinaryFlow, 'artifact-2'),
                () => safeInitArtifact(initParticleVessel, 'artifact-3'),
                () => safeInitArtifact(initMetamorphosis, 'artifact-4'),
                () => safeInitArtifact(initLayeredSineWaves, 'artifact-5')
            ];
            
            // Initialize the first artifact
            artifacts[0]();
        }

        // Artifact 1: Enhanced HankiesInTheWind
        function initHankiesInTheWind() {
            const container = document.getElementById('artifact-1');
            if (container.hasChildNodes()) return;
            
            let scene, camera, renderer, lineGroups = [];
            let animationFrameId;
            
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ 
                antialias: !window.matchMedia('(max-width: 768px)').matches,
                powerPreference: "high-performance"
            });
            
            renderer.setSize(width, height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(currentTheme === 'dark' ? 0x1a1a1a : 0xF0EEE6);
            container.appendChild(renderer.domElement);
            
            camera.position.set(0, 0, 6);
            camera.lookAt(0, 0, 0);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(5, 5, 5);
            scene.add(ambientLight);
            scene.add(directionalLight);
            
            const mainGroup = new THREE.Group();
            scene.add(mainGroup);
            
            let time = 0;
            
            function createWaveSources(time, scale) {
                const result = [];
                const count = 5;
                
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const radius = scale * (1 + Math.sin(angle * 3) * 0.2);
                    
                    result.push({
                        position: [
                            Math.cos(angle) * radius,
                            0,
                            Math.sin(angle) * radius
                        ],
                        frequency: 2 + Math.sin(angle * 2),
                        amplitude: 0.3 + Math.cos(angle) * 0.1,
                        phase: time * 3 + angle
                    });
                }
                
                result.push({
                    position: [0, 0, 0],
                    frequency: 3,
                    amplitude: 0.4,
                    phase: time * 4
                });
                
                return result;
            }
            
            function createInterferenceField(sources, size, resolution, time) {
                const step = size / resolution;
                const heightMap = [];
                
                for (let i = 0; i <= resolution; i++) {
                    heightMap[i] = [];
                    const x = (i * step) - (size / 2);
                    
                    for (let j = 0; j <= resolution; j++) {
                        const z = (j * step) - (size / 2);
                        let height = 0;
                        
                        sources.forEach(({ position: [sx, sy, sz], frequency, amplitude, phase }) => {
                            const dx = x - sx;
                            const dz = z - sz;
                            const distance = Math.sqrt(dx * dx + dz * dz);
                            height += Math.sin(distance * frequency - time * 5 + phase) * 
                                     amplitude * Math.exp(-distance * 0.3);
                        });
                        
                        heightMap[i][j] = height;
                    }
                }
                
                const linesMaterial = new THREE.LineBasicMaterial({ 
                    color: currentTheme === 'dark' ? 0xffffff : 0x333333,
                    transparent: true,
                    opacity: 0.4
                });
                
                const linesGroup = new THREE.Group();
                
                // Create horizontal lines
                for (let i = 0; i <= resolution; i++) {
                    const geometry = new THREE.BufferGeometry();
                    const points = [];
                    const x = (i * step) - (size / 2);
                    
                    for (let j = 0; j <= resolution; j++) {
                        const z = (j * step) - (size / 2);
                        points.push(x, heightMap[i][j], z);
                    }
                    
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
                    const line = new THREE.Line(geometry, linesMaterial);
                    linesGroup.add(line);
                }
                
                // Create vertical lines
                for (let j = 0; j <= resolution; j++) {
                    const geometry = new THREE.BufferGeometry();
                    const points = [];
                    const z = (j * step) - (size / 2);
                    
                    for (let i = 0; i <= resolution; i++) {
                        const x = (i * step) - (size / 2);
                        points.push(x, heightMap[i][j], z);
                    }
                    
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
                    const line = new THREE.Line(geometry, linesMaterial);
                    linesGroup.add(line);
                }
                
                return linesGroup;
            }
            
            function animate() {
                animationFrameId = requestAnimationFrame(animate);
                time += CONFIG.artifacts.hankies.animationSpeed;
                
                updatePerformanceInfo();
                
                // Clear previous groups
                mainGroup.children.forEach(child => {
                    if (child instanceof THREE.Group) {
                        child.children.forEach(line => {
                            if (line.geometry) line.geometry.dispose();
                            if (line.material) line.material.dispose();
                        });
                        mainGroup.remove(child);
                    }
                });
                
                // Create new interference fields
                const sources1 = createWaveSources(time, 1.5);
                const field1 = createInterferenceField(sources1, 1.5 * 4, CONFIG.artifacts.hankies.resolution, time);
                mainGroup.add(field1);
                
                const sources2 = createWaveSources(time + 0.33, 0.8);
                const field2 = createInterferenceField(sources2, 0.8 * 4, CONFIG.artifacts.hankies.resolution, time + 0.33);
                field2.position.set(0, 1.5, 0);
                field2.rotation.set(Math.PI/6, 0, Math.PI/4);
                mainGroup.add(field2);
                
                mainGroup.rotation.y = Math.sin(time * 0.3) * 0.2;
                mainGroup.rotation.x = Math.cos(time * 0.2) * 0.1;
                
                renderer.render(scene, camera);
            }
            
            animate();
            
            // Store for cleanup
            threeScenes['artifact-1'] = {
                cleanup: () => enhancedCleanup(scene, renderer, container, animationFrameId)
            };
        }

        // Artifact 2: Enhanced AsciiBinaryFlow
        function initAsciiBinaryFlow() {
            const container = document.querySelector('#artifact-2 .ascii-container');
            if (container.dataset.initialized) return;
            container.dataset.initialized = 'true';
            
            let width = CONFIG.artifacts.ascii.width;
            let height = CONFIG.artifacts.ascii.height;
            let grid = [];
            let time = 0;
            let animationFrameId;
            
            function initGrid() {
                grid = [];
                for (let y = 0; y < height; y++) {
                    let row = [];
                    for (let x = 0; x < width; x++) {
                        row.push(' ');
                    }
                    grid.push(row);
                }
            }
            
            function render() {
                let html = '';
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        html += grid[y][x];
                    }
                    html += '<br>';
                }
                container.innerHTML = html;
            }
            
            function update() {
                initGrid();
                
                const blockSize = Math.floor(width * 0.46);
                const blockX = Math.floor(width / 2 - blockSize / 2);
                const blockY = Math.floor(height / 2 - blockSize / 2);
                const t = time * 0.005;
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        if (x >= blockX && x < blockX + blockSize && 
                            y >= blockY && y < blockY + blockSize) {
                            const innerDist = Math.min(
                                x - blockX, 
                                blockX + blockSize - x,
                                y - blockY,
                                blockY + blockSize - y
                            );
                            
                            const erosion = time * 0.0067;
                            if (innerDist > erosion) {
                                grid[y][x] = '1';
                            } else {
                                grid[y][x] = Math.random() > 0.8 ? '1' : '0';
                            }
                        } else {
                            const dx = x - width / 2;
                            const dy = y - height / 2;
                            const angle = Math.atan2(dy, dx);
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            const wave = Math.sin(dist * 0.2 - t + angle * 1.5);
                            const flow = Math.sin(x * 0.08 + y * 0.04 + t * 0.4);
                            
                            if (flow + wave > 0.4) {
                                grid[y][x] = '0';
                            } else if (flow + wave < -0.4) {
                                grid[y][x] = '~';
                            }
                        }
                    }
                }
                
                // Add cracks
                for (let i = 0; i < 5; i++) {
                    const crackX = blockX + Math.floor(Math.random() * blockSize);
                    const crackY = blockY + Math.floor(Math.random() * blockSize);
                    const length = Math.floor(Math.random() * 10) + 5;
                    let cx = Math.floor(crackX);
                    let cy = Math.floor(crackY);
                    
                    for (let j = 0; j < length; j++) {
                        if (cx >= 0 && cx < width && cy >= 0 && cy < height) {
                            grid[cy][cx] = '0';
                        }
                        cx += Math.floor(Math.random() * 3) - 1;
                        cy += Math.floor(Math.random() * 3) - 1;
                    }
                }
                
                time++;
            }
            
            function animate() {
                update();
                render();
                updatePerformanceInfo();
                animationFrameId = requestAnimationFrame(animate);
            }
            
            initGrid();
            animate();
            
            // Store for cleanup
            threeScenes['artifact-2'] = {
                cleanup: () => {
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    container.innerHTML = '';
                    container.dataset.initialized = '';
                }
            };
        }

        // Artifact 3: Enhanced ParticleVessel
        function initParticleVessel() {
            const container = document.getElementById('artifact-3');
            if (container.hasChildNodes()) return;
            
            let scene, camera, renderer, animationFrameId;
            const count = CONFIG.artifacts.particles.count;
            
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ 
                antialias: !window.matchMedia('(max-width: 768px)').matches,
                powerPreference: "high-performance"
            });
            
            renderer.setSize(width, height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(currentTheme === 'dark' ? 0x1a1a1a : 0xF0EEE6);
            container.appendChild(renderer.domElement);
            
            camera.position.z = 5;
            
            const particleMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    opacity: { value: CONFIG.artifacts.particles.opacity }
                },
                vertexShader: `
                    uniform float time;
                    attribute float size;
                    attribute vec3 customColor;
                    varying vec3 vColor;
                    
                    void main() {
                        vColor = customColor;
                        vec3 pos = position;
                        
                        float radius = length(pos.xz);
                        float angle = atan(pos.z, pos.x);
                        float height = pos.y;
                        
                        float vessel = smoothstep(0.3, 0.7, radius) * smoothstep(1.0, 0.7, radius);
                        
                        angle += time * 0.08;
                        
                        float space = sin(time * 0.3 + radius * 3.0) * 0.1;
                        
                        float newRadius = (radius + space) * vessel;
                        
                        vec3 newPos;
                        newPos.x = cos(angle) * newRadius;
                        newPos.z = sin(angle) * newRadius;
                        newPos.y = height * vessel - 1.2;
                        
                        newPos *= 2.75;
                        
                        vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);
                        gl_PointSize = size * (128.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform float opacity;
                    varying vec3 vColor;
                    void main() {
                        vec2 center = gl_PointCoord - vec2(0.5);
                        float dist = dot(center, center);
                        
                        if (dist > 0.25) discard;
                        
                        float alpha = (1.0 - smoothstep(0.2025, 0.25, dist)) * opacity;
                        gl_FragColor = vec4(vColor, alpha);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.NormalBlending
            });
            
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            
            let i3 = 0;
            for (let i = 0; i < count; i++) {
                const t = i / count;
                const radius = Math.pow(t, 0.5);
                const angle = t * Math.PI * 40;
                
                const vesselHeight = Math.sin(t * Math.PI) * 1.8;
                
                const randRadius = radius + (Math.random() - 0.5) * 0.05;
                const randAngle = angle + (Math.random() - 0.5) * 0.1;
                
                positions[i3] = Math.cos(randAngle) * randRadius;
                positions[i3 + 1] = vesselHeight;
                positions[i3 + 2] = Math.sin(randAngle) * randRadius;

                const shade = currentTheme === 'dark' ? 
                    (0.8 + Math.sqrt(radius) * 0.2 + Math.random() * 0.1) :
                    (0.1 + Math.sqrt(radius) * 0.1 + Math.random() * 0.02);
                colors[i3] = shade;
                colors[i3 + 1] = shade;
                colors[i3 + 2] = shade;

                sizes[i] = (1.0 - Math.abs(vesselHeight * 0.5)) * 0.2 + 0.1;
                
                i3 += 3;
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const points = new THREE.Points(geometry, particleMaterial);
            scene.add(points);
            
            const clock = new THREE.Clock();
            
            function animate() {
                animationFrameId = requestAnimationFrame(animate);
                
                const time = clock.getElapsedTime();
                particleMaterial.uniforms.time.value = time;
                
                updatePerformanceInfo();
                renderer.render(scene, camera);
            }
            
            animate();
            
            threeScenes['artifact-3'] = {
                cleanup: () => enhancedCleanup(scene, renderer, container, animationFrameId)
            };
        }

        // Artifact 4: Enhanced Metamorphosis
        function initMetamorphosis() {
            const canvas = document.querySelector('#artifact-4 canvas');
            if (canvas.dataset.initialized) return;
            canvas.dataset.initialized = 'true';
            
            const ctx = canvas.getContext('2d', { willReadFrequently: false });
            const width = canvas.width;
            const height = canvas.height;
            
            let animationFrameId;
            let time = 2000;
            
            const numLines = CONFIG.artifacts.metamorphosis.numLines;
            const lineSegments = CONFIG.artifacts.metamorphosis.lineSegments;
            const lineAlpha = 0.5;
            const lineWidth = 0.6;
            
            const forms = [
                // Form 1: Draped cloth-like shape
                (u, v, t) => {
                    const theta = u * Math.PI * 2;
                    const phi = v * Math.PI;
                    
                    let r = 120 + 30 * Math.sin(phi * 4 + theta * 2);
                    r += 20 * Math.sin(phi * 6) * Math.cos(theta * 3);
                    
                    let x = r * Math.sin(phi) * Math.cos(theta);
                    let y = r * Math.sin(phi) * Math.sin(theta);
                    let z = r * Math.cos(phi) + 20 * Math.sin(theta * 5 + phi * 3);
                    
                    return { x, y, z };
                },
                
                // Form 2: More angular folded shape
                (u, v, t) => {
                    const theta = u * Math.PI * 2;
                    const phi = v * Math.PI;
                    
                    let r = 150 + 20 * Math.cos(phi * 8);
                    r *= 0.8 + 0.2 * Math.abs(Math.cos(theta * 2));
                    
                    let x = r * Math.sin(phi) * Math.cos(theta);
                    let y = r * Math.sin(phi) * Math.sin(theta);
                    let z = r * Math.cos(phi) * (0.8 + 0.3 * Math.sin(theta * 4));
                    
                    return { x, y, z };
                },
                
                // Form 3: Organic bulbous shape
                (u, v, t) => {
                    const theta = u * Math.PI * 2;
                    const phi = v * Math.PI;
                    
                    let r = 120;
                    r += 50 * Math.sin(phi * 3) * Math.sin(theta * 2.5);
                    r += 30 * Math.cos(phi * 5 + theta);
                    
                    let x = r * Math.sin(phi) * Math.cos(theta);
                    let y = r * Math.sin(phi) * Math.sin(theta);
                    let z = r * Math.cos(phi);
                    
                    const hollow = Math.max(0, Math.sin(phi * 2 + theta * 3) - 0.7);
                    r *= 1 - hollow * 0.8;
                    
                    return { x, y, z };
                }
            ];
            
            function interpolateForms(formA, formB, u, v, t, blend) {
                const pointA = formA(u, v, t);
                const pointB = formB(u, v, t);
                
                return {
                    x: pointA.x * (1 - blend) + pointB.x * blend,
                    y: pointA.y * (1 - blend) + pointB.y * blend,
                    z: pointA.z * (1 - blend) + pointB.z * blend
                };
            }
            
            function getCurrentForm(u, v, t) {
                const totalForms = forms.length;
                const cycleTime = 600;
                const position = (t % (cycleTime * totalForms)) / cycleTime;
                const formIndex = Math.floor(position);
                const nextFormIndex = (formIndex + 1) % totalForms;
                
                let rawBlend = position - formIndex;
                const pauseTime = 0;
                const transitionTime = 1 - (pauseTime * 2);
                
                let blend;
                if (rawBlend < pauseTime) {
                    blend = 0;
                } else if (rawBlend > (1 - pauseTime)) {
                    blend = 1;
                } else {
                    const normalizedTime = (rawBlend - pauseTime) / transitionTime;
                    blend = normalizedTime < 0.5
                        ? 4 * normalizedTime * normalizedTime * normalizedTime
                        : 1 - Math.pow(-2 * normalizedTime + 2, 3) / 2;
                }
                
                return interpolateForms(
                    forms[formIndex], 
                    forms[nextFormIndex], 
                    u, v, t, blend
                );
            }
            
            function animate() {
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = currentTheme === 'dark' ? '#1a1a1a' : '#F0EEE6';
                ctx.fillRect(0, 0, width, height);
                
                const rotateX = Math.sin(time * 0.00025) * 0.5;
                const rotateY = Math.cos(time * 0.00025 * 0.7) * 0.3;
                const rotateZ = time * 0.00025 * 0.1;
                
                // Draw horizontal contour lines
                for (let i = 0; i < numLines; i++) {
                    const v = i / (numLines - 1);
                    
                    ctx.beginPath();
                    const strokeColor = currentTheme === 'dark' ? 'rgba(255, 255, 255, 0.5)' : 'rgba(51, 51, 51, 0.5)';
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = lineWidth;
                    
                    let lastPointVisible = false;
                    
                    for (let j = 0; j <= lineSegments; j++) {
                        const u = j / lineSegments;
                        
                        const point = getCurrentForm(u, v, time);
                        
                        const rotatedX = point.x * Math.cos(rotateZ) - point.y * Math.sin(rotateZ);
                        const rotatedY = point.x * Math.sin(rotateZ) + point.y * Math.cos(rotateZ);
                        const rotatedZ = point.z;
                        
                        const scale = 1.5 + rotatedZ * 0.001;
                        const projX = width / 2 + rotatedX * scale;
                        const projY = height / 2 + rotatedY * scale;
                        
                        const pointVisible = rotatedZ > -50;
                        
                        if (j === 0) {
                            if (pointVisible) {
                                ctx.moveTo(projX, projY);
                                lastPointVisible = true;
                            }
                        } else {
                            if (pointVisible && lastPointVisible) {
                                ctx.lineTo(projX, projY);
                            } else if (pointVisible && !lastPointVisible) {
                                ctx.moveTo(projX, projY);
                            }
                        }
                        
                        lastPointVisible = pointVisible;
                    }
                    
                    ctx.stroke();
                }
                
                // Draw vertical contour lines
                for (let i = 0; i < numLines * 0.3; i++) {
                    const u = i / (numLines * 0.3 - 1);
                    
                    ctx.beginPath();
                    const strokeColor = currentTheme === 'dark' ? 'rgba(255, 255, 255, 0.35)' : 'rgba(51, 51, 51, 0.35)';
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = lineWidth * 0.7;
                    
                    let lastPointVisible = false;
                    
                    for (let j = 0; j <= lineSegments * 0.5; j++) {
                        const v = j / (lineSegments * 0.5);
                        
                        const point = getCurrentForm(u, v, time);
                        
                        const rotatedX = point.x * Math.cos(rotateZ) - point.y * Math.sin(rotateZ);
                        const rotatedY = point.x * Math.sin(rotateZ) + point.y * Math.cos(rotateZ);
                        const rotatedZ = point.z;
                        
                        const scale = 1.5 + rotatedZ * 0.001;
                        const projX = width / 2 + rotatedX * scale;
                        const projY = height / 2 + rotatedY * scale;
                        
                        const pointVisible = rotatedZ > -50;
                        
                        if (j === 0) {
                            if (pointVisible) {
                                ctx.moveTo(projX, projY);
                                lastPointVisible = true;
                            }
                        } else {
                            if (pointVisible && lastPointVisible) {
                                ctx.lineTo(projX, projY);
                            } else if (pointVisible && !lastPointVisible) {
                                ctx.moveTo(projX, projY);
                            }
                        }
                        
                        lastPointVisible = pointVisible;
                    }
                    
                    ctx.stroke();
                }
                
                time += 0.5;
                updatePerformanceInfo();
                animationFrameId = requestAnimationFrame(animate);
            }
            
            animate();
            
            threeScenes['artifact-4'] = {
                cleanup: () => {
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    ctx.clearRect(0, 0, width, height);
                    canvas.dataset.initialized = '';
                }
            };
        }

        // Artifact 5: Enhanced LayeredSineWaves
        function initLayeredSineWaves() {
            const canvas = document.querySelector('#artifact-5 canvas');
            if (canvas.dataset.initialized) return;
            canvas.dataset.initialized = 'true';
            
            const ctx = canvas.getContext('2d', { willReadFrequently: false });
            const width = canvas.width;
            const height = canvas.height;
            
            let animationId;
            let time = 0;
            
            const layers = CONFIG.artifacts.sineWaves.layers;
            const points = CONFIG.artifacts.sineWaves.points;
            const waveAmplitude = 40;
            
            function draw() {
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = currentTheme === 'dark' ? '#1a1a1a' : '#F0EEE6';
                ctx.fillRect(0, 0, width, height);
                
                time += 0.01;
                
                // Draw each layer
                for (let layer = 0; layer < layers; layer++) {
                    const layerPosition = (layer / layers) * height * 0.8 + height * 0.1;
                    const layerFrequency = 0.5 + layer * 0.03;
                    const layerPhase = time * 0.2 + layer * 0.05;
                    const layerAmplitude = waveAmplitude * (0.5 + 0.5 * Math.sin(layer * 0.1 + time * 0.3));
                    
                    const baseOpacity = 0.2 + 0.6 * Math.pow(Math.sin((layer / layers) * Math.PI), 2);
                    const timeEffect = 0.2 * Math.sin(time * 0.4 + layer * 0.1);
                    const opacity = Math.min(0.9, Math.max(0.1, baseOpacity + timeEffect));
                    
                    ctx.beginPath();
                    const strokeColor = currentTheme === 'dark' ? 
                        `rgba(255, 255, 255, ${opacity})` : 
                        `rgba(50, 50, 50, ${opacity})`;
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = 0.6;
                    
                    for (let i = 0; i <= points; i++) {
                        const x = (i / points) * width;
                        
                        let y = layerPosition;
                        
                        y += layerAmplitude * Math.sin(x * 0.01 * layerFrequency + layerPhase);
                        y += layerAmplitude * 0.3 * Math.sin(x * 0.02 * layerFrequency + layerPhase * 1.5);
                        y += layerAmplitude * 0.2 * Math.sin(x * 0.04 * layerFrequency - layerPhase * 0.7);
                        y += layerAmplitude * 0.1 * Math.sin(x * 0.08 * layerFrequency + layerPhase * 2.3);
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    
                    ctx.stroke();
                }
                
                // Draw connecting lines
                for (let i = 0; i < width; i += 20) {
                    if (Math.random() < 0.4) {
                        ctx.beginPath();
                        
                        const opacity = 0.1 + 0.2 * Math.sin(i * 0.05 + time);
                        const strokeColor = currentTheme === 'dark' ? 
                            `rgba(255, 255, 255, ${opacity})` : 
                            `rgba(50, 50, 50, ${opacity})`;
                        ctx.strokeStyle = strokeColor;
                        ctx.lineWidth = 0.3;
                        
                        const startY = height * 0.1 + Math.random() * height * 0.2;
                        const endY = height * 0.7 + Math.random() * height * 0.2;
                        
                        ctx.moveTo(i, startY);
                        ctx.lineTo(i, endY);
                        ctx.stroke();
                    }
                }
                
                updatePerformanceInfo();
                animationId = requestAnimationFrame(draw);
            }
            
            draw();
            
            threeScenes['artifact-5'] = {
                cleanup: () => {
                    if (animationId) cancelAnimationFrame(animationId);
                    ctx.clearRect(0, 0, width, height);
                    canvas.dataset.initialized = '';
                }
            };
        }

        // Artifact switching
        function changeArtifact() {
            const currentElement = document.querySelector('.artifact.active');
            currentElement.classList.remove('active');
            
            // Clean up current artifact
            if (threeScenes[`artifact-${currentArtifact + 1}`] && 
                threeScenes[`artifact-${currentArtifact + 1}`].cleanup) {
                threeScenes[`artifact-${currentArtifact + 1}`].cleanup();
            }
            
            currentArtifact = (currentArtifact + 1) % artifacts.length;
            
            const nextElement = document.getElementById(`artifact-${currentArtifact + 1}`);
            nextElement.classList.add('active');
            
            // Initialize the new artifact
            setTimeout(() => {
                artifacts[currentArtifact]();
            }, 100);
        }

        // Smooth scrolling for navigation links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const target = document.getElementById(targetId);
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // Simple working project toggle function (KEEP THIS WORKING)
        function toggleProject(element) {
            // Close all other projects
            document.querySelectorAll('.project-item').forEach(item => {
                if (item !== element) {
                    item.classList.remove('open');
                }
            });
            
            // Toggle current project
            element.classList.toggle('open');
        }

        // Initialize everything
        window.initialize = function initialize() {
            // Hide loading screen
            const loadingScreen = document.getElementById('loadingScreen');
            setTimeout(() => {
                loadingScreen.classList.add('hidden');
            }, 1000);

            // Initialize artifacts
            initializeArtifacts();
            
            
            // Initialize enhanced mobile accessibility
            if (typeof MobileAccessibilityManager !== 'undefined') {
                window.accessibilityManager = new MobileAccessibilityManager();
                console.log('‚úÖ Mobile accessibility manager initialized');
            }

            // Add click effects to buttons
            document.querySelectorAll('.cta-button').forEach(button => {
                button.addEventListener('click', function() {
                    this.style.transform = 'scale(0.95)';
                    setTimeout(() => {
                        this.style.transform = 'translateY(-2px)';
                    }, 100);
                });
            });
        }

        // Enhanced resize handler with debouncing
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // Update configuration for new screen size
                CONFIG.artifacts.particles.count = window.innerWidth < 768 ? 15000 : 45000;
                CONFIG.artifacts.hankies.resolution = window.innerWidth < 768 ? 16 : 32;
                CONFIG.artifacts.ascii.width = window.innerWidth < 768 ? 45 : 65;
                CONFIG.artifacts.ascii.height = window.innerWidth < 768 ? 45 : 65;
                CONFIG.artifacts.metamorphosis.numLines = window.innerWidth < 768 ? 60 : 120;
                CONFIG.artifacts.metamorphosis.lineSegments = window.innerWidth < 768 ? 90 : 180;
                CONFIG.artifacts.sineWaves.layers = window.innerWidth < 768 ? 40 : 80;
                CONFIG.artifacts.sineWaves.points = window.innerWidth < 768 ? 100 : 200;
                
                // Reinitialize current Three.js artifact on resize
                if (currentArtifact === 0 || currentArtifact === 2) {
                    if (threeScenes[`artifact-${currentArtifact + 1}`] && 
                        threeScenes[`artifact-${currentArtifact + 1}`].cleanup) {
                        threeScenes[`artifact-${currentArtifact + 1}`].cleanup();
                    }
                    setTimeout(() => {
                        artifacts[currentArtifact]();
                    }, 100);
                }
            }, 250);
        });

        // Enhanced Touch Gesture System for Mobile
        class TouchGestureManager {
            constructor() {
                this.startX = 0;
                this.startY = 0;
                this.startTime = 0;
                this.threshold = 50; // minimum swipe distance
                this.timeThreshold = 300; // maximum swipe time
                this.setupGestures();
                this.showMobileHints();
            }
            
            setupGestures() {
                const heroContainer = document.querySelector('.hero-container');
                let isDragging = false;
                
                heroContainer.addEventListener('touchstart', (e) => {
                    // Handle title/magic button taps
                    if (e.target.classList.contains('glitch-title') || e.target.classList.contains('spark-magic')) {
                        e.preventDefault();
                        changeEverything();
                        return;
                    }
                    
                    // Start gesture tracking
                    this.startX = e.touches[0].clientX;
                    this.startY = e.touches[0].clientY;
                    this.startTime = Date.now();
                    isDragging = false;
                }, { passive: false });
                
                heroContainer.addEventListener('touchmove', (e) => {
                    if (!this.startX || !this.startY) return;
                    
                    const currentX = e.touches[0].clientX;
                    const deltaX = Math.abs(currentX - this.startX);
                    
                    // Detect if user is actively swiping
                    if (deltaX > 10) {
                        isDragging = true;
                        // Add visual feedback during swipe
                        this.addSwipeVisualFeedback(currentX - this.startX);
                    }
                }, { passive: true });
                
                heroContainer.addEventListener('touchend', (e) => {
                    if (!this.startX || !this.startY) return;
                    
                    const endX = e.changedTouches[0].clientX;
                    const endY = e.changedTouches[0].clientY;
                    const endTime = Date.now();
                    
                    const deltaX = endX - this.startX;
                    const deltaY = endY - this.startY;
                    const deltaTime = endTime - this.startTime;
                    
                    // Remove any visual feedback
                    this.removeSwipeVisualFeedback();
                    
                    // Check if it's a valid swipe
                    if (Math.abs(deltaX) > Math.abs(deltaY) && 
                        Math.abs(deltaX) > this.threshold && 
                        deltaTime < this.timeThreshold &&
                        isDragging) {
                        
                        e.preventDefault();
                        
                        if (deltaX > 0) {
                            // Swipe right - previous artifact
                            this.previousArtifact();
                        } else {
                            // Swipe left - next artifact
                            this.nextArtifact();
                        }
                    }
                    
                    // Reset
                    this.startX = 0;
                    this.startY = 0;
                    this.startTime = 0;
                    isDragging = false;
                }, { passive: false });
            }
            
            nextArtifact() {
                if (!isTransitioning) {
                    changeEverything();
                    this.showSwipeSuccess('right');
                }
            }
            
            previousArtifact() {
                if (!isTransitioning) {
                    isTransitioning = true;
                    
                    // Cycle backwards through titles
                    currentTitleIndex = currentTitleIndex === 0 ? CONFIG.titles.length - 1 : currentTitleIndex - 1;
                    this.updateTitleText();
                    
                    // Cycle backwards through artifacts
                    setTimeout(() => {
                        const currentElement = document.querySelector('.artifact.active');
                        currentElement.classList.remove('active');
                        
                        if (threeScenes[`artifact-${currentArtifact + 1}`]?.cleanup) {
                            threeScenes[`artifact-${currentArtifact + 1}`].cleanup();
                        }
                        
                        currentArtifact = currentArtifact === 0 ? artifacts.length - 1 : currentArtifact - 1;
                        
                        const nextElement = document.getElementById(`artifact-${currentArtifact + 1}`);
                        nextElement.classList.add('active');
                        
                        setTimeout(() => {
                            artifacts[currentArtifact]();
                            isTransitioning = false;
                        }, 100);
                    }, CONFIG.transitions.delay);
                    
                    this.showSwipeSuccess('left');
                }
            }
            
            updateTitleText() {
                const titleElement = document.querySelector('.glitch-title');
                gsap.to(titleElement, {
                    duration: 1.2,
                    text: { value: CONFIG.titles[currentTitleIndex], delimiter: "" },
                    ease: "none"
                });
            }
            
            addSwipeVisualFeedback(deltaX) {
                const heroContainer = document.querySelector('.hero-container');
                const opacity = Math.min(Math.abs(deltaX) / 100, 0.3);
                
                if (deltaX > 0) {
                    heroContainer.style.background = `linear-gradient(90deg, rgba(102, 102, 102, ${opacity}) 0%, transparent 100%)`;
                } else {
                    heroContainer.style.background = `linear-gradient(-90deg, rgba(102, 102, 102, ${opacity}) 0%, transparent 100%)`;
                }
            }
            
            removeSwipeVisualFeedback() {
                const heroContainer = document.querySelector('.hero-container');
                heroContainer.style.background = '';
            }
            
            showSwipeSuccess(direction) {
                const indicator = document.createElement('div');
                indicator.style.cssText = `
                    position: fixed;
                    top: 50%;
                    ${direction === 'right' ? 'right: 20px;' : 'left: 20px;'}
                    transform: translateY(-50%);
                    background: rgba(102, 102, 102, 0.9);
                    color: white;
                    padding: 10px 15px;
                    border-radius: 25px;
                    font-size: 0.8rem;
                    z-index: 1002;
                    font-family: 'Roboto Mono', monospace;
                    animation: swipeSuccess 0.6s ease-out;
                `;
                indicator.textContent = direction === 'right' ? '‚Üê Previous' : 'Next ‚Üí';
                document.body.appendChild(indicator);
                
                setTimeout(() => indicator.remove(), 600);
            }
            
            showMobileHints() {
                if (window.innerWidth <= 768) {
                    const hintsHTML = `
                        <div class="mobile-hints" style="
                            position: absolute;
                            bottom: 100px;
                            left: 50%;
                            transform: translateX(-50%);
                            color: rgba(51, 51, 51, 0.6);
                            font-size: 0.8rem;
                            text-align: center;
                            z-index: 10;
                            pointer-events: none;
                            animation: fadeInOut 4s ease-in-out infinite;
                        ">
                            ‚Üê Swipe to explore ‚Üí<br>
                            <span style="font-size: 0.7rem;">Tap title to cycle</span>
                        </div>
                    `;
                    document.querySelector('.hero-content').insertAdjacentHTML('beforeend', hintsHTML);
                }
            }
        }
        
        // CSS animations for swipe feedback
        const swipeStyles = document.createElement('style');
        swipeStyles.textContent = `
            @keyframes swipeSuccess {
                0% { opacity: 0; transform: translateY(-50%) scale(0.8); }
                50% { opacity: 1; transform: translateY(-50%) scale(1.1); }
                100% { opacity: 0; transform: translateY(-50%) scale(1); }
            }
            
            @keyframes fadeInOut {
                0%, 100% { opacity: 0; }
                50% { opacity: 1; }
            }
            
            @media (max-width: 768px) {
                .mobile-hints {
                    display: block;
                }
            }
            
            @media (min-width: 769px) {
                .mobile-hints {
                    display: none;
                }
            }
        `;
        document.head.appendChild(swipeStyles);
        
        // Initialize gesture manager on mobile devices
        if (window.innerWidth <= 768 || 'ontouchstart' in window) {
            window.gestureManager = new TouchGestureManager();
        }


        // Accessibility: Focus management
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Tab') {
                // Allow normal tab navigation
                return;
            }
            if (e.key === ' ' || e.key === 'Enter') {
                const activeElement = document.activeElement;
                if (activeElement.classList.contains('glitch-title') || 
                    activeElement.classList.contains('spark-magic')) {
                    e.preventDefault();
                    changeEverything();
                }
            }
        });

        // Performance optimization: Pause animations when page is not visible
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Page is hidden, consider pausing heavy animations
                console.log('Page hidden - animations continue for demo purposes');
            } else {
                // Page is visible again
                console.log('Page visible - all animations active');
            }
        });

        // Error boundary for global errors
        window.addEventListener('error', (e) => {
            console.warn('Global error caught:', e.error);
            // Could implement fallback here
        });

        // Service worker registration (commented out for demo)
        /*
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js').catch(console.error);
        }
        */

        // Simplified initialization - removed old terminal experience system
        // Now using trait selector interface with backend integration
        
        // Chat functionality (keeping for future backend integration)
        let globalChatUI = null;
        let globalConversationManager = null;
        let chatInitialized = false;
        
        function ensureChatInitialized() {
            if (chatInitialized && globalChatUI && globalConversationManager) {
                return { chatUI: globalChatUI, conversationManager: globalConversationManager };
            }
            
            if (window.ConversationManager && window.ChatUI) {
                console.log('üîß Initializing global chat system...');
                globalChatUI = new ChatUI();
                globalConversationManager = new ConversationManager();
                
                globalChatUI.initialize();
                globalConversationManager.initialize(globalChatUI);
                globalConversationManager.loadStoredApiKey();
                
                chatInitialized = true;
                console.log('‚úÖ Global chat system initialized');
                
                return { chatUI: globalChatUI, conversationManager: globalConversationManager };
            }
            
            console.warn('‚ö†Ô∏è Chat classes not available yet');
            return null;
        }

        // Navigation handlers
        document.addEventListener('DOMContentLoaded', function() {
            // Meet Your El button handler (now goes to trait selector)
            const meetYourElBtn = document.getElementById('meetYourElBtn');
            if (meetYourElBtn) {
                meetYourElBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    // Scroll to trait selector section
                    const traitSection = document.getElementById('build-your-el');
                    if (traitSection) {
                        traitSection.scrollIntoView({ behavior: 'smooth' });
                    }
                });
            }
        });

        
        // Add swipe feedback animation
        const swipeStyle = document.createElement('style');
        swipeStyle.textContent = `
            @keyframes swipe-feedback {
                0% { transform: translateY(-50%) scale(0.5); opacity: 0; }
                50% { transform: translateY(-50%) scale(1.2); opacity: 1; }
                100% { transform: translateY(-50%) scale(1); opacity: 0; }
            }
            
            .mobile-hints .hint {
                margin: 2px 0;
                animation: fade-in-out 4s ease-in-out;
            }
            
            @keyframes fade-in-out {
                0%, 100% { opacity: 0; }
                20%, 80% { opacity: 0.6; }
            }
        `;
        document.head.appendChild(swipeStyle);
        
        // Chat circle functionality
        const chatCircle = document.createElement('div');
        chatCircle.className = 'chat-circle';
        chatCircle.innerHTML = `
            <svg viewBox="0 0 24 24" fill="currentColor">
                <path d="M20 2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h4l4 4 4-4h4c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-2 12H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"/>
            </svg>
        `;
        
        chatCircle.addEventListener('click', () => {
            const chat = ensureChatInitialized();
            if (chat) {
                chat.chatUI.show();
            }
        });
        
        document.body.appendChild(chatCircle);
        
        // Chat circle styles
        const chatStyle = document.createElement('style');
        chatStyle.textContent = `
            .chat-circle {
                position: fixed;
                bottom: 30px;
                right: 30px;
                width: 60px;
                height: 60px;
                background: var(--accent-color);
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                z-index: 1000;
                transition: all 0.3s ease;
                color: white;
                box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
            }
            
            .chat-circle:hover {
                transform: scale(1.1);
                box-shadow: 0 6px 24px rgba(0, 0, 0, 0.3);
            }
            
            .chat-circle svg {
                width: 24px;
                height: 24px;
            }
            
            .chat-circle::before {
                content: '';
                position: absolute;
                top: -2px;
                left: -2px;
                right: -2px;
                bottom: -2px;
                border-radius: 50%;
                background: var(--accent-color);
                opacity: 0.3;
                animation: pulse-ring 2s infinite;
            }
            
            @keyframes pulse-ring {
                0% {
                    transform: scale(0.8);
                    opacity: 0.8;
                }
                50% {
                    transform: scale(1.2);
                    opacity: 0.4;
                }
                100% {
                    transform: scale(1.5);
                    opacity: 0;
                }
            }
            
            /* Mobile optimizations */
            @media (max-width: 768px) {
                .chat-circle {
                    bottom: 20px;
                    right: 20px;
                    width: 56px;
                    height: 56px;
                }
                
                .chat-circle svg {
                    width: 20px;
                    height: 20px;
                }
            }
        `;
        document.head.appendChild(chatStyle);
    </script>    <!-- Main Application JavaScript -->
    <script src="js/main.js"></script>
    <script src="js/trait-selector.js"></script>
    
    <script>
        // Terminal interface class - Claude Code style with Elliot
        class Terminal {
            constructor() {
                this.output = document.getElementById('terminalOutput');
                this.input = null; // Will be created dynamically
                this.isProcessing = false;
                this.conversationHistory = [];
                this.questMode = false;
                this.currentQuestion = 0;
                this.userResponses = [];
                this.hasGeneratedAvatar = false;
                this.init();
                
                // Questions for quest mode
                this.questions = [
                    "What's your name, and what do you do for work?",
                    "What's something you've been working on lately that you're genuinely excited about?",
                    "If you could have dinner with anyone (dead or alive), who would it be and what would you want to talk about?",
                    "What kind of impact do you hope to make in your work or the world?"
                ];
            }

            init() {
                // Welcome message will be shown when entering terminal mode
            }
            
            showWelcomeMessage() {
                // Clear any existing content
                this.output.innerHTML = '';
                
                // Add ELLIOT ASCII art with animation delay using Unicode blocks
                const elliotLines = [
                    '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà      ‚ñà‚ñà      ‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà',
                    '‚ñà‚ñà      ‚ñà‚ñà      ‚ñà‚ñà      ‚ñà‚ñà ‚ñà‚ñà    ‚ñà‚ñà    ‚ñà‚ñà   ',
                    '‚ñà‚ñà‚ñà‚ñà‚ñà   ‚ñà‚ñà      ‚ñà‚ñà      ‚ñà‚ñà ‚ñà‚ñà    ‚ñà‚ñà    ‚ñà‚ñà   ',
                    '‚ñà‚ñà      ‚ñà‚ñà      ‚ñà‚ñà      ‚ñà‚ñà ‚ñà‚ñà    ‚ñà‚ñà    ‚ñà‚ñà   ',
                    '‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà     ‚ñà‚ñà   '
                ];
                
                elliotLines.forEach((line, index) => {
                    setTimeout(() => {
                        this.addToOutput(`<span style="color: #ffffff; font-family: 'Roboto Mono', monospace; letter-spacing: 1px; white-space: pre;">${line}</span>`);
                    }, index * 150);
                });
                
                // Add divider and instructions after ASCII art
                setTimeout(() => {
                    this.addToOutput('');
                    this.addToOutput(`<span style="color: #ffffff; font-family: 'Roboto Mono', monospace; font-weight: bold;">PERSONA GENERATOR v2.0 | Custom Neural Architecture</span>`);
                    this.addToOutput(`<span style="color: #ffffff; font-family: 'Roboto Mono', monospace;">‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê</span>`);
                    this.addToOutput('');
                    this.addToOutput(`<span style="color: #ffffff; font-family: 'Roboto Mono', monospace;">I built a specialized LLM head that extracts Big Five personality</span>`);
                    this.addToOutput(`<span style="color: #ffffff; font-family: 'Roboto Mono', monospace;">traits from any text input. Doesn't matter what you feed it.</span>`);
                    this.addToOutput('');
                    this.addToOutput(`<span style="color: #ffffff; font-family: 'Roboto Mono', monospace;">Resume? Job description? Essay you wrote? Random thoughts?</span>`);
                    this.addToOutput(`<span style="color: #ffffff; font-family: 'Roboto Mono', monospace;">The model reads between the lines and pulls your psychological</span>`);
                    this.addToOutput(`<span style="color: #ffffff; font-family: 'Roboto Mono', monospace;">profile. Then generates your personalized "El" avatar.</span>`);
                    this.addToOutput('');
                    this.addToOutput(`<span style="color: #ffffff; font-family: 'Roboto Mono', monospace;">No surveys. No questionnaires. Just raw text analysis.</span>`);
                    this.addToOutput('');
                    this.addToOutput(`<span style="color: #ffffff; font-family: 'Roboto Mono', monospace;">‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ</span>`);
                    this.addToOutput(`<span style="color: #ffffff; font-family: 'Roboto Mono', monospace;">Ready for input...</span>`);
                    this.addPrompt();
                }, elliotLines.length * 150 + 300);
            }

            async processInput() {
                const userInput = this.input.value.trim();
                if (!userInput) return;

                this.isProcessing = true;
                
                // Replace the input line with the completed command
                this.input.parentNode.innerHTML = `<span style="color: #28ca42; font-family: 'Roboto Mono', monospace;">elliot@terminal ~ % </span><span style="color: #ffffff; font-family: 'Roboto Mono', monospace;">${userInput}</span>`;
                
                this.showLoading();

                try {
                    // Check for special commands
                    if (userInput.toLowerCase() === 'quest') {
                        this.startQuestMode();
                        return;
                    }

                    // Build conversation context
                    this.conversationHistory.push({
                        role: 'user',
                        content: userInput
                    });

                    let response;
                    if (this.questMode) {
                        response = await this.handleQuestResponse(userInput);
                    } else {
                        response = await this.generateElliotResponse(userInput);
                    }

                    this.hideLoading();
                    this.addToOutput(`<span class="terminal-ai">elliot@terminal ~ % ${response}</span>`);
                    
                    this.conversationHistory.push({
                        role: 'assistant',
                        content: response
                    });

                } catch (error) {
                    this.hideLoading();
                    this.addToOutput(`<span style="color: #ff5f57;">ERROR: ${error.message}</span>`);
                } finally {
                    this.isProcessing = false;
                    this.addPrompt();
                }
            }

            startQuestMode() {
                this.questMode = true;
                this.currentQuestion = 0;
                this.userResponses = [];
                
                this.hideLoading();
                this.addToOutput(`<span class="terminal-ai">elliot@terminal ~ % Perfect! Let's dive into the guided flow.</span>`);
                this.addToOutput(`<span class="terminal-ai">elliot@terminal ~ % I'll ask you ${this.questions.length} questions to understand what kind of El you need.</span>`);
                this.addToOutput(`<span class="terminal-ai">elliot@terminal ~ % </span>`);
                this.addToOutput(`<span class="terminal-ai">elliot@terminal ~ % ${this.questions[0]}</span>`);
                this.addPrompt();
            }

            async handleQuestResponse(userInput) {
                this.userResponses.push(userInput);
                
                if (this.currentQuestion < this.questions.length - 1) {
                    // Move to next question
                    this.currentQuestion++;
                    const followUp = await this.generateFollowUp(userInput, this.currentQuestion - 1);
                    return `${followUp} \n\nNext question: ${this.questions[this.currentQuestion]}`;
                } else {
                    // Final question answered
                    this.questMode = false;
                    return await this.generateFinalQuestResponse();
                }
            }

            async generateFollowUp(response, questionIndex) {
                const followUps = [
                    "Nice to meet you! That sounds like interesting work.",
                    "That's awesome - passion projects often lead to the best insights.",
                    "Fascinating choice! Great conversations usually reveal character.",
                    "That's a meaningful vision - impact-driven people tend to be great collaborators."
                ];
                
                return followUps[questionIndex] || "Thanks for sharing that insight.";
            }

            async generateFinalQuestResponse() {
                try {
                    // Simulate API call with delay
                    await new Promise(resolve => setTimeout(resolve, 2000));
                    
                    // Generate a response based on user inputs
                    const response = this.generateLocalAnalysis();
                    
                    // Trigger avatar generation on the right card
                    if (window.personaGenerator) {
                        const persona = window.personaGenerator.selectPersona();
                        window.personaGenerator.displayPersona(persona);
                    }
                    
                    return response;
                } catch (error) {
                    console.error('Error in quest analysis:', error);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    return `Perfect! Based on your responses, I can see you're looking for an El who can balance ${this.extractKeyTraits()}. Let me generate a personalized recommendation for you.`;
                }
            }

            generateLocalAnalysis() {
                const traits = this.extractKeyTraits();
                return `Perfect! Based on your responses, I can see you're looking for an El who can balance ${traits}.

Here's my analysis:
‚Ä¢ Strong communication patterns detected
‚Ä¢ Collaborative mindset with technical depth  
‚Ä¢ Innovation-focused with practical application
‚Ä¢ Values meaningful impact over pure technical achievement

Your personality profile shows: Balanced traits across multiple dimensions with strong interpersonal skills.

[COMPLETE] Big Five extracted. Generating your El persona...`;
            }

            extractKeyTraits() {
                // Simple trait extraction from responses
                const allText = this.userResponses.join(' ').toLowerCase();
                const traits = [];
                
                if (allText.includes('technical') || allText.includes('engineer') || allText.includes('code')) {
                    traits.push('technical expertise');
                }
                if (allText.includes('team') || allText.includes('collaborate') || allText.includes('people')) {
                    traits.push('collaboration');
                }
                if (allText.includes('creative') || allText.includes('design') || allText.includes('art')) {
                    traits.push('creativity');
                }
                if (allText.includes('lead') || allText.includes('manage') || allText.includes('direct')) {
                    traits.push('leadership');
                }
                
                return traits.length > 0 ? traits.join(' and ') : 'multiple perspectives';
            }

            async generateElliotResponse(userInput) {
                try {
                    // Simulate processing time
                    await new Promise(resolve => setTimeout(resolve, 1500));
                    
                    return this.getFallbackResponse(userInput);
                } catch (error) {
                    console.error('Error generating response:', error);
                    await new Promise(resolve => setTimeout(resolve, 1500));
                    return this.getFallbackResponse(userInput);
                }
            }
            
            getFallbackResponse(userInput) {
                // Check if it's a job description
                if (userInput.length > 100 && (userInput.includes('requirements') || userInput.includes('experience') || userInput.includes('responsible'))) {
                    return this.analyzeJobDescription(userInput);
                }
                
                // General conversation responses
                const responses = [
                    "I hear you! Based on what you're describing, it sounds like you need an El who can adapt to different situations. What's the main challenge you're trying to solve?",
                    "Interesting perspective. Tell me more about the context - is this for a specific project or a longer-term role?",
                    "Got it. I'm picking up on some key themes here. What would success look like with the right El on your team?",
                    "That makes sense. From what you're sharing, I can see a few different personality directions we could explore. Any particular working style preferences?",
                    "Understanding your needs... It sounds like you're looking for someone who can balance different skills. What's most important - the technical side or the people side?"
                ];
                
                return responses[Math.floor(Math.random() * responses.length)];
            }

            analyzeJobDescription(jd) {
                return "I can see this is a detailed role description. Let me parse through the key requirements... Based on this JD, I'm seeing needs for someone who can handle both strategic thinking and hands-on execution. Want me to break down what kind of El personality would fit best?";
            }

            showLoading() {
                this.addToOutput(`<span class="terminal-loading">[ANALYZING] Running text through personality extraction pipeline...</span>`);
            }

            hideLoading() {
                const loadingElements = this.output.querySelectorAll('.terminal-loading');
                loadingElements.forEach(el => el.remove());
            }

            addToOutput(html) {
                const div = document.createElement('div');
                div.innerHTML = html;
                this.output.appendChild(div);
                this.output.scrollTop = this.output.scrollHeight;
            }

            addPrompt() {
                // Remove any existing input
                if (this.input && this.input.parentNode) {
                    this.input.parentNode.remove();
                }
                
                // Create input container within the output
                const inputContainer = document.createElement('div');
                inputContainer.style.display = 'flex';
                inputContainer.style.alignItems = 'center';
                inputContainer.style.fontFamily = "'Roboto Mono', monospace";
                inputContainer.style.fontSize = '12px';
                inputContainer.style.color = '#ffffff';
                inputContainer.style.marginTop = '8px';
                
                // Create prompt symbol
                const promptSymbol = document.createElement('span');
                promptSymbol.textContent = 'elliot@terminal ~ % ';
                promptSymbol.style.color = '#28ca42'; // Mac terminal green
                promptSymbol.style.marginRight = '0';
                
                // Create input field
                this.input = document.createElement('input');
                this.input.type = 'text';
                this.input.style.background = 'none';
                this.input.style.border = 'none';
                this.input.style.color = '#ffffff';
                this.input.style.fontFamily = "'Roboto Mono', monospace";
                this.input.style.fontSize = '12px';
                this.input.style.outline = 'none';
                this.input.style.flex = '1';
                this.input.style.caretColor = '#ffffff';
                
                // Add event listener
                this.input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !this.isProcessing) {
                        this.processInput();
                    }
                });
                
                inputContainer.appendChild(promptSymbol);
                inputContainer.appendChild(this.input);
                this.output.appendChild(inputContainer);
                
                // Focus and scroll to bottom
                this.input.focus();
                this.output.scrollTop = this.output.scrollHeight;
            }
        }

        class RetroPersonaGenerator {
            constructor() {
                this.selectedTraits = new Set(['energy', 'creative', 'leadership', 'technical']);
                this.isGenerating = false;
                this.terminal = null;
                this.isTerminalMode = false;
                this.personas = {
                    conspiracyel: {
                        name: "CONSPIRACYEL",
                        title: "Paranoid Problem Investigator",
                        description: "Nothing is a coincidence. Every bug is connected. The code is trying to tell us something...",
                        traits: "Paranoid, pattern-seeking, suspicious, deep-thinking.<br>An expert in pattern recognition, system thinking, uncovering hidden issues."
                    },
                    energyel: {
                        name: "ENERGYEL",
                        title: "High-Velocity Product Catalyst",
                        description: "Coffee-powered development machine. Ships features before you finish explaining the requirements...",
                        traits: "High-energy, collaborative, fast-paced, dynamic.<br>Thrives in startup environments requiring rapid iteration and team coordination."
                    },
                    analyticalel: {
                        name: "ANALYTICALEL",
                        title: "Data-Driven Strategic Architect",
                        description: "Turns spreadsheets into strategies. Every decision backed by three different data sources...",
                        traits: "Analytical, methodical, precise, evidence-based.<br>Excels at translating complex data into actionable business insights."
                    },
                    creativeel: {
                        name: "CREATIVEEL",
                        title: "Innovative Design Catalyst",
                        description: "Sees possibilities where others see problems. Builds beautiful solutions that users love...",
                        traits: "Creative, artistic, innovative, user-focused.<br>Combines aesthetic sensibility with practical problem-solving skills."
                    }
                };
                this.init();
            }

            init() {
                // Add event listeners for toggle switches
                document.querySelectorAll('.toggle-switch').forEach(toggle => {
                    toggle.addEventListener('click', (e) => this.toggleTrait(e));
                });

                // Add event listeners for trait option buttons
                document.querySelectorAll('.trait-option').forEach(option => {
                    option.addEventListener('click', (e) => this.toggleTraitOption(e));
                });

                // Add event listeners for sound bars
                document.querySelectorAll('.soundbar').forEach(bar => {
                    bar.addEventListener('click', (e) => this.toggleSoundbar(e));
                });

                // Add event listeners for command buttons
                const generateBtn = document.getElementById('generateBtn');
                const randomBtn = document.getElementById('randomBtn');
                const resetBtn = document.getElementById('resetBtn');
                const saveBtn = document.getElementById('saveBtn');
                
                if (generateBtn) generateBtn.addEventListener('click', () => this.generatePersona());
                if (randomBtn) randomBtn.addEventListener('click', () => this.randomizeTraits());
                if (resetBtn) resetBtn.addEventListener('click', () => this.resetTraits());
                if (saveBtn) saveBtn.addEventListener('click', () => this.savePersona());

                // Add Advanced toggle functionality
                const advancedToggle = document.getElementById('advancedToggle');
                if (advancedToggle) advancedToggle.addEventListener('click', () => this.toggleAdvanced());

                // Add Terminal Mode functionality
                const terminalModeBtn = document.getElementById('terminalModeBtn');
                const terminalCloseBtn = document.getElementById('terminalCloseBtn');
                if (terminalModeBtn) terminalModeBtn.addEventListener('click', () => this.enterTerminalMode());
                if (terminalCloseBtn) terminalCloseBtn.addEventListener('click', () => this.exitTerminalMode());

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    if (e.key === 'g' || e.key === 'G') {
                        e.preventDefault();
                        this.generatePersona();
                    } else if (e.key === 'r' || e.key === 'R') {
                        e.preventDefault();
                        this.randomizeTraits();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        if (this.isTerminalMode) {
                            this.exitTerminalMode();
                        } else {
                            this.resetTraits();
                        }
                    }
                });

                this.updateDisplay();
            }

            enterTerminalMode() {
                const cardFlipContainer = document.getElementById('cardFlipContainer');
                if (cardFlipContainer) {
                    cardFlipContainer.classList.add('flipped');
                    this.isTerminalMode = true;

                    // Initialize terminal after flip animation
                    setTimeout(() => {
                        if (!this.terminal) {
                            this.terminal = new Terminal();
                        }
                        this.terminal.showWelcomeMessage();
                    }, 400); // Half way through the flip animation
                }
            }

            exitTerminalMode() {
                const cardFlipContainer = document.getElementById('cardFlipContainer');
                if (cardFlipContainer) {
                    cardFlipContainer.classList.remove('flipped');
                    this.isTerminalMode = false;
                }
            }

            toggleAdvanced() {
                console.log('Advanced toggle clicked!'); // Debug log
                const content = document.getElementById('advancedContent');
                const toggle = document.getElementById('advancedToggle');
                
                if (content && toggle) {
                    content.classList.toggle('show');
                    const isOpen = content.classList.contains('show');
                    toggle.innerHTML = isOpen ? '<span>‚ñº Advanced</span>' : '<span>‚ñ∂ Advanced</span>';
                    console.log('Advanced content toggled:', isOpen); // Debug log
                } else {
                    console.log('Advanced elements not found:', { content, toggle }); // Debug log
                }
            }

            toggleTrait(e) {
                console.log('Toggle switch clicked:', e.currentTarget.dataset.trait); // Debug log
                const toggle = e.currentTarget;
                const trait = toggle.dataset.trait;

                if (toggle.classList.contains('active')) {
                    toggle.classList.remove('active');
                    this.selectedTraits.delete(trait);
                } else {
                    toggle.classList.add('active');
                    this.selectedTraits.add(trait);
                }

                // Update corresponding sound bar
                const soundbar = document.querySelector(`.soundbar[data-trait="${trait}"]`);
                if (soundbar) {
                    soundbar.classList.toggle('active', this.selectedTraits.has(trait));
                }

                this.updateDisplay();
                this.triggerSoundbarPulse();
            }

            toggleTraitOption(e) {
                console.log('Trait option clicked:', e.currentTarget.dataset.trait); // Debug log
                const option = e.currentTarget;
                const trait = option.dataset.trait;

                if (option.classList.contains('selected')) {
                    option.classList.remove('selected');
                    this.selectedTraits.delete(trait);
                } else {
                    option.classList.add('selected');
                    this.selectedTraits.add(trait);
                }

                // Update corresponding sound bar
                const soundbar = document.querySelector(`.soundbar[data-trait="${trait}"]`);
                if (soundbar) {
                    soundbar.classList.toggle('active', this.selectedTraits.has(trait));
                }

                this.updateDisplay();
                this.triggerSoundbarPulse();
            }

            toggleSoundbar(e) {
                const bar = e.currentTarget;
                const trait = bar.dataset.trait;
                
                if (this.selectedTraits.has(trait)) {
                    this.selectedTraits.delete(trait);
                } else {
                    this.selectedTraits.add(trait);
                }
                
                // Update corresponding toggle switch if it exists
                const toggle = document.querySelector(`[data-trait="${trait}"].toggle-switch`);
                if (toggle) {
                    toggle.classList.toggle('active', this.selectedTraits.has(trait));
                }

                // Update corresponding trait option if it exists
                const option = document.querySelector(`[data-trait="${trait}"].trait-option`);
                if (option) {
                    option.classList.toggle('selected', this.selectedTraits.has(trait));
                }
                
                this.updateDisplay();
                this.triggerSoundbarPulse();
            }

            updateDisplay() {
                const count = this.selectedTraits.size;
                const traitCounter = document.getElementById('traitCounter');
                if (traitCounter) traitCounter.textContent = `${count}/18`;
                
                // Update the display counter on the right card as well
                const displayCounter = document.getElementById('displayTraitCounter');
                if (displayCounter) {
                    displayCounter.textContent = `${count}/18`;
                }

                // Update sound bars
                document.querySelectorAll('.soundbar').forEach(bar => {
                    const trait = bar.dataset.trait;
                    bar.classList.toggle('active', this.selectedTraits.has(trait));
                });

                // Update toggle switches
                document.querySelectorAll('.toggle-switch').forEach(toggle => {
                    const trait = toggle.dataset.trait;
                    toggle.classList.toggle('active', this.selectedTraits.has(trait));
                });

                // Update trait options
                document.querySelectorAll('.trait-option').forEach(option => {
                    const trait = option.dataset.trait;
                    option.classList.toggle('selected', this.selectedTraits.has(trait));
                });
            }

            triggerSoundbarPulse() {
                const soundbars = document.querySelectorAll('.soundbar.active');
                soundbars.forEach((bar, index) => {
                    setTimeout(() => {
                        bar.style.background = '#D4AF37'; // Gold
                        bar.style.transform = 'scaleY(1.2)';
                        setTimeout(() => {
                            bar.style.background = '#CC7A00'; // Amber
                            bar.style.transform = 'scaleY(1)';
                        }, 200);
                    }, index * 50);
                });
            }

            async generatePersona() {
                if (this.isGenerating) return;

                this.isGenerating = true;
                this.showGeneratingState();

                try {
                    // Simulate generation time
                    await new Promise(resolve => setTimeout(resolve, 2500));
                    
                    // Select persona based on traits
                    const persona = this.selectPersona();
                    this.displayPersona(persona);
                } finally {
                    this.isGenerating = false;
                    this.hideGeneratingState();
                }
            }

            selectPersona() {
                const traits = Array.from(this.selectedTraits);
                
                if (traits.includes('paranoia') || traits.includes('mystery')) {
                    return this.personas.conspiracyel;
                } else if (traits.includes('energy') || traits.includes('speed')) {
                    return this.personas.energyel;
                } else if (traits.includes('analytical') || traits.includes('discipline')) {
                    return this.personas.analyticalel;
                } else if (traits.includes('creative') || traits.includes('innovation')) {
                    return this.personas.creativeel;
                } else {
                    return this.personas.conspiracyel; // Default
                }
            }

            displayPersona(persona) {
                const personaName = document.getElementById('personaName');
                const personaTitle = document.getElementById('personaTitle');
                const personaDescription = document.getElementById('personaDescription');
                const personaTraits = document.getElementById('personaTraits');
                
                if (personaName) personaName.textContent = persona.name;
                if (personaTitle) personaTitle.textContent = persona.title;
                if (personaDescription) personaDescription.textContent = persona.description;
                if (personaTraits) personaTraits.innerHTML = persona.traits;

                // Add success animation to museum card
                const card = document.getElementById('museumCard');
                if (card) {
                    card.style.transform = 'scale(1.02)';
                    setTimeout(() => {
                        card.style.transform = 'scale(1)';
                    }, 300);
                }
            }

            showGeneratingState() {
                // Show generation status
                const generationStatus = document.getElementById('generationStatus');
                if (generationStatus) generationStatus.classList.add('show');
                
                // Activate all sound bars for generation
                document.querySelectorAll('.soundbar').forEach(bar => {
                    bar.classList.add('generating');
                });
                
                // Update generate button
                const btn = document.getElementById('generateBtn');
                if (btn) {
                    btn.classList.add('generating');
                    btn.innerHTML = 'GENERATING...<div class="button-subtitle">G</div>';
                }
            }

            hideGeneratingState() {
                // Hide generation status
                const generationStatus = document.getElementById('generationStatus');
                if (generationStatus) generationStatus.classList.remove('show');
                
                // Remove generating state from sound bars
                document.querySelectorAll('.soundbar').forEach(bar => {
                    bar.classList.remove('generating');
                });
                
                // Reset generate button
                const btn = document.getElementById('generateBtn');
                if (btn) {
                    btn.classList.remove('generating');
                    btn.innerHTML = 'Generate<div class="button-subtitle">G</div>';
                }
            }

            randomizeTraits() {
                console.log('Random button clicked!'); // Debug log
                // Clear current selection
                document.querySelectorAll('.trait-option').forEach(option => {
                    option.classList.remove('selected');
                });
                this.selectedTraits.clear();

                // Get all available traits
                const allTraits = Array.from(document.querySelectorAll('.trait-option')).map(option => option.dataset.trait);
                
                // Randomly select 3-5 traits
                const count = 3 + Math.floor(Math.random() * 3);
                const selectedTraits = [];
                
                while (selectedTraits.length < count && selectedTraits.length < allTraits.length) {
                    const randomTrait = allTraits[Math.floor(Math.random() * allTraits.length)];
                    if (!selectedTraits.includes(randomTrait)) {
                        selectedTraits.push(randomTrait);
                        this.selectedTraits.add(randomTrait);
                    }
                }

                // Update UI
                selectedTraits.forEach(trait => {
                    const option = document.querySelector(`[data-trait="${trait}"]`);
                    if (option && option.classList.contains('trait-option')) {
                        option.classList.add('selected');
                    }
                });

                this.updateDisplay();
                this.triggerSoundbarPulse();
            }

            resetTraits() {
                document.querySelectorAll('.trait-option').forEach(option => {
                    option.classList.remove('selected');
                });
                
                this.selectedTraits.clear();
                this.selectedTraits.add('energy');
                this.selectedTraits.add('creative');
                this.selectedTraits.add('leadership');
                this.selectedTraits.add('technical');
                
                // Reset to default selections
                const energyOption = document.querySelector('[data-trait="energy"]');
                const creativeOption = document.querySelector('[data-trait="creative"]');
                const leadershipOption = document.querySelector('[data-trait="leadership"]');
                const technicalOption = document.querySelector('[data-trait="technical"]');
                
                if (energyOption) energyOption.classList.add('selected');
                if (creativeOption) creativeOption.classList.add('selected');
                if (leadershipOption) leadershipOption.classList.add('selected');
                if (technicalOption) technicalOption.classList.add('selected');
                
                this.updateDisplay();
                this.triggerSoundbarPulse();
            }

            savePersona() {
                const personaName = document.getElementById('personaName');
                const personaTitle = document.getElementById('personaTitle');
                
                const currentPersona = {
                    name: personaName ? personaName.textContent : 'Unknown',
                    title: personaTitle ? personaTitle.textContent : 'Unknown',
                    traits: Array.from(this.selectedTraits),
                    timestamp: new Date().toISOString()
                };

                console.log('Saved Persona:', currentPersona);
                
                // Visual feedback
                const btn = document.getElementById('saveBtn');
                if (btn) {
                    const original = btn.innerHTML;
                    btn.innerHTML = 'EXPORTED!<div class="button-subtitle">S</div>';
                    setTimeout(() => {
                        btn.innerHTML = original;
                    }, 1500);
                }

                // Copy to clipboard if available
                try {
                    navigator.clipboard.writeText(JSON.stringify(currentPersona, null, 2));
                } catch (err) {
                    console.log('Clipboard access not available');
                }
            }
        }

        // Initialize when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            window.personaGenerator = new RetroPersonaGenerator();
        });
    </script>
    
    <script>
        // Initialize the application after DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            window.initialize();
        });
    </script>
</body>
</html>