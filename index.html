<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elliot Lee - Portfolio</title>
    <meta name="description" content="Interactive portfolio showcasing generative art and creative coding">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/Flip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/TextPlugin.min.js"></script>
    <link rel="stylesheet" href="css/conversation.css?v=4">
    <script src="js/conversation/claude-client.js?v=4"></script>
    <script src="js/conversation/avatar-generator.js?v=3"></script>
    <script src="js/conversation/chat-ui.js?v=5"></script>
    <script src="js/conversation/conversation-manager.js?v=4"></script>
    <link rel="stylesheet" href="css/main.css">
    <link rel="stylesheet" href="css/trait-selector.css">

</head>
<body>
    <div class="loading-screen" id="loadingScreen">
        <div class="loader">Loading Experience...</div>
    </div>

    <nav class="nav-bar">
        <div class="nav-logo">
            EL
        </div>
        
        <div class="nav-center">
            <a href="#home" class="nav-item">HOME</a>
            <a href="#projects" class="nav-item">PROJECTS</a>
            <a href="#contact" class="nav-item">CONTACT</a>
        </div>
    </nav>

    <div class="hero-container" id="home">
        <!-- Artifact containers -->
        <div class="artifact-container">
            <!-- Artifact 1: HankiesInTheWind (Three.js interference patterns) -->
            <div class="artifact active" id="artifact-1"></div>
            
            <!-- Artifact 2: AsciiBinaryFlow -->
            <div class="artifact" id="artifact-2">
                <div class="ascii-container"></div>
            </div>
            
            <!-- Artifact 3: ParticleVessel (Three.js particles) -->
            <div class="artifact" id="artifact-3"></div>
            
            <!-- Artifact 4: Metamorphosis (Canvas 3D forms) -->
            <div class="artifact" id="artifact-4">
                <div class="canvas-container">
                    <canvas width="550" height="550"></canvas>
                </div>
            </div>
            
            <!-- Artifact 5: LayeredSineWaves (Canvas sine waves) -->
            <div class="artifact" id="artifact-5">
                <div class="canvas-container">
                    <canvas width="550" height="550"></canvas>
                </div>
            </div>
        </div>
        
        <div class="hero-content">
            <h1 class="glitch-title" 
                onclick="changeEverything()" 
                onkeydown="handleKeyPress(event)"
                role="button" 
                tabindex="0"
                aria-label="Click to cycle through titles and change background art">
                ELLIOT LEE
            </h1>
            
            <div class="spark-magic" 
                 onclick="changeEverything()"
                 onkeydown="handleKeyPress(event)"
                 role="button"
                 tabindex="0"
                 aria-label="Change experience">
                <span>[click me]</span>
            </div>
        </div>
    </div>

    <!-- Build Your El Section -->
    <section class="build-your-el-section" id="build-your-el">
        <div class="build-el-container">
            <!-- Section Header -->
            <div class="build-el-header">
                <h2 class="build-el-title">Create</h2>
                <p class="build-el-subtitle">Thinking about El? Find the version that works best for you!</p>
            </div>
            
            <!-- New Trait Selector Interface -->
            <div class="trait-selector-container">
                <div class="trait-selector-grid">
                    <!-- Left Panel - Trait Selection with flip capability -->
                    <div class="trait-panel" id="traitPanel">
                        <div class="trait-panel-inner">
                            <!-- Front side - Original trait selection -->
                            <div class="trait-panel-front">
                                <!-- Trait Categories Section -->
                                <div class="trait-categories">
                                    <div class="category-header">
                                        <span class="category-title">Select Traits</span>
                                    </div>

                                    <div class="trait-row">
                                        <span class="trait-label">
                                            <span class="trait-icon">‚ö°</span>
                                            High Energy
                                        </span>
                                        <div class="trait-toggle active" data-trait="energy"></div>
                                    </div>


                                    <div class="trait-row">
                                        <span class="trait-label">
                                            <span class="trait-icon">üéØ</span>
                                            Intense Focus
                                        </span>
                                        <div class="trait-toggle" data-trait="intensity"></div>
                                    </div>

                                    <div class="trait-row">
                                        <span class="trait-label">
                                            <span class="trait-icon">üöÄ</span>
                                            Innovation
                                        </span>
                                        <div class="trait-toggle" data-trait="innovation"></div>
                                    </div>

                                    <div class="trait-row">
                                        <span class="trait-label">
                                            <span class="trait-icon">ü§ù</span>
                                            Cooperative
                                        </span>
                                        <div class="trait-toggle" data-trait="cooperative"></div>
                                    </div>

                                    <div class="trait-row">
                                        <span class="trait-label">
                                            <span class="trait-icon">üßò</span>
                                            Calm Under Pressure
                                        </span>
                                        <div class="trait-toggle" data-trait="calm"></div>
                                    </div>

                                    <div class="selection-display">
                                        <div class="selection-label">Active Traits <span class="selection-text">analysing...</span></div>
                                        <div class="selection-count">2/19</div>
                                    </div>

                                    <div class="generation-display">
                                        <div class="soundbar-container" id="soundbarContainer">
                                            <div class="soundbar" data-trait="energy" title="High Energy"></div>
                                            <div class="soundbar" data-trait="intensity" title="Intense Focus"></div>
                                            <div class="soundbar" data-trait="innovation" title="Innovation"></div>
                                            <div class="soundbar" data-trait="cooperative" title="Cooperative"></div>
                                            <div class="soundbar" data-trait="calm" title="Calm Under Pressure"></div>
                                            <div class="soundbar" data-trait="technical" title="Technical"></div>
                                            <div class="soundbar" data-trait="creativity" title="Creative"></div>
                                            <div class="soundbar" data-trait="leadership" title="Leadership"></div>
                                            <div class="soundbar" data-trait="collaborative" title="Collaborative"></div>
                                            <div class="soundbar" data-trait="adventure" title="Adventure"></div>
                                            <div class="soundbar" data-trait="mystery" title="Mystery"></div>
                                            <div class="soundbar" data-trait="discipline" title="Discipline"></div>
                                            <div class="soundbar" data-trait="curiosity" title="Curiosity"></div>
                                            <div class="soundbar" data-trait="hustle" title="Hustle"></div>
                                            <div class="soundbar" data-trait="speed" title="Speed"></div>
                                            <div class="soundbar" data-trait="experimental" title="Experimental"></div>
                                            <div class="soundbar" data-trait="paranoia" title="Paranoia"></div>
                                            <div class="soundbar" data-trait="procrastination" title="Procrastination"></div>
                                            <div class="soundbar" data-trait="futuristic" title="Futuristic"></div>
                                        </div>
                                        <div class="soundbar-info">
                                            <span class="trait-count" id="traitCount">2 traits</span>
                                            <span class="possibilities-label">‚àû combinations</span>
                                        </div>
                                    </div>

                                    <div class="trait-options">
                                        <div class="trait-option" data-dimension="technical" data-tooltip="Loves coding & engineering">üîß</div>
                                        <div class="trait-option" data-dimension="creativity" data-tooltip="Creative & artistic">üé®</div>
                                        <div class="trait-option selected" data-dimension="energy" data-tooltip="High energy & dynamic">‚ö°</div>
                                        <div class="trait-option" data-dimension="leadership" data-tooltip="Natural leader">üëë</div>
                                        <div class="trait-option selected" data-dimension="collaborative" data-tooltip="Team player">ü§ù</div>
                                        
                                        <div class="trait-option" data-dimension="cooperative" data-tooltip="Seeks consensus & agreement">ü§ù</div>
                                        <div class="trait-option" data-dimension="adventure" data-tooltip="Seeks bold challenges">üè¥‚Äç‚ò†Ô∏è</div>
                                        <div class="trait-option" data-dimension="mystery" data-tooltip="Investigates complex problems">üïµÔ∏è</div>
                                        <div class="trait-option" data-dimension="discipline" data-tooltip="Systematic & consistent">üí™</div>
                                        <div class="trait-option" data-dimension="calm" data-tooltip="Stays composed under stress">üßò</div>
                                        <div class="trait-option" data-dimension="innovation" data-tooltip="Revolutionary thinker">üöÄ</div>
                                        <div class="trait-option" data-dimension="curiosity" data-tooltip="Always learning">ü§î</div>
                                        <div class="trait-option" data-dimension="hustle" data-tooltip="Relentlessly driven">üî•</div>
                                        
                                        <div class="trait-option" data-dimension="speed" data-tooltip="Fast-paced execution">üí®</div>
                                        <div class="trait-option" data-dimension="intensity" data-tooltip="Maximum focus">‚ö°</div>
                                        <div class="trait-option" data-dimension="experimental" data-tooltip="Tests weird ideas">üß™</div>
                                        <div class="trait-option" data-dimension="paranoia" data-tooltip="Security conscious">üëÄ</div>
                                        <div class="trait-option" data-dimension="procrastination" data-tooltip="Does it later">üò¥</div>
                                        <div class="trait-option" data-dimension="futuristic" data-tooltip="AI & automation lover">ü§ñ</div>
                                    </div>

                                    <!-- Advanced Section -->
                                    <div class="advanced-section">
                                        <button class="advanced-toggle" id="advancedToggle">
                                            ‚ñ∂ Advanced
                                        </button>
                                        <div class="advanced-content" id="advancedContent">
                                            <div style="margin-bottom: 8px;">
                                                <strong>Are you a pro?</strong> Have a go at doing it the hard way
                                            </div>
                                            <button class="advanced-button" id="terminalModeBtn">
                                                Enter Terminal Mode
                                            </button>
                                        </div>
                                    </div>
                                </div>

                                <!-- Action Buttons -->
                                <div class="action-grid">
                                    <button class="action-button" id="generateBtn">
                                        Generate
                                        <div class="button-subtitle">G</div>
                                    </button>
                                    <button class="action-button" id="randomBtn">
                                        Random
                                        <div class="button-subtitle">R</div>
                                    </button>
                                    <button class="action-button secondary" id="resetBtn">
                                        Reset
                                        <div class="button-subtitle">ESC</div>
                                    </button>
                                    <button class="action-button secondary" id="saveBtn">
                                        Save
                                        <div class="button-subtitle">S</div>
                                    </button>
                                </div>
                            </div>

                            <!-- Back side - Terminal interface -->
                            <div class="trait-panel-back">
                                <div class="terminal-container">
                                    <div class="terminal-titlebar">
                                        <div class="terminal-buttons">
                                            <button class="terminal-button close" id="backToTraits"></button>
                                            <button class="terminal-button minimize"></button>
                                            <button class="terminal-button maximize"></button>
                                        </div>
                                        <div class="terminal-title">elliot@terminal ‚Äî claude-code ‚Äî 80√ó24</div>
                                    </div>
                                    <div class="terminal-output" id="terminalOutput">
                                    </div>
                                    <div class="terminal-input-container">
                                        <span class="terminal-prompt-symbol">%</span>
                                        <input type="text" class="terminal-input" id="terminalInput" placeholder="Type 'quest' for guided flow or just start talking..." />
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Right Panel - Elliot Display -->
                    <div class="elliot-display">
                        <div class="helix-container">
                            <!-- Personality Matrix Label -->
                            <div class="matrix-label">Personality Matrix</div>
                            
                            <!-- Water ASCII Visualization - grace without force, finding natural paths -->
                            <div class="water-ascii" id="waterAscii">
                                <pre id="asciiContent"></pre>
                            </div>
                            
                            <div class="generation-path" id="generationPath"></div>
                            
                            <!-- Avatar Generation Label -->
                            <div class="avatar-label">[ Avatar Generation Space ]</div>
                            
                            <!-- Radar Charts Container -->
                            <div class="radar-charts-container" id="radarChartsContainer">
                                <div class="radar-chart-wrapper">
                                    <div class="radar-chart-title">Your Profile</div>
                                    <canvas id="userRadarChart" class="radar-chart" width="120" height="120"></canvas>
                                </div>
                                <div class="radar-chart-wrapper">
                                    <div class="radar-chart-title">Character Match</div>
                                    <canvas id="characterRadarChart" class="radar-chart" width="120" height="120"></canvas>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <section class="projects-section" id="projects">
        <div class="projects-header">
            <h2 class="projects-title">Projects</h2>
        </div>

        <ul class="projects-list">
            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">The Daoist Sage AI Agent <span class="project-status status-case-study">Case Study</span></span>
                    <span class="project-year">2025</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>AI Development & RAG Systems</h3>
                                <p>A case study on grounding AI memory using a dedicated RAG (Retrieval-Augmented Generation) system to solve challenges of hallucination and unreliable memory in AI trading agents.</p>
                                <p>The core challenge emerged from developing an AI crypto trading agent where memory issues and hallucination severely limited reliability. AI hallucination causes confident generation of factually incorrect information, while fickle memory creates inability to recall crucial details from knowledge bases or maintain coherent context.</p>
                                <p>The solution involved building a Daoist Sage Agent using RAG as its foundational memory and accuracy mechanism. As Product Manager and Lead Developer, I handled the full process from ideation to conceptual deployment.</p>
                                <p>The future vision includes processing complex internal documentation and providing specialized, fact-checked assistance in regulated industries where precision and verifiability are crucial.</p>
                                <p><a href="https://github.com/el-fuegoso/daobot" class="project-link" target="_blank" rel="noopener noreferrer">‚ñ∂ View Code</a></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/daobot/agent-interface.jpg')">Agent Interface</div>
                                <div class="project-image" style="background-image: url('./images/daobot/rag-architecture.jpg')">RAG Architecture</div>
                                <div class="project-image" style="background-image: url('./images/daobot/memory-system.jpg')">Memory System</div>
                                <div class="project-image" style="background-image: url('./images/daobot/testing-results.jpg')">Testing Results</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>

            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">Eliza Trading Agent <span class="project-status status-pivoted">Pivoted</span></span>
                    <span class="project-year">2025</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>AI-Powered Memecoin Trading</h3>
                                <p>An attempt to develop an AI-powered memecoin trading bot to capitalize on Solana's volatility while managing risk.</p>
                                <p>The approach involved training Mistral 7B on Pump.fun launch patterns combined with Twitter sentiment analysis. Integration with 3Commas API as a provider allowed testing of hybrid DEX/CEX strategy through paper trading on the 3Commas platform.</p>
                                <p>The outcome was clear: the system was inconsistent and kept hallucinating on the signals being fed to it. The project was pivoted due to inability to achieve reliable trading consistency.</p>
                                <p>This failure led to valuable insights about AI reliability in financial applications and directly informed the development of the Daoist Sage Agent with its focus on grounded memory systems.</p>
                                <p><em>Project documentation available upon request</em></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/eliza/eliza-banner.jpg')">Eliza Banner</div>
                                <div class="project-image" style="background-image: url('./images/eliza/trading-interface.jpg')">Trading Interface</div>
                                <div class="project-image" style="background-image: url('./images/eliza/performance-metrics.jpg')">Performance Metrics</div>
                                <div class="project-image" style="background-image: url('./images/eliza/lessons-learned.jpg')">Lessons Learned</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>

            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">Kaiawhina Auckland</span>
                    <span class="project-year">2023 ‚Äì 2024</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>Activism & Social Justice</h3>
                                <p>In 2023, as global calls for a Free Palestine grew louder, I realized my skills and privilege needed redirecting. Joining Kaiawhina Auckland, I committed to honoring MƒÅori sovereignty, supporting Palestinian freedom, and advancing climate justice.</p>
                                <p>The work involves weekly marshal duties for activations, disrupting "business as usual" at corporate complicity sites, and learning that actions matter more than hashtags. The experience taught crucial lessons: data is power (using Signal to track police or counter protestors movements at demonstrations), access is activism (always providing wheelchair routes and live captions), and joy is resistance (singing waiata at 5am blockades).</p>
                                <p>This work reinforced that technology doesn't exist in a vacuum and provided hands-on experience in using tech skills for social justice organizing.</p>
                                <p><a href="https://www.instagram.com/kaiawhina_tamaki/" class="project-link" target="_blank" rel="noopener noreferrer">‚ñ∂ Learn About Kaiawhina</a></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/kaiawhina/demonstration-photography.jpg')">Demonstration Photography</div>
                                <div class="project-image" style="background-image: url('./images/kaiawhina/community-organizing.jpg')">Community Organizing</div>
                                <div class="project-image" style="background-image: url('./images/kaiawhina/marshall-training.jpg')">Marshall Training</div>
                                <div class="project-image" style="background-image: url('./images/kaiawhina/solidarity-actions.jpg')">Solidarity Actions</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>

            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">Drama School 202: The Illusion</span>
                    <span class="project-year">2023</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>Black Box Theatre Performance</h3>
                                <p>A reimagining of Tony Kushner's baroque meta-theatrical fantasy as a contemporary meditation on love, artifice, and the transformative power of storytelling under director Leo Gene Peters.</p>
                                <p>Our approach centered on staging the unreal by building a 1:1 cave to bring the audience into the world. We performed costume quick-changes in full view to highlight theatrical artifice and projected text fragments from Kushner's stage directions onto actors' bodies. The production challenged actors to master 17th-century verse while finding modern emotional truth.</p>
                                <p>As Theogenes - The Lover, I connected with the verbs that brought the character to life and genuinely fell in love on stage. I also taught yoga to the company every other day, helping connect with breath and body.</p>
                                <p><em>Performance archived in personal collection</em></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/drama/performance-photography.jpg')">Performance Photography</div>
                                <div class="project-image" style="background-image: url('./images/drama/behind-the-scenes.jpg')">Behind-the-Scenes</div>
                                <div class="project-image" style="background-image: url('./images/drama/cast-images.jpg')">Cast Images</div>
                                <div class="project-image" style="background-image: url('./images/drama/set-design.jpg')">Set Design</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>

            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">Vipassana Journey <span class="project-status status-ongoing">Ongoing</span></span>
                    <span class="project-year">2022 ‚Äì Present</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>Personal Practice & Mindfulness</h3>
                                <p>After burning out from building startups, I needed something no algorithm could provide. A way to sit with myself.</p>
                                <p>The practice involves 10 day silent retreats completed at Dhamma Medini, NZ, with an intention of twice daily meditation sits. The approach eschews apps and hacks in favor of just the breath, the body, and whatever arises.</p>
                                <p>The key insight: "It's not about achieving some perfect mental state, it's about seeing what's already there." This ongoing practice provides grounding and perspective that informs all other work.</p>
                                <p>This foundation of mindfulness and presence has become integral to my approach to technology, bringing intention and awareness to how I build and interact with digital systems.</p>
                                <p><a href="https://www.dhamma.org/en/index" class="project-link" target="_blank" rel="noopener noreferrer">‚ñ∂ Learn More</a></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/vipassana/retreat-photography.jpg')">Retreat Photography</div>
                                <div class="project-image" style="background-image: url('./images/vipassana/meditation-hall.jpg')">Meditation Hall</div>
                                <div class="project-image" style="background-image: url('./images/vipassana/dhamma-medini.jpg')">Dhamma Medini</div>
                                <div class="project-image" style="background-image: url('./images/vipassana/silent-reflection.jpg')">Silent Reflection</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>

            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">Talent Army <span class="project-status status-award">Award Winner</span></span>
                    <span class="project-year">2022</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>Best UX Design, NZ Tech Innovation | Psychoactive</h3>
                                <p>A reimagining of tech recruitment as a dynamic growth journey, replacing sterile job boards with living stories of career transformation.</p>
                                <p>The narrative-driven web experience featured claymation-style 3D animations, spontaneous "Easter egg" movements, and visual storytelling for both employers and candidates. The intelligent job board included custom API syncing between Webflow and JobAdder in real-time, JetBoost filtering that felt like Tinder for dream jobs, and Kiwi-tech coded icons replacing generic briefcase symbols.</p>
                                <p>As Account Manager, I won the pitch against 4 agencies by demonstrating how storytelling reduces candidate drop-off. As Conductor, I managed 6 specialists across 3 timezones, and as Bridge Builder, I translated recruiter pain points into playful interactions.</p>
                                <p>The project was shortlisted for 2023 Webby Awards and became Talent Army's flagship client acquisition tool.</p>
                                <p><a href="https://www.talent.army/" class="project-link" target="_blank" rel="noopener noreferrer">‚ñ∂ View Live Site</a></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/talent-army/homepage-design.jpg')">Homepage Design</div>
                                <div class="project-image" style="background-image: url('./images/talent-army/job-board-interface.jpg')">Job Board Interface</div>
                                <div class="project-image" style="background-image: url('./images/talent-army/3d-animation-examples.jpg')">3D Animation Examples</div>
                                <div class="project-image" style="background-image: url('./images/talent-army/awards-recognition.jpg')">Awards Recognition</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>

            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">Blackbird VC</span>
                    <span class="project-year">2022</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>Australia | Psychoactive</h3>
                                <p>Blackbird VC needed a digital presence as bold as their investments. One that would make founders feel seen, not just pitched to.</p>
                                <p>We abandoned the tired "suits shaking hands" aesthetic and built an electric visual language featuring handmade documentary photography of real founders and bespoke animations mimicking startup momentum. The functional artistry organized content like a gallery with no buried decks, and interactive founder stories triggered by scroll velocity.</p>
                                <p>My role as Deal Maker involved working with the development team and Blackbird to envision a website that was both achievable and visually stunning, creating a rebellion against traditional VC digital clich√©s.</p>
                                <p><a href="https://www.blackbird.vc/home-hub" class="project-link" target="_blank" rel="noopener noreferrer">‚ñ∂ View Project</a></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/blackbird/homepage-design.jpg')">Homepage Design</div>
                                <div class="project-image" style="background-image: url('./images/blackbird/portfolio-layout.jpg')">Portfolio Layout</div>
                                <div class="project-image" style="background-image: url('./images/blackbird/founder-stories-interface.jpg')">Founder Stories Interface</div>
                                <div class="project-image" style="background-image: url('./images/blackbird/interactive-elements.jpg')">Interactive Elements</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>

            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">121 Festival</span>
                    <span class="project-year">2021</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>Entertainment Technology | Psychoactive</h3>
                                <p>Wellington's legendary Club 121 needed a website that could bottle their underground energy and pour it across screens nationwide. A digital mainstage for their debut festival.</p>
                                <p>The project featured psychedelic Kiwi immersion with native flora and fauna illustrations pulsing to ambient basslines, hover-triggered soundwave animations, and lineup reveals that felt like uncovering secret set times at the venue. The technical backbone included an Airtable/Zapier CMS allowing real-time vendor applications and volunteer coordination.</p>
                                <p>As Project Manager, I pitched the "digital doof" concept after attending 3 club nights for research. As Systems Architect, I streamlined 14 stakeholder workflows into one unified backend while balancing festival chaos with UX clarity.</p>
                                <p><em>Festival concluded - site archived</em></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/121-festival/homepage-design.jpg')">Homepage Design</div>
                                <div class="project-image" style="background-image: url('./images/121-festival/content-management-interface.jpg')">Content Management Interface</div>
                                <div class="project-image" style="background-image: url('./images/121-festival/interactive-elements.jpg')">Interactive Elements</div>
                                <div class="project-image" style="background-image: url('./images/121-festival/festival-branding.jpg')">Festival Branding</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>
        </ul>
    </section>

    <section class="contact-section" id="contact">
        <div class="contact-header">
            <h2 class="contact-title">Contact</h2>
        </div>
        
        <div class="contact-buttons">
            <a href="https://www.linkedin.com/in/elliot-james-lee" class="contact-button" target="_blank" rel="noopener noreferrer">
                <span>LinkedIn</span>
            </a>
            <a href="mailto:elliotjameslee8@gmail.com" class="contact-button">
                <span>Email</span>
            </a>
            <a href="https://www.instagram.com/elliot.james.lee/" class="contact-button" target="_blank" rel="noopener noreferrer">
                <span>Instagram</span>
            </a>
        </div>
    </section>

    <div class="performance-info" id="performanceInfo">
        Performance: Optimized
    </div>

    <!-- Configuration and main application scripts now in js/main.js -->
    <script>
        const CONFIG = {
            artifacts: {
                hankies: { 
                    resolution: window.innerWidth < 768 ? 16 : 32, 
                    animationSpeed: 0.0013 
                },
                particles: { 
                    count: window.innerWidth < 768 ? 15000 : 45000, 
                    opacity: 0.4 
                },
                ascii: {
                    width: window.innerWidth < 768 ? 45 : 65,
                    height: window.innerWidth < 768 ? 45 : 65
                },
                metamorphosis: {
                    numLines: window.innerWidth < 768 ? 60 : 120,
                    lineSegments: window.innerWidth < 768 ? 90 : 180
                },
                sineWaves: {
                    layers: window.innerWidth < 768 ? 40 : 80,
                    points: window.innerWidth < 768 ? 100 : 200
                }
            },
            transitions: { duration: 1200, delay: 150 },
            titles: ["ELLIOT LEE", "PRODUCT MANAGER", "BUILDER", "ACCOUNT MANAGER", "HUMAN"]
        };

        // Performance monitoring configuration
        const PERFORMANCE_CONFIG = {
            battery: {
                lowThreshold: 0.2,
                criticalThreshold: 0.1
            },
            thermal: {
                throttleTemp: 45, // Celsius
                shutdownTemp: 55
            },
            network: {
                slowConnection: ['slow-2g', '2g'],
                fastConnection: ['4g', '5g']
            },
            performance: {
                targetFPS: 60,
                minFPS: 30
            }
        };

        // Mobile Performance Manager
        class MobilePerformanceManager {
            constructor() {
                this.isLowPower = false;
                this.isCriticalMode = false;
                this.currentFPS = 60;
                this.frameCount = 0;
                this.lastFPSUpdate = Date.now();
                this.originalConfig = this.backupConfig();
                this.setupMonitoring();
            }
            
            backupConfig() {
                return JSON.parse(JSON.stringify(CONFIG.artifacts));
            }
            
            async setupMonitoring() {
                // Battery API monitoring
                if ('getBattery' in navigator) {
                    try {
                        const battery = await navigator.getBattery();
                        this.monitorBattery(battery);
                    } catch (e) {
                        console.log('Battery API not available');
                    }
                }
                
                // Network connection monitoring
                if ('connection' in navigator) {
                    this.monitorConnection();
                }
                
                // Frame rate monitoring
                this.startFPSMonitoring();
                
                // Visibility change optimization
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        this.pauseHeavyAnimations();
                    } else {
                        this.resumeAnimations();
                    }
                });
                
                // Device memory monitoring (if available)
                if ('deviceMemory' in navigator && navigator.deviceMemory < 4) {
                    this.enableLowMemoryMode();
                }
            }
            
            monitorBattery(battery) {
                const checkBattery = () => {
                    const batteryInfo = {
                        level: battery.level,
                        charging: battery.charging,
                        chargingTime: battery.chargingTime,
                        dischargingTime: battery.dischargingTime
                    };
                    
                    if (battery.level < PERFORMANCE_CONFIG.battery.criticalThreshold) {
                        this.enableCriticalMode(batteryInfo);
                    } else if (battery.level < PERFORMANCE_CONFIG.battery.lowThreshold) {
                        this.enableLowPowerMode(batteryInfo);
                    } else if (!battery.charging && this.isLowPower) {
                        // Only disable low power if we're not charging and battery is good
                        this.disableLowPowerMode();
                    }
                };
                
                battery.addEventListener('levelchange', checkBattery);
                battery.addEventListener('chargingchange', checkBattery);
                checkBattery();
            }
            
            monitorConnection() {
                const connection = navigator.connection;
                const checkConnection = () => {
                    if (PERFORMANCE_CONFIG.network.slowConnection.includes(connection.effectiveType)) {
                        this.enableLowBandwidthMode();
                    } else if (PERFORMANCE_CONFIG.network.fastConnection.includes(connection.effectiveType)) {
                        this.disableLowBandwidthMode();
                    }
                };
                
                connection.addEventListener('change', checkConnection);
                checkConnection();
            }
            
            startFPSMonitoring() {
                const measureFPS = () => {
                    this.frameCount++;
                    const now = Date.now();
                    
                    if (now - this.lastFPSUpdate >= 1000) {
                        this.currentFPS = this.frameCount;
                        this.frameCount = 0;
                        this.lastFPSUpdate = now;
                        
                        // Adjust performance based on FPS
                        if (this.currentFPS < PERFORMANCE_CONFIG.performance.minFPS && !this.isLowPower) {
                            this.enablePerformanceMode();
                        }
                        
                        this.updatePerformanceIndicator();
                    }
                    
                    requestAnimationFrame(measureFPS);
                };
                measureFPS();
            }
            
            enableLowPowerMode(batteryInfo = null) {
                if (this.isLowPower) return;
                this.isLowPower = true;
                
                // Reduce particle counts by 75%
                CONFIG.artifacts.particles.count = Math.floor(this.originalConfig.particles.count * 0.25);
                CONFIG.artifacts.hankies.resolution = Math.floor(this.originalConfig.hankies.resolution * 0.5);
                CONFIG.artifacts.ascii.width = Math.floor(this.originalConfig.ascii.width * 0.7);
                CONFIG.artifacts.ascii.height = Math.floor(this.originalConfig.ascii.height * 0.7);
                CONFIG.artifacts.metamorphosis.numLines = Math.floor(this.originalConfig.metamorphosis.numLines * 0.5);
                CONFIG.artifacts.metamorphosis.lineSegments = Math.floor(this.originalConfig.metamorphosis.lineSegments * 0.5);
                CONFIG.artifacts.sineWaves.layers = Math.floor(this.originalConfig.sineWaves.layers * 0.5);
                CONFIG.artifacts.sineWaves.points = Math.floor(this.originalConfig.sineWaves.points * 0.5);
                
                // Reduce animation speeds
                CONFIG.artifacts.hankies.animationSpeed *= 0.5;
                
                // Show low power indicator
                const message = batteryInfo ? 
                    `Low Power Mode: ${Math.round(batteryInfo.level * 100)}% battery` : 
                    'Low Power Mode Active';
                this.showPowerModeIndicator(message, '#ff9500');
                
                // Restart current artifact with new settings
                this.restartCurrentArtifact();
                
                console.log('Low power mode enabled', batteryInfo);
            }
            
            enableCriticalMode(batteryInfo) {
                if (this.isCriticalMode) return;
                this.isCriticalMode = true;
                this.isLowPower = true;
                
                // Stop all animations except essential UI
                this.pauseAllArtifacts();
                this.showPowerModeIndicator(
                    `Critical Battery: ${Math.round(batteryInfo.level * 100)}% - Animations Paused`, 
                    '#ff3300'
                );
                console.log('Critical battery mode enabled', batteryInfo);
            }
            
            enablePerformanceMode() {
                // Automatically reduce settings when FPS drops
                CONFIG.artifacts.particles.count = Math.floor(CONFIG.artifacts.particles.count * 0.8);
                CONFIG.artifacts.hankies.resolution = Math.max(8, Math.floor(CONFIG.artifacts.hankies.resolution * 0.8));
                
                this.showPowerModeIndicator(`Performance Mode: ${this.currentFPS}fps`, '#ffa500');
                this.restartCurrentArtifact();
            }
            
            enableLowMemoryMode() {
                CONFIG.artifacts.particles.count = Math.floor(CONFIG.artifacts.particles.count * 0.6);
                CONFIG.artifacts.ascii.width = Math.floor(CONFIG.artifacts.ascii.width * 0.8);
                CONFIG.artifacts.ascii.height = Math.floor(CONFIG.artifacts.ascii.height * 0.8);
                
                this.showPowerModeIndicator('Low Memory Mode', '#ff6600');
                console.log('Low memory mode enabled');
            }
            
            enableLowBandwidthMode() {
                // Reduce update frequencies for network-dependent features
                CONFIG.transitions.duration = Math.min(CONFIG.transitions.duration * 1.5, 2000);
                this.showPowerModeIndicator('Slow Connection Detected', '#666666');
            }
            
            disableLowPowerMode() {
                if (!this.isLowPower) return;
                this.isLowPower = false;
                this.isCriticalMode = false;
                
                // Restore original settings
                CONFIG.artifacts = JSON.parse(JSON.stringify(this.originalConfig));
                
                this.hidePowerModeIndicator();
                this.restartCurrentArtifact();
                console.log('Low power mode disabled');
            }
            
            disableLowBandwidthMode() {
                CONFIG.transitions.duration = 1200; // Reset to default
            }
            
            pauseHeavyAnimations() {
                // Pause current artifact animations
                if (window.currentArtifactAnimation) {
                    cancelAnimationFrame(window.currentArtifactAnimation);
                }
                
                // Pause Three.js rendering
                Object.values(threeScenes).forEach(scene => {
                    if (scene.renderer && scene.renderer.setAnimationLoop) {
                        scene.renderer.setAnimationLoop(null);
                    }
                });
            }
            
            pauseAllArtifacts() {
                this.pauseHeavyAnimations();
                // Set black background to save energy
                document.body.style.background = '#000000';
            }
            
            resumeAnimations() {
                if (!this.isCriticalMode && !document.hidden) {
                    // Restart current artifact if not in critical mode
                    if (typeof artifacts !== 'undefined' && artifacts[currentArtifact]) {
                        artifacts[currentArtifact]();
                    }
                    
                    // Restore background
                    document.body.style.background = '';
                }
            }
            
            restartCurrentArtifact() {
                if (this.isCriticalMode) return;
                
                // Clean up current artifact
                if (threeScenes[`artifact-${currentArtifact + 1}`]?.cleanup) {
                    threeScenes[`artifact-${currentArtifact + 1}`].cleanup();
                }
                
                // Restart with new settings
                setTimeout(() => {
                    if (artifacts[currentArtifact]) {
                        artifacts[currentArtifact]();
                    }
                }, 100);
            }
            
            showPowerModeIndicator(message, color = '#ff9500') {
                let indicator = document.getElementById('powerModeIndicator');
                if (!indicator) {
                    indicator = document.createElement('div');
                    indicator.id = 'powerModeIndicator';
                    indicator.style.cssText = `
                        position: fixed;
                        top: 80px;
                        right: 20px;
                        background: ${color};
                        color: white;
                        padding: 8px 12px;
                        border-radius: 4px;
                        font-size: 12px;
                        z-index: 1002;
                        font-family: 'Roboto Mono', monospace;
                        max-width: 200px;
                        text-align: center;
                        animation: slideInRight 0.3s ease-out;
                    `;
                    document.body.appendChild(indicator);
                    
                    // Add animation
                    const style = document.createElement('style');
                    style.textContent = `
                        @keyframes slideInRight {
                            from { transform: translateX(100%); opacity: 0; }
                            to { transform: translateX(0); opacity: 1; }
                        }
                    `;
                    document.head.appendChild(style);
                } else {
                    indicator.style.background = color;
                }
                indicator.textContent = message;
            }
            
            hidePowerModeIndicator() {
                const indicator = document.getElementById('powerModeIndicator');
                if (indicator) {
                    indicator.style.animation = 'slideInRight 0.3s ease-out reverse';
                    setTimeout(() => indicator.remove(), 300);
                }
            }
            
            updatePerformanceIndicator() {
                const perfInfo = document.getElementById('performanceInfo');
                if (perfInfo) {
                    let status = 'Optimized';
                    let color = '#00ff00';
                    
                    if (this.isCriticalMode) {
                        status = 'Critical Battery';
                        color = '#ff3300';
                    } else if (this.isLowPower) {
                        status = 'Low Power';
                        color = '#ff9500';
                    } else if (this.currentFPS < PERFORMANCE_CONFIG.performance.minFPS) {
                        status = `${this.currentFPS}fps`;
                        color = '#ffa500';
                    }
                    
                    perfInfo.textContent = `Performance: ${status}`;
                    perfInfo.style.color = color;
                }
            }
        }

        // Enhanced Mobile Accessibility Manager
        class MobileAccessibilityManager {
            constructor() {
                this.setupMobileA11y();
                this.setupScreenReaderSupport();
                this.setupVoiceOverSupport();
                this.setupTalkBackSupport();
                this.addLiveRegions();
            }
            
            setupMobileA11y() {
                // Enhanced focus management for mobile
                document.addEventListener('focusin', (e) => {
                    const target = e.target;
                    
                    // Ensure focused element is visible on mobile
                    if (target.classList.contains('glitch-title') || 
                        target.classList.contains('spark-magic') ||
                        target.classList.contains('chat-control-btn')) {
                        target.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'center',
                            inline: 'nearest'
                        });
                    }
                    
                    // Add focus announcement for screen readers
                    if (target.hasAttribute('aria-label')) {
                        this.announceToScreenReader(`Focused: ${target.getAttribute('aria-label')}`);
                    }
                });
                
                // Enhanced keyboard navigation
                document.addEventListener('keydown', (e) => {
                    // Handle escape key to close modals
                    if (e.key === 'Escape') {
                        this.handleEscapeKey();
                    }
                    
                    // Handle arrow keys for artifact navigation
                    if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                        const activeElement = document.activeElement;
                        if (activeElement.classList.contains('glitch-title') || 
                            activeElement.classList.contains('spark-magic')) {
                            e.preventDefault();
                            
                            if (e.key === 'ArrowRight') {
                                changeEverything();
                                this.announceToScreenReader('Next experience loaded');
                            } else if (window.gestureManager?.previousArtifact) {
                                window.gestureManager.previousArtifact();
                                this.announceToScreenReader('Previous experience loaded');
                            }
                        }
                    }
                });
            }
            
            addLiveRegions() {
                // Create ARIA live region for dynamic announcements
                const liveRegion = document.createElement('div');
                liveRegion.setAttribute('aria-live', 'polite');
                liveRegion.setAttribute('aria-atomic', 'true');
                liveRegion.setAttribute('id', 'liveRegion');
                liveRegion.className = 'sr-only';
                liveRegion.style.cssText = `
                    position: absolute;
                    width: 1px;
                    height: 1px;
                    padding: 0;
                    margin: -1px;
                    overflow: hidden;
                    clip: rect(0, 0, 0, 0);
                    white-space: nowrap;
                    border: 0;
                `;
                document.body.appendChild(liveRegion);
                
                // Create assertive live region for urgent announcements
                const assertiveRegion = document.createElement('div');
                assertiveRegion.setAttribute('aria-live', 'assertive');
                assertiveRegion.setAttribute('aria-atomic', 'true');
                assertiveRegion.setAttribute('id', 'assertiveRegion');
                assertiveRegion.className = 'sr-only';
                assertiveRegion.style.cssText = liveRegion.style.cssText;
                document.body.appendChild(assertiveRegion);
            }
            
            setupScreenReaderSupport() {
                // Enhance artifact change announcements
                const originalChangeEverything = window.changeEverything;
                window.changeEverything = () => {
                    originalChangeEverything.call(window);
                    
                    setTimeout(() => {
                        const currentTitle = CONFIG.titles[currentTitleIndex];
                        const experienceNumber = currentArtifact + 1;
                        this.announceToScreenReader(
                            `Now showing experience ${experienceNumber}: ${currentTitle} with interactive artwork`
                        );
                    }, 500);
                };
                
                // Add landmarks and structure
                this.addLandmarkRoles();
                this.enhanceFormAccessibility();
            }
            
            addLandmarkRoles() {
                // Add main landmark
                const heroContainer = document.querySelector('.hero-container');
                if (heroContainer) {
                    heroContainer.setAttribute('role', 'main');
                    heroContainer.setAttribute('aria-label', 'Portfolio showcase with interactive art');
                }
                
                // Add navigation landmark
                const navBar = document.querySelector('.nav-bar');
                if (navBar) {
                    navBar.setAttribute('role', 'navigation');
                    navBar.setAttribute('aria-label', 'Main navigation');
                }
                
                // Add complementary landmarks for sections
                const contactSection = document.querySelector('.contact-section');
                if (contactSection) {
                    contactSection.setAttribute('role', 'complementary');
                    contactSection.setAttribute('aria-label', 'Contact information');
                }
                
                const projectsSection = document.querySelector('.projects-section');
                if (projectsSection) {
                    projectsSection.setAttribute('role', 'region');
                    projectsSection.setAttribute('aria-label', 'Featured projects');
                }
            }
            
            enhanceFormAccessibility() {
                // Enhance chat input
                const messageInput = document.getElementById('messageInput');
                if (messageInput) {
                    messageInput.setAttribute('aria-describedby', 'messageInputDesc');
                    
                    const description = document.createElement('div');
                    description.id = 'messageInputDesc';
                    description.className = 'sr-only';
                    description.textContent = 'Type your message and press Enter to send';
                    messageInput.parentNode.insertBefore(description, messageInput);
                }
                
                // Enhance project items
                document.querySelectorAll('.project-item').forEach((item, index) => {
                    item.setAttribute('role', 'button');
                    item.setAttribute('aria-expanded', 'false');
                    item.setAttribute('aria-describedby', `project-desc-${index}`);
                    item.setAttribute('tabindex', '0');
                    
                    const originalToggle = item.onclick;
                    item.onclick = function() {
                        originalToggle.call(this);
                        const isOpen = this.classList.contains('open');
                        this.setAttribute('aria-expanded', isOpen.toString());
                        
                        const action = isOpen ? 'expanded' : 'collapsed';
                        window.accessibilityManager.announceToScreenReader(
                            `Project ${this.querySelector('.project-header').textContent} ${action}`
                        );
                    };
                    
                    // Add keyboard support
                    item.addEventListener('keydown', (e) => {
                        if (e.key === ' ' || e.key === 'Enter') {
                            e.preventDefault();
                            item.click();
                        }
                    });
                });
            }
            
            setupVoiceOverSupport() {
                // Enhanced VoiceOver navigation for iOS
                document.querySelector('.glitch-title').setAttribute(
                    'aria-description', 
                    'Interactive title that cycles through different professional identities and changes the background artwork. Swipe or use arrow keys to navigate.'
                );
                
                document.querySelector('.spark-magic').setAttribute(
                    'aria-description',
                    'Alternative control to cycle through visual experiences'
                );
                
                // Add VoiceOver-specific hint text
                if (this.isIOSDevice()) {
                    const voiceOverHints = document.createElement('div');
                    voiceOverHints.className = 'sr-only';
                    voiceOverHints.textContent = 'VoiceOver users: Use flick gestures to navigate between elements, and double-tap to activate. Swipe left or right on the main area to change experiences.';
                    document.body.appendChild(voiceOverHints);
                }
            }
            
            setupTalkBackSupport() {
                // Enhanced TalkBack support for Android
                if (this.isAndroidDevice()) {
                    // Add content descriptions for TalkBack
                    document.querySelectorAll('[role="button"]').forEach(button => {
                        if (!button.hasAttribute('aria-description')) {
                            const label = button.getAttribute('aria-label') || button.textContent;
                            button.setAttribute('aria-description', `Button: ${label}`);
                        }
                    });
                    
                    // Add TalkBack-specific instructions
                    const talkBackHints = document.createElement('div');
                    talkBackHints.className = 'sr-only';
                    talkBackHints.textContent = 'TalkBack users: Use explore by touch to navigate, and double-tap to activate elements. Swipe gestures change the visual experience.';
                    document.body.appendChild(talkBackHints);
                }
            }
            
            announceToScreenReader(message, urgent = false) {
                const regionId = urgent ? 'assertiveRegion' : 'liveRegion';
                const region = document.getElementById(regionId);
                if (region) {
                    // Clear first to ensure the announcement triggers
                    region.textContent = '';
                    setTimeout(() => {
                        region.textContent = message;
                    }, 100);
                    
                    // Clear after announcement
                    setTimeout(() => {
                        region.textContent = '';
                    }, 3000);
                }
            }
            
            handleEscapeKey() {
                // Close any open modals or overlays
                const chatOverlay = document.querySelector('.chat-overlay.active');
                if (chatOverlay) {
                    chatOverlay.classList.remove('active');
                    this.announceToScreenReader('Chat closed');
                    return;
                }
                
                const terminalOverlay = document.getElementById('terminalOverlay');
                if (terminalOverlay && terminalOverlay.style.display === 'block') {
                    terminalOverlay.style.display = 'none';
                    this.announceToScreenReader('Terminal closed');
                    return;
                }
                
                // Close any expanded project items
                const openProjects = document.querySelectorAll('.project-item.open');
                if (openProjects.length > 0) {
                    openProjects.forEach(project => {
                        project.classList.remove('open');
                        project.setAttribute('aria-expanded', 'false');
                    });
                    this.announceToScreenReader('All projects collapsed');
                }
            }
            
            isIOSDevice() {
                return /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                       (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            }
            
            isAndroidDevice() {
                return /Android/.test(navigator.userAgent);
            }
            
            // Performance mode accessibility adjustments
            adjustForPerformanceMode() {
                if (window.performanceManager?.isLowPower) {
                    // Reduce animation announcements in low power mode
                    this.announceToScreenReader('Low power mode active - reduced animations for better battery life');
                }
                
                if (window.performanceManager?.isCriticalMode) {
                    this.announceToScreenReader('Critical battery mode - animations paused to conserve power', true);
                }
            }
        }

        // Global state
        let currentArtifact = 0;
        let currentTheme = 'light';
        let currentTitleIndex = 0;
        let isTweening = false;
        let artifacts = [];
        let threeScenes = {};
        let isTransitioning = false;
        let resizeTimeout;
        let performanceMonitor = { fps: 0, lastTime: 0, frameCount: 0 };

        // Performance monitoring
        function updatePerformanceInfo() {
            performanceMonitor.frameCount++;
            const currentTime = performance.now();
            
            if (currentTime > performanceMonitor.lastTime + 1000) {
                performanceMonitor.fps = Math.round((performanceMonitor.frameCount * 1000) / (currentTime - performanceMonitor.lastTime));
                performanceMonitor.frameCount = 0;
                performanceMonitor.lastTime = currentTime;
                
                const perfInfo = document.getElementById('performanceInfo');
                if (perfInfo) {
                    const quality = performanceMonitor.fps > 45 ? 'Excellent' : 
                                   performanceMonitor.fps > 30 ? 'Good' : 'Basic';
                    perfInfo.textContent = `Performance: ${quality} (${performanceMonitor.fps} FPS)`;
                }
            }
        }

        // Error handling wrapper
        function safeInitArtifact(artifactFunction, artifactId, fallback = null) {
            try {
                artifactFunction();
            } catch (error) {
                console.warn(`Artifact ${artifactId} initialization failed:`, error);
                if (fallback) {
                    fallback();
                } else {
                    // Show error fallback
                    const container = document.getElementById(artifactId);
                    if (container) {
                        container.innerHTML = '<div class="error-fallback">Unable to load visualization</div>';
                    }
                }
            }
        }

        // Enhanced cleanup function
        function enhancedCleanup(scene, renderer, container, animationFrameId) {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            
            if (scene) {
                scene.traverse((object) => {
                    if (object.geometry) {
                        object.geometry.dispose();
                    }
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(material => material.dispose());
                        } else {
                            object.material.dispose();
                        }
                    }
                });
            }
            
            if (renderer) {
                renderer.dispose();
                if (renderer.domElement && container && container.contains(renderer.domElement)) {
                    container.removeChild(renderer.domElement);
                }
            }
        }

        // Accessibility: Keyboard event handler
        function handleKeyPress(event) {
            if (event.key === ' ' || event.key === 'Enter') {
                event.preventDefault();
                changeEverything();
            }
        }

        // Title cycling system
        function cycleTitle() {
            const titleElement = document.querySelector('.glitch-title');
            
            currentTitleIndex = (currentTitleIndex + 1) % CONFIG.titles.length;
            const newTitle = CONFIG.titles[currentTitleIndex];
            
            gsap.to(titleElement, {
                duration: 1.2,
                text: {
                    value: newTitle,
                    delimiter: ""
                },
                ease: "none"
            });
        }

        // Combined function that changes both title and artifact
        function changeEverything() {
            if (isTransitioning) return;
            isTransitioning = true;
            
            // Trigger title glitch
            cycleTitle();
            
            // Change artifact with slight delay for dramatic effect
            setTimeout(() => {
                changeArtifact();
                setTimeout(() => {
                    isTransitioning = false;
                }, CONFIG.transitions.duration);
            }, CONFIG.transitions.delay);
            
            // Visual feedback for buttons
            const activeElement = document.activeElement;
            if (activeElement.classList.contains('spark-magic') || activeElement.classList.contains('glitch-title')) {
                activeElement.style.transform = 'scale(1.2)';
                setTimeout(() => {
                    activeElement.style.transform = '';
                }, 200);
            }
        }

        // Initialize artifacts
        function initializeArtifacts() {
            artifacts = [
                () => safeInitArtifact(initHankiesInTheWind, 'artifact-1'),
                () => safeInitArtifact(initAsciiBinaryFlow, 'artifact-2'),
                () => safeInitArtifact(initParticleVessel, 'artifact-3'),
                () => safeInitArtifact(initMetamorphosis, 'artifact-4'),
                () => safeInitArtifact(initLayeredSineWaves, 'artifact-5')
            ];
            
            // Initialize the first artifact
            artifacts[0]();
        }

        // Artifact 1: Enhanced HankiesInTheWind
        function initHankiesInTheWind() {
            const container = document.getElementById('artifact-1');
            if (container.hasChildNodes()) return;
            
            let scene, camera, renderer, lineGroups = [];
            let animationFrameId;
            
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ 
                antialias: !window.matchMedia('(max-width: 768px)').matches,
                powerPreference: "high-performance"
            });
            
            renderer.setSize(width, height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(currentTheme === 'dark' ? 0x1a1a1a : 0xF0EEE6);
            container.appendChild(renderer.domElement);
            
            camera.position.set(0, 0, 6);
            camera.lookAt(0, 0, 0);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(5, 5, 5);
            scene.add(ambientLight);
            scene.add(directionalLight);
            
            const mainGroup = new THREE.Group();
            scene.add(mainGroup);
            
            let time = 0;
            
            function createWaveSources(time, scale) {
                const result = [];
                const count = 5;
                
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const radius = scale * (1 + Math.sin(angle * 3) * 0.2);
                    
                    result.push({
                        position: [
                            Math.cos(angle) * radius,
                            0,
                            Math.sin(angle) * radius
                        ],
                        frequency: 2 + Math.sin(angle * 2),
                        amplitude: 0.3 + Math.cos(angle) * 0.1,
                        phase: time * 3 + angle
                    });
                }
                
                result.push({
                    position: [0, 0, 0],
                    frequency: 3,
                    amplitude: 0.4,
                    phase: time * 4
                });
                
                return result;
            }
            
            function createInterferenceField(sources, size, resolution, time) {
                const step = size / resolution;
                const heightMap = [];
                
                for (let i = 0; i <= resolution; i++) {
                    heightMap[i] = [];
                    const x = (i * step) - (size / 2);
                    
                    for (let j = 0; j <= resolution; j++) {
                        const z = (j * step) - (size / 2);
                        let height = 0;
                        
                        sources.forEach(({ position: [sx, sy, sz], frequency, amplitude, phase }) => {
                            const dx = x - sx;
                            const dz = z - sz;
                            const distance = Math.sqrt(dx * dx + dz * dz);
                            height += Math.sin(distance * frequency - time * 5 + phase) * 
                                     amplitude * Math.exp(-distance * 0.3);
                        });
                        
                        heightMap[i][j] = height;
                    }
                }
                
                const linesMaterial = new THREE.LineBasicMaterial({ 
                    color: currentTheme === 'dark' ? 0xffffff : 0x333333,
                    transparent: true,
                    opacity: 0.4
                });
                
                const linesGroup = new THREE.Group();
                
                // Create horizontal lines
                for (let i = 0; i <= resolution; i++) {
                    const geometry = new THREE.BufferGeometry();
                    const points = [];
                    const x = (i * step) - (size / 2);
                    
                    for (let j = 0; j <= resolution; j++) {
                        const z = (j * step) - (size / 2);
                        points.push(x, heightMap[i][j], z);
                    }
                    
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
                    const line = new THREE.Line(geometry, linesMaterial);
                    linesGroup.add(line);
                }
                
                // Create vertical lines
                for (let j = 0; j <= resolution; j++) {
                    const geometry = new THREE.BufferGeometry();
                    const points = [];
                    const z = (j * step) - (size / 2);
                    
                    for (let i = 0; i <= resolution; i++) {
                        const x = (i * step) - (size / 2);
                        points.push(x, heightMap[i][j], z);
                    }
                    
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
                    const line = new THREE.Line(geometry, linesMaterial);
                    linesGroup.add(line);
                }
                
                return linesGroup;
            }
            
            function animate() {
                animationFrameId = requestAnimationFrame(animate);
                time += CONFIG.artifacts.hankies.animationSpeed;
                
                updatePerformanceInfo();
                
                // Clear previous groups
                mainGroup.children.forEach(child => {
                    if (child instanceof THREE.Group) {
                        child.children.forEach(line => {
                            if (line.geometry) line.geometry.dispose();
                            if (line.material) line.material.dispose();
                        });
                        mainGroup.remove(child);
                    }
                });
                
                // Create new interference fields
                const sources1 = createWaveSources(time, 1.5);
                const field1 = createInterferenceField(sources1, 1.5 * 4, CONFIG.artifacts.hankies.resolution, time);
                mainGroup.add(field1);
                
                const sources2 = createWaveSources(time + 0.33, 0.8);
                const field2 = createInterferenceField(sources2, 0.8 * 4, CONFIG.artifacts.hankies.resolution, time + 0.33);
                field2.position.set(0, 1.5, 0);
                field2.rotation.set(Math.PI/6, 0, Math.PI/4);
                mainGroup.add(field2);
                
                mainGroup.rotation.y = Math.sin(time * 0.3) * 0.2;
                mainGroup.rotation.x = Math.cos(time * 0.2) * 0.1;
                
                renderer.render(scene, camera);
            }
            
            animate();
            
            // Store for cleanup
            threeScenes['artifact-1'] = {
                cleanup: () => enhancedCleanup(scene, renderer, container, animationFrameId)
            };
        }

        // Artifact 2: Enhanced AsciiBinaryFlow
        function initAsciiBinaryFlow() {
            const container = document.querySelector('#artifact-2 .ascii-container');
            if (container.dataset.initialized) return;
            container.dataset.initialized = 'true';
            
            let width = CONFIG.artifacts.ascii.width;
            let height = CONFIG.artifacts.ascii.height;
            let grid = [];
            let time = 0;
            let animationFrameId;
            
            function initGrid() {
                grid = [];
                for (let y = 0; y < height; y++) {
                    let row = [];
                    for (let x = 0; x < width; x++) {
                        row.push(' ');
                    }
                    grid.push(row);
                }
            }
            
            function render() {
                let html = '';
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        html += grid[y][x];
                    }
                    html += '<br>';
                }
                container.innerHTML = html;
            }
            
            function update() {
                initGrid();
                
                const blockSize = Math.floor(width * 0.46);
                const blockX = Math.floor(width / 2 - blockSize / 2);
                const blockY = Math.floor(height / 2 - blockSize / 2);
                const t = time * 0.005;
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        if (x >= blockX && x < blockX + blockSize && 
                            y >= blockY && y < blockY + blockSize) {
                            const innerDist = Math.min(
                                x - blockX, 
                                blockX + blockSize - x,
                                y - blockY,
                                blockY + blockSize - y
                            );
                            
                            const erosion = time * 0.0067;
                            if (innerDist > erosion) {
                                grid[y][x] = '1';
                            } else {
                                grid[y][x] = Math.random() > 0.8 ? '1' : '0';
                            }
                        } else {
                            const dx = x - width / 2;
                            const dy = y - height / 2;
                            const angle = Math.atan2(dy, dx);
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            const wave = Math.sin(dist * 0.2 - t + angle * 1.5);
                            const flow = Math.sin(x * 0.08 + y * 0.04 + t * 0.4);
                            
                            if (flow + wave > 0.4) {
                                grid[y][x] = '0';
                            } else if (flow + wave < -0.4) {
                                grid[y][x] = '~';
                            }
                        }
                    }
                }
                
                // Add cracks
                for (let i = 0; i < 5; i++) {
                    const crackX = blockX + Math.floor(Math.random() * blockSize);
                    const crackY = blockY + Math.floor(Math.random() * blockSize);
                    const length = Math.floor(Math.random() * 10) + 5;
                    let cx = Math.floor(crackX);
                    let cy = Math.floor(crackY);
                    
                    for (let j = 0; j < length; j++) {
                        if (cx >= 0 && cx < width && cy >= 0 && cy < height) {
                            grid[cy][cx] = '0';
                        }
                        cx += Math.floor(Math.random() * 3) - 1;
                        cy += Math.floor(Math.random() * 3) - 1;
                    }
                }
                
                time++;
            }
            
            function animate() {
                update();
                render();
                updatePerformanceInfo();
                animationFrameId = requestAnimationFrame(animate);
            }
            
            initGrid();
            animate();
            
            // Store for cleanup
            threeScenes['artifact-2'] = {
                cleanup: () => {
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    container.innerHTML = '';
                    container.dataset.initialized = '';
                }
            };
        }

        // Artifact 3: Enhanced ParticleVessel
        function initParticleVessel() {
            const container = document.getElementById('artifact-3');
            if (container.hasChildNodes()) return;
            
            let scene, camera, renderer, animationFrameId;
            const count = CONFIG.artifacts.particles.count;
            
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ 
                antialias: !window.matchMedia('(max-width: 768px)').matches,
                powerPreference: "high-performance"
            });
            
            renderer.setSize(width, height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(currentTheme === 'dark' ? 0x1a1a1a : 0xF0EEE6);
            container.appendChild(renderer.domElement);
            
            camera.position.z = 5;
            
            const particleMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    opacity: { value: CONFIG.artifacts.particles.opacity }
                },
                vertexShader: `
                    uniform float time;
                    attribute float size;
                    attribute vec3 customColor;
                    varying vec3 vColor;
                    
                    void main() {
                        vColor = customColor;
                        vec3 pos = position;
                        
                        float radius = length(pos.xz);
                        float angle = atan(pos.z, pos.x);
                        float height = pos.y;
                        
                        float vessel = smoothstep(0.3, 0.7, radius) * smoothstep(1.0, 0.7, radius);
                        
                        angle += time * 0.08;
                        
                        float space = sin(time * 0.3 + radius * 3.0) * 0.1;
                        
                        float newRadius = (radius + space) * vessel;
                        
                        vec3 newPos;
                        newPos.x = cos(angle) * newRadius;
                        newPos.z = sin(angle) * newRadius;
                        newPos.y = height * vessel - 1.2;
                        
                        newPos *= 2.75;
                        
                        vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);
                        gl_PointSize = size * (128.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform float opacity;
                    varying vec3 vColor;
                    void main() {
                        vec2 center = gl_PointCoord - vec2(0.5);
                        float dist = dot(center, center);
                        
                        if (dist > 0.25) discard;
                        
                        float alpha = (1.0 - smoothstep(0.2025, 0.25, dist)) * opacity;
                        gl_FragColor = vec4(vColor, alpha);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.NormalBlending
            });
            
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            
            let i3 = 0;
            for (let i = 0; i < count; i++) {
                const t = i / count;
                const radius = Math.pow(t, 0.5);
                const angle = t * Math.PI * 40;
                
                const vesselHeight = Math.sin(t * Math.PI) * 1.8;
                
                const randRadius = radius + (Math.random() - 0.5) * 0.05;
                const randAngle = angle + (Math.random() - 0.5) * 0.1;
                
                positions[i3] = Math.cos(randAngle) * randRadius;
                positions[i3 + 1] = vesselHeight;
                positions[i3 + 2] = Math.sin(randAngle) * randRadius;

                const shade = currentTheme === 'dark' ? 
                    (0.8 + Math.sqrt(radius) * 0.2 + Math.random() * 0.1) :
                    (0.1 + Math.sqrt(radius) * 0.1 + Math.random() * 0.02);
                colors[i3] = shade;
                colors[i3 + 1] = shade;
                colors[i3 + 2] = shade;

                sizes[i] = (1.0 - Math.abs(vesselHeight * 0.5)) * 0.2 + 0.1;
                
                i3 += 3;
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const points = new THREE.Points(geometry, particleMaterial);
            scene.add(points);
            
            const clock = new THREE.Clock();
            
            function animate() {
                animationFrameId = requestAnimationFrame(animate);
                
                const time = clock.getElapsedTime();
                particleMaterial.uniforms.time.value = time;
                
                updatePerformanceInfo();
                renderer.render(scene, camera);
            }
            
            animate();
            
            threeScenes['artifact-3'] = {
                cleanup: () => enhancedCleanup(scene, renderer, container, animationFrameId)
            };
        }

        // Artifact 4: Enhanced Metamorphosis
        function initMetamorphosis() {
            const canvas = document.querySelector('#artifact-4 canvas');
            if (canvas.dataset.initialized) return;
            canvas.dataset.initialized = 'true';
            
            const ctx = canvas.getContext('2d', { willReadFrequently: false });
            const width = canvas.width;
            const height = canvas.height;
            
            let animationFrameId;
            let time = 2000;
            
            const numLines = CONFIG.artifacts.metamorphosis.numLines;
            const lineSegments = CONFIG.artifacts.metamorphosis.lineSegments;
            const lineAlpha = 0.5;
            const lineWidth = 0.6;
            
            const forms = [
                // Form 1: Draped cloth-like shape
                (u, v, t) => {
                    const theta = u * Math.PI * 2;
                    const phi = v * Math.PI;
                    
                    let r = 120 + 30 * Math.sin(phi * 4 + theta * 2);
                    r += 20 * Math.sin(phi * 6) * Math.cos(theta * 3);
                    
                    let x = r * Math.sin(phi) * Math.cos(theta);
                    let y = r * Math.sin(phi) * Math.sin(theta);
                    let z = r * Math.cos(phi) + 20 * Math.sin(theta * 5 + phi * 3);
                    
                    return { x, y, z };
                },
                
                // Form 2: More angular folded shape
                (u, v, t) => {
                    const theta = u * Math.PI * 2;
                    const phi = v * Math.PI;
                    
                    let r = 150 + 20 * Math.cos(phi * 8);
                    r *= 0.8 + 0.2 * Math.abs(Math.cos(theta * 2));
                    
                    let x = r * Math.sin(phi) * Math.cos(theta);
                    let y = r * Math.sin(phi) * Math.sin(theta);
                    let z = r * Math.cos(phi) * (0.8 + 0.3 * Math.sin(theta * 4));
                    
                    return { x, y, z };
                },
                
                // Form 3: Organic bulbous shape
                (u, v, t) => {
                    const theta = u * Math.PI * 2;
                    const phi = v * Math.PI;
                    
                    let r = 120;
                    r += 50 * Math.sin(phi * 3) * Math.sin(theta * 2.5);
                    r += 30 * Math.cos(phi * 5 + theta);
                    
                    let x = r * Math.sin(phi) * Math.cos(theta);
                    let y = r * Math.sin(phi) * Math.sin(theta);
                    let z = r * Math.cos(phi);
                    
                    const hollow = Math.max(0, Math.sin(phi * 2 + theta * 3) - 0.7);
                    r *= 1 - hollow * 0.8;
                    
                    return { x, y, z };
                }
            ];
            
            function interpolateForms(formA, formB, u, v, t, blend) {
                const pointA = formA(u, v, t);
                const pointB = formB(u, v, t);
                
                return {
                    x: pointA.x * (1 - blend) + pointB.x * blend,
                    y: pointA.y * (1 - blend) + pointB.y * blend,
                    z: pointA.z * (1 - blend) + pointB.z * blend
                };
            }
            
            function getCurrentForm(u, v, t) {
                const totalForms = forms.length;
                const cycleTime = 600;
                const position = (t % (cycleTime * totalForms)) / cycleTime;
                const formIndex = Math.floor(position);
                const nextFormIndex = (formIndex + 1) % totalForms;
                
                let rawBlend = position - formIndex;
                const pauseTime = 0;
                const transitionTime = 1 - (pauseTime * 2);
                
                let blend;
                if (rawBlend < pauseTime) {
                    blend = 0;
                } else if (rawBlend > (1 - pauseTime)) {
                    blend = 1;
                } else {
                    const normalizedTime = (rawBlend - pauseTime) / transitionTime;
                    blend = normalizedTime < 0.5
                        ? 4 * normalizedTime * normalizedTime * normalizedTime
                        : 1 - Math.pow(-2 * normalizedTime + 2, 3) / 2;
                }
                
                return interpolateForms(
                    forms[formIndex], 
                    forms[nextFormIndex], 
                    u, v, t, blend
                );
            }
            
            function animate() {
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = currentTheme === 'dark' ? '#1a1a1a' : '#F0EEE6';
                ctx.fillRect(0, 0, width, height);
                
                const rotateX = Math.sin(time * 0.00025) * 0.5;
                const rotateY = Math.cos(time * 0.00025 * 0.7) * 0.3;
                const rotateZ = time * 0.00025 * 0.1;
                
                // Draw horizontal contour lines
                for (let i = 0; i < numLines; i++) {
                    const v = i / (numLines - 1);
                    
                    ctx.beginPath();
                    const strokeColor = currentTheme === 'dark' ? 'rgba(255, 255, 255, 0.5)' : 'rgba(51, 51, 51, 0.5)';
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = lineWidth;
                    
                    let lastPointVisible = false;
                    
                    for (let j = 0; j <= lineSegments; j++) {
                        const u = j / lineSegments;
                        
                        const point = getCurrentForm(u, v, time);
                        
                        const rotatedX = point.x * Math.cos(rotateZ) - point.y * Math.sin(rotateZ);
                        const rotatedY = point.x * Math.sin(rotateZ) + point.y * Math.cos(rotateZ);
                        const rotatedZ = point.z;
                        
                        const scale = 1.5 + rotatedZ * 0.001;
                        const projX = width / 2 + rotatedX * scale;
                        const projY = height / 2 + rotatedY * scale;
                        
                        const pointVisible = rotatedZ > -50;
                        
                        if (j === 0) {
                            if (pointVisible) {
                                ctx.moveTo(projX, projY);
                                lastPointVisible = true;
                            }
                        } else {
                            if (pointVisible && lastPointVisible) {
                                ctx.lineTo(projX, projY);
                            } else if (pointVisible && !lastPointVisible) {
                                ctx.moveTo(projX, projY);
                            }
                        }
                        
                        lastPointVisible = pointVisible;
                    }
                    
                    ctx.stroke();
                }
                
                // Draw vertical contour lines
                for (let i = 0; i < numLines * 0.3; i++) {
                    const u = i / (numLines * 0.3 - 1);
                    
                    ctx.beginPath();
                    const strokeColor = currentTheme === 'dark' ? 'rgba(255, 255, 255, 0.35)' : 'rgba(51, 51, 51, 0.35)';
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = lineWidth * 0.7;
                    
                    let lastPointVisible = false;
                    
                    for (let j = 0; j <= lineSegments * 0.5; j++) {
                        const v = j / (lineSegments * 0.5);
                        
                        const point = getCurrentForm(u, v, time);
                        
                        const rotatedX = point.x * Math.cos(rotateZ) - point.y * Math.sin(rotateZ);
                        const rotatedY = point.x * Math.sin(rotateZ) + point.y * Math.cos(rotateZ);
                        const rotatedZ = point.z;
                        
                        const scale = 1.5 + rotatedZ * 0.001;
                        const projX = width / 2 + rotatedX * scale;
                        const projY = height / 2 + rotatedY * scale;
                        
                        const pointVisible = rotatedZ > -50;
                        
                        if (j === 0) {
                            if (pointVisible) {
                                ctx.moveTo(projX, projY);
                                lastPointVisible = true;
                            }
                        } else {
                            if (pointVisible && lastPointVisible) {
                                ctx.lineTo(projX, projY);
                            } else if (pointVisible && !lastPointVisible) {
                                ctx.moveTo(projX, projY);
                            }
                        }
                        
                        lastPointVisible = pointVisible;
                    }
                    
                    ctx.stroke();
                }
                
                time += 0.5;
                updatePerformanceInfo();
                animationFrameId = requestAnimationFrame(animate);
            }
            
            animate();
            
            threeScenes['artifact-4'] = {
                cleanup: () => {
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    ctx.clearRect(0, 0, width, height);
                    canvas.dataset.initialized = '';
                }
            };
        }

        // Artifact 5: Enhanced LayeredSineWaves
        function initLayeredSineWaves() {
            const canvas = document.querySelector('#artifact-5 canvas');
            if (canvas.dataset.initialized) return;
            canvas.dataset.initialized = 'true';
            
            const ctx = canvas.getContext('2d', { willReadFrequently: false });
            const width = canvas.width;
            const height = canvas.height;
            
            let animationId;
            let time = 0;
            
            const layers = CONFIG.artifacts.sineWaves.layers;
            const points = CONFIG.artifacts.sineWaves.points;
            const waveAmplitude = 40;
            
            function draw() {
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = currentTheme === 'dark' ? '#1a1a1a' : '#F0EEE6';
                ctx.fillRect(0, 0, width, height);
                
                time += 0.01;
                
                // Draw each layer
                for (let layer = 0; layer < layers; layer++) {
                    const layerPosition = (layer / layers) * height * 0.8 + height * 0.1;
                    const layerFrequency = 0.5 + layer * 0.03;
                    const layerPhase = time * 0.2 + layer * 0.05;
                    const layerAmplitude = waveAmplitude * (0.5 + 0.5 * Math.sin(layer * 0.1 + time * 0.3));
                    
                    const baseOpacity = 0.2 + 0.6 * Math.pow(Math.sin((layer / layers) * Math.PI), 2);
                    const timeEffect = 0.2 * Math.sin(time * 0.4 + layer * 0.1);
                    const opacity = Math.min(0.9, Math.max(0.1, baseOpacity + timeEffect));
                    
                    ctx.beginPath();
                    const strokeColor = currentTheme === 'dark' ? 
                        `rgba(255, 255, 255, ${opacity})` : 
                        `rgba(50, 50, 50, ${opacity})`;
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = 0.6;
                    
                    for (let i = 0; i <= points; i++) {
                        const x = (i / points) * width;
                        
                        let y = layerPosition;
                        
                        y += layerAmplitude * Math.sin(x * 0.01 * layerFrequency + layerPhase);
                        y += layerAmplitude * 0.3 * Math.sin(x * 0.02 * layerFrequency + layerPhase * 1.5);
                        y += layerAmplitude * 0.2 * Math.sin(x * 0.04 * layerFrequency - layerPhase * 0.7);
                        y += layerAmplitude * 0.1 * Math.sin(x * 0.08 * layerFrequency + layerPhase * 2.3);
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    
                    ctx.stroke();
                }
                
                // Draw connecting lines
                for (let i = 0; i < width; i += 20) {
                    if (Math.random() < 0.4) {
                        ctx.beginPath();
                        
                        const opacity = 0.1 + 0.2 * Math.sin(i * 0.05 + time);
                        const strokeColor = currentTheme === 'dark' ? 
                            `rgba(255, 255, 255, ${opacity})` : 
                            `rgba(50, 50, 50, ${opacity})`;
                        ctx.strokeStyle = strokeColor;
                        ctx.lineWidth = 0.3;
                        
                        const startY = height * 0.1 + Math.random() * height * 0.2;
                        const endY = height * 0.7 + Math.random() * height * 0.2;
                        
                        ctx.moveTo(i, startY);
                        ctx.lineTo(i, endY);
                        ctx.stroke();
                    }
                }
                
                updatePerformanceInfo();
                animationId = requestAnimationFrame(draw);
            }
            
            draw();
            
            threeScenes['artifact-5'] = {
                cleanup: () => {
                    if (animationId) cancelAnimationFrame(animationId);
                    ctx.clearRect(0, 0, width, height);
                    canvas.dataset.initialized = '';
                }
            };
        }

        // Artifact switching
        function changeArtifact() {
            const currentElement = document.querySelector('.artifact.active');
            currentElement.classList.remove('active');
            
            // Clean up current artifact
            if (threeScenes[`artifact-${currentArtifact + 1}`] && 
                threeScenes[`artifact-${currentArtifact + 1}`].cleanup) {
                threeScenes[`artifact-${currentArtifact + 1}`].cleanup();
            }
            
            currentArtifact = (currentArtifact + 1) % artifacts.length;
            
            const nextElement = document.getElementById(`artifact-${currentArtifact + 1}`);
            nextElement.classList.add('active');
            
            // Initialize the new artifact
            setTimeout(() => {
                artifacts[currentArtifact]();
            }, 100);
        }

        // Smooth scrolling for navigation links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const target = document.getElementById(targetId);
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // Simple working project toggle function (KEEP THIS WORKING)
        function toggleProject(element) {
            // Close all other projects
            document.querySelectorAll('.project-item').forEach(item => {
                if (item !== element) {
                    item.classList.remove('open');
                }
            });
            
            // Toggle current project
            element.classList.toggle('open');
        }

        // Initialize everything
        window.initialize = function initialize() {
            // Hide loading screen
            const loadingScreen = document.getElementById('loadingScreen');
            setTimeout(() => {
                loadingScreen.classList.add('hidden');
            }, 1000);

            // Initialize artifacts
            initializeArtifacts();
            
            
            // Initialize enhanced mobile accessibility
            if (typeof MobileAccessibilityManager !== 'undefined') {
                window.accessibilityManager = new MobileAccessibilityManager();
                console.log('‚úÖ Mobile accessibility manager initialized');
            }

            // Add click effects to buttons
            document.querySelectorAll('.cta-button').forEach(button => {
                button.addEventListener('click', function() {
                    this.style.transform = 'scale(0.95)';
                    setTimeout(() => {
                        this.style.transform = 'translateY(-2px)';
                    }, 100);
                });
            });
        }

        // Enhanced resize handler with debouncing
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // Update configuration for new screen size
                CONFIG.artifacts.particles.count = window.innerWidth < 768 ? 15000 : 45000;
                CONFIG.artifacts.hankies.resolution = window.innerWidth < 768 ? 16 : 32;
                CONFIG.artifacts.ascii.width = window.innerWidth < 768 ? 45 : 65;
                CONFIG.artifacts.ascii.height = window.innerWidth < 768 ? 45 : 65;
                CONFIG.artifacts.metamorphosis.numLines = window.innerWidth < 768 ? 60 : 120;
                CONFIG.artifacts.metamorphosis.lineSegments = window.innerWidth < 768 ? 90 : 180;
                CONFIG.artifacts.sineWaves.layers = window.innerWidth < 768 ? 40 : 80;
                CONFIG.artifacts.sineWaves.points = window.innerWidth < 768 ? 100 : 200;
                
                // Reinitialize current Three.js artifact on resize
                if (currentArtifact === 0 || currentArtifact === 2) {
                    if (threeScenes[`artifact-${currentArtifact + 1}`] && 
                        threeScenes[`artifact-${currentArtifact + 1}`].cleanup) {
                        threeScenes[`artifact-${currentArtifact + 1}`].cleanup();
                    }
                    setTimeout(() => {
                        artifacts[currentArtifact]();
                    }, 100);
                }
            }, 250);
        });

        // Enhanced Touch Gesture System for Mobile
        class TouchGestureManager {
            constructor() {
                this.startX = 0;
                this.startY = 0;
                this.startTime = 0;
                this.threshold = 50; // minimum swipe distance
                this.timeThreshold = 300; // maximum swipe time
                this.setupGestures();
                this.showMobileHints();
            }
            
            setupGestures() {
                const heroContainer = document.querySelector('.hero-container');
                let isDragging = false;
                
                heroContainer.addEventListener('touchstart', (e) => {
                    // Handle title/magic button taps
                    if (e.target.classList.contains('glitch-title') || e.target.classList.contains('spark-magic')) {
                        e.preventDefault();
                        changeEverything();
                        return;
                    }
                    
                    // Start gesture tracking
                    this.startX = e.touches[0].clientX;
                    this.startY = e.touches[0].clientY;
                    this.startTime = Date.now();
                    isDragging = false;
                }, { passive: false });
                
                heroContainer.addEventListener('touchmove', (e) => {
                    if (!this.startX || !this.startY) return;
                    
                    const currentX = e.touches[0].clientX;
                    const deltaX = Math.abs(currentX - this.startX);
                    
                    // Detect if user is actively swiping
                    if (deltaX > 10) {
                        isDragging = true;
                        // Add visual feedback during swipe
                        this.addSwipeVisualFeedback(currentX - this.startX);
                    }
                }, { passive: true });
                
                heroContainer.addEventListener('touchend', (e) => {
                    if (!this.startX || !this.startY) return;
                    
                    const endX = e.changedTouches[0].clientX;
                    const endY = e.changedTouches[0].clientY;
                    const endTime = Date.now();
                    
                    const deltaX = endX - this.startX;
                    const deltaY = endY - this.startY;
                    const deltaTime = endTime - this.startTime;
                    
                    // Remove any visual feedback
                    this.removeSwipeVisualFeedback();
                    
                    // Check if it's a valid swipe
                    if (Math.abs(deltaX) > Math.abs(deltaY) && 
                        Math.abs(deltaX) > this.threshold && 
                        deltaTime < this.timeThreshold &&
                        isDragging) {
                        
                        e.preventDefault();
                        
                        if (deltaX > 0) {
                            // Swipe right - previous artifact
                            this.previousArtifact();
                        } else {
                            // Swipe left - next artifact
                            this.nextArtifact();
                        }
                    }
                    
                    // Reset
                    this.startX = 0;
                    this.startY = 0;
                    this.startTime = 0;
                    isDragging = false;
                }, { passive: false });
            }
            
            nextArtifact() {
                if (!isTransitioning) {
                    changeEverything();
                    this.showSwipeSuccess('right');
                }
            }
            
            previousArtifact() {
                if (!isTransitioning) {
                    isTransitioning = true;
                    
                    // Cycle backwards through titles
                    currentTitleIndex = currentTitleIndex === 0 ? CONFIG.titles.length - 1 : currentTitleIndex - 1;
                    this.updateTitleText();
                    
                    // Cycle backwards through artifacts
                    setTimeout(() => {
                        const currentElement = document.querySelector('.artifact.active');
                        currentElement.classList.remove('active');
                        
                        if (threeScenes[`artifact-${currentArtifact + 1}`]?.cleanup) {
                            threeScenes[`artifact-${currentArtifact + 1}`].cleanup();
                        }
                        
                        currentArtifact = currentArtifact === 0 ? artifacts.length - 1 : currentArtifact - 1;
                        
                        const nextElement = document.getElementById(`artifact-${currentArtifact + 1}`);
                        nextElement.classList.add('active');
                        
                        setTimeout(() => {
                            artifacts[currentArtifact]();
                            isTransitioning = false;
                        }, 100);
                    }, CONFIG.transitions.delay);
                    
                    this.showSwipeSuccess('left');
                }
            }
            
            updateTitleText() {
                const titleElement = document.querySelector('.glitch-title');
                gsap.to(titleElement, {
                    duration: 1.2,
                    text: { value: CONFIG.titles[currentTitleIndex], delimiter: "" },
                    ease: "none"
                });
            }
            
            addSwipeVisualFeedback(deltaX) {
                const heroContainer = document.querySelector('.hero-container');
                const opacity = Math.min(Math.abs(deltaX) / 100, 0.3);
                
                if (deltaX > 0) {
                    heroContainer.style.background = `linear-gradient(90deg, rgba(102, 102, 102, ${opacity}) 0%, transparent 100%)`;
                } else {
                    heroContainer.style.background = `linear-gradient(-90deg, rgba(102, 102, 102, ${opacity}) 0%, transparent 100%)`;
                }
            }
            
            removeSwipeVisualFeedback() {
                const heroContainer = document.querySelector('.hero-container');
                heroContainer.style.background = '';
            }
            
            showSwipeSuccess(direction) {
                const indicator = document.createElement('div');
                indicator.style.cssText = `
                    position: fixed;
                    top: 50%;
                    ${direction === 'right' ? 'right: 20px;' : 'left: 20px;'}
                    transform: translateY(-50%);
                    background: rgba(102, 102, 102, 0.9);
                    color: white;
                    padding: 10px 15px;
                    border-radius: 25px;
                    font-size: 0.8rem;
                    z-index: 1002;
                    font-family: 'Roboto Mono', monospace;
                    animation: swipeSuccess 0.6s ease-out;
                `;
                indicator.textContent = direction === 'right' ? '‚Üê Previous' : 'Next ‚Üí';
                document.body.appendChild(indicator);
                
                setTimeout(() => indicator.remove(), 600);
            }
            
            showMobileHints() {
                if (window.innerWidth <= 768) {
                    const hintsHTML = `
                        <div class="mobile-hints" style="
                            position: absolute;
                            bottom: 100px;
                            left: 50%;
                            transform: translateX(-50%);
                            color: rgba(51, 51, 51, 0.6);
                            font-size: 0.8rem;
                            text-align: center;
                            z-index: 10;
                            pointer-events: none;
                            animation: fadeInOut 4s ease-in-out infinite;
                        ">
                            ‚Üê Swipe to explore ‚Üí<br>
                            <span style="font-size: 0.7rem;">Tap title to cycle</span>
                        </div>
                    `;
                    document.querySelector('.hero-content').insertAdjacentHTML('beforeend', hintsHTML);
                }
            }
        }
        
        // CSS animations for swipe feedback
        const swipeStyles = document.createElement('style');
        swipeStyles.textContent = `
            @keyframes swipeSuccess {
                0% { opacity: 0; transform: translateY(-50%) scale(0.8); }
                50% { opacity: 1; transform: translateY(-50%) scale(1.1); }
                100% { opacity: 0; transform: translateY(-50%) scale(1); }
            }
            
            @keyframes fadeInOut {
                0%, 100% { opacity: 0; }
                50% { opacity: 1; }
            }
            
            @media (max-width: 768px) {
                .mobile-hints {
                    display: block;
                }
            }
            
            @media (min-width: 769px) {
                .mobile-hints {
                    display: none;
                }
            }
        `;
        document.head.appendChild(swipeStyles);
        
        // Initialize gesture manager on mobile devices
        if (window.innerWidth <= 768 || 'ontouchstart' in window) {
            window.gestureManager = new TouchGestureManager();
        }


        // Accessibility: Focus management
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Tab') {
                // Allow normal tab navigation
                return;
            }
            if (e.key === ' ' || e.key === 'Enter') {
                const activeElement = document.activeElement;
                if (activeElement.classList.contains('glitch-title') || 
                    activeElement.classList.contains('spark-magic')) {
                    e.preventDefault();
                    changeEverything();
                }
            }
        });

        // Performance optimization: Pause animations when page is not visible
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Page is hidden, consider pausing heavy animations
                console.log('Page hidden - animations continue for demo purposes');
            } else {
                // Page is visible again
                console.log('Page visible - all animations active');
            }
        });

        // Error boundary for global errors
        window.addEventListener('error', (e) => {
            console.warn('Global error caught:', e.error);
            // Could implement fallback here
        });

        // Service worker registration (commented out for demo)
        /*
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js').catch(console.error);
        }
        */

        // Simplified initialization - removed old terminal experience system
        // Now using trait selector interface with backend integration
        
        // Chat functionality (keeping for future backend integration)
        let globalChatUI = null;
        let globalConversationManager = null;
        let chatInitialized = false;
        
        function ensureChatInitialized() {
            if (chatInitialized && globalChatUI && globalConversationManager) {
                return { chatUI: globalChatUI, conversationManager: globalConversationManager };
            }
            
            if (window.ConversationManager && window.ChatUI) {
                console.log('üîß Initializing global chat system...');
                globalChatUI = new ChatUI();
                globalConversationManager = new ConversationManager();
                
                globalChatUI.initialize();
                globalConversationManager.initialize(globalChatUI);
                globalConversationManager.loadStoredApiKey();
                
                chatInitialized = true;
                console.log('‚úÖ Global chat system initialized');
                
                return { chatUI: globalChatUI, conversationManager: globalConversationManager };
            }
            
            console.warn('‚ö†Ô∏è Chat classes not available yet');
            return null;
        }

        // Navigation handlers
        document.addEventListener('DOMContentLoaded', function() {
            // Meet Your El button handler (now goes to trait selector)
            const meetYourElBtn = document.getElementById('meetYourElBtn');
            if (meetYourElBtn) {
                meetYourElBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    // Scroll to trait selector section
                    const traitSection = document.getElementById('build-your-el');
                    if (traitSection) {
                        traitSection.scrollIntoView({ behavior: 'smooth' });
                    }
                });
            }
        });

        
        // Add swipe feedback animation
        const swipeStyle = document.createElement('style');
        swipeStyle.textContent = `
            @keyframes swipe-feedback {
                0% { transform: translateY(-50%) scale(0.5); opacity: 0; }
                50% { transform: translateY(-50%) scale(1.2); opacity: 1; }
                100% { transform: translateY(-50%) scale(1); opacity: 0; }
            }
            
            .mobile-hints .hint {
                margin: 2px 0;
                animation: fade-in-out 4s ease-in-out;
            }
            
            @keyframes fade-in-out {
                0%, 100% { opacity: 0; }
                20%, 80% { opacity: 0.6; }
            }
        `;
        document.head.appendChild(swipeStyle);
        
        // Chat circle functionality
        const chatCircle = document.createElement('div');
        chatCircle.className = 'chat-circle';
        chatCircle.innerHTML = `
            <svg viewBox="0 0 24 24" fill="currentColor">
                <path d="M20 2H4c-1.1 0-2 .9-2 2v12c0 1.1.9 2 2 2h4l4 4 4-4h4c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-2 12H6v-2h12v2zm0-3H6V9h12v2zm0-3H6V6h12v2z"/>
            </svg>
        `;
        
        chatCircle.addEventListener('click', () => {
            const chat = ensureChatInitialized();
            if (chat) {
                chat.chatUI.show();
            }
        });
        
        document.body.appendChild(chatCircle);
        
        // Chat circle styles
        const chatStyle = document.createElement('style');
        chatStyle.textContent = `
            .chat-circle {
                position: fixed;
                bottom: 30px;
                right: 30px;
                width: 60px;
                height: 60px;
                background: var(--accent-color);
                border-radius: 50%;
                display: flex;
                align-items: center;
                justify-content: center;
                cursor: pointer;
                z-index: 1000;
                transition: all 0.3s ease;
                color: white;
                box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
            }
            
            .chat-circle:hover {
                transform: scale(1.1);
                box-shadow: 0 6px 24px rgba(0, 0, 0, 0.3);
            }
            
            .chat-circle svg {
                width: 24px;
                height: 24px;
            }
            
            .chat-circle::before {
                content: '';
                position: absolute;
                top: -2px;
                left: -2px;
                right: -2px;
                bottom: -2px;
                border-radius: 50%;
                background: var(--accent-color);
                opacity: 0.3;
                animation: pulse-ring 2s infinite;
            }
            
            @keyframes pulse-ring {
                0% {
                    transform: scale(0.8);
                    opacity: 0.8;
                }
                50% {
                    transform: scale(1.2);
                    opacity: 0.4;
                }
                100% {
                    transform: scale(1.5);
                    opacity: 0;
                }
            }
            
            /* Mobile optimizations */
            @media (max-width: 768px) {
                .chat-circle {
                    bottom: 20px;
                    right: 20px;
                    width: 56px;
                    height: 56px;
                }
                
                .chat-circle svg {
                    width: 20px;
                    height: 20px;
                }
            }
        `;
        document.head.appendChild(chatStyle);
    </script>    <!-- Main Application JavaScript -->
    <script src="js/main.js"></script>
    <script src="js/trait-selector.js"></script>
    
    <script>
        // Initialize the application after DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            window.initialize();
        });
    </script>
</body>
</html>