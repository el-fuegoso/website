<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elliot Lee - Portfolio</title>
    <meta name="description" content="Interactive portfolio showcasing generative art and creative coding">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/Flip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/TextPlugin.min.js"></script>
    <link rel="stylesheet" href="css/conversation.css?v=4">
    <script src="js/conversation/claude-client.js?v=4"></script>
    <script src="js/conversation/avatar-generator.js?v=3"></script>
    <script src="js/conversation/chat-ui.js?v=5"></script>
    <script src="js/conversation/conversation-manager.js?v=4"></script>
    <script src="js/terminal-experience/DataCollector.js?v=3"></script>
    <script src="js/terminal-experience/AdvancedPersonalityAnalyzer.js?v=3"></script>
    <script src="js/terminal-experience/TemplateAvatarGenerator.js?v=3"></script>
    <script src="js/terminal-experience/ClaudeAvatarService.js?v=3"></script>
    <script src="js/terminal-experience/AvatarDisplay.js?v=3"></script>
    <script src="js/terminal-experience/CharacterTerminal.js?v=5"></script>
    <script src="js/terminal-experience/TerminalQuestionnaire.js?v=4"></script>
    <link rel="stylesheet" href="css/main.css">
    <link rel="stylesheet" href="css/trait-selector.css">

</head>
<body>
    <div class="loading-screen" id="loadingScreen">
        <div class="loader">Loading Experience...</div>
    </div>

    <nav class="nav-bar">
        <div class="nav-logo">
            EL
        </div>
        
        <div class="nav-center">
            <a href="#home" class="nav-item">HOME</a>
            <a href="#projects" class="nav-item">PROJECTS</a>
            <a href="#contact" class="nav-item">CONTACT</a>
        </div>
    </nav>

    <div class="hero-container" id="home">
        <!-- Artifact containers -->
        <div class="artifact-container">
            <!-- Artifact 1: HankiesInTheWind (Three.js interference patterns) -->
            <div class="artifact active" id="artifact-1"></div>
            
            <!-- Artifact 2: AsciiBinaryFlow -->
            <div class="artifact" id="artifact-2">
                <div class="ascii-container"></div>
            </div>
            
            <!-- Artifact 3: ParticleVessel (Three.js particles) -->
            <div class="artifact" id="artifact-3"></div>
            
            <!-- Artifact 4: Metamorphosis (Canvas 3D forms) -->
            <div class="artifact" id="artifact-4">
                <div class="canvas-container">
                    <canvas width="550" height="550"></canvas>
                </div>
            </div>
            
            <!-- Artifact 5: LayeredSineWaves (Canvas sine waves) -->
            <div class="artifact" id="artifact-5">
                <div class="canvas-container">
                    <canvas width="550" height="550"></canvas>
                </div>
            </div>
        </div>
        
        <div class="hero-content">
            <h1 class="glitch-title" 
                onclick="changeEverything()" 
                onkeydown="handleKeyPress(event)"
                role="button" 
                tabindex="0"
                aria-label="Click to cycle through titles and change background art">
                ELLIOT LEE
            </h1>
            
            <div class="spark-magic" 
                 onclick="changeEverything()"
                 onkeydown="handleKeyPress(event)"
                 role="button"
                 tabindex="0"
                 aria-label="Change experience">
                <span>[click me]</span>
            </div>
        </div>
    </div>

    <!-- Build Your El Section -->
    <section class="build-your-el-section" id="build-your-el">
        <div class="build-el-container">
            <!-- Section Header -->
            <div class="build-el-header">
                <h2 class="build-el-title">Create</h2>
                <p class="build-el-subtitle">Thinking about El? Find the version that works best for you!</p>
            </div>
            
            <!-- New Trait Selector Interface -->
            <div class="trait-selector-container">
                <div class="trait-selector-grid">
                    <!-- Left Panel - Trait Selection with flip capability -->
                    <div class="trait-panel" id="traitPanel">
                        <div class="trait-panel-inner">
                            <!-- Front side - Original trait selection -->
                            <div class="trait-panel-front">
                                <!-- Trait Categories Section -->
                                <div class="trait-categories">
                                    <div class="category-header">
                                        <span class="category-title">Select Traits</span>
                                    </div>

                                    <div class="trait-row">
                                        <span class="trait-label">
                                            <span class="trait-icon">⚡</span>
                                            High Energy
                                        </span>
                                        <div class="trait-toggle active" data-trait="energy"></div>
                                    </div>

                                    <div class="trait-row">
                                        <span class="trait-label">
                                            <span class="trait-icon">🔬</span>
                                            Analytical
                                        </span>
                                        <div class="trait-toggle" data-trait="analytical"></div>
                                    </div>

                                    <div class="trait-row">
                                        <span class="trait-label">
                                            <span class="trait-icon">🎯</span>
                                            Intense Focus
                                        </span>
                                        <div class="trait-toggle" data-trait="intensity"></div>
                                    </div>

                                    <div class="trait-row">
                                        <span class="trait-label">
                                            <span class="trait-icon">🚀</span>
                                            Innovation
                                        </span>
                                        <div class="trait-toggle" data-trait="innovation"></div>
                                    </div>

                                    <div class="selection-display">
                                        <div class="selection-label">Active Traits <span class="selection-text">analysing...</span></div>
                                        <div class="selection-count">2/18</div>
                                    </div>

                                    <div class="generation-display">
                                        <div class="soundbar-container" id="soundbarContainer">
                                            <div class="soundbar" data-trait="energy" title="High Energy"></div>
                                            <div class="soundbar" data-trait="analytical" title="Analytical"></div>
                                            <div class="soundbar" data-trait="intensity" title="Intense Focus"></div>
                                            <div class="soundbar" data-trait="innovation" title="Innovation"></div>
                                            <div class="soundbar" data-trait="technical" title="Technical"></div>
                                            <div class="soundbar" data-trait="creativity" title="Creative"></div>
                                            <div class="soundbar" data-trait="leadership" title="Leadership"></div>
                                            <div class="soundbar" data-trait="collaborative" title="Collaborative"></div>
                                            <div class="soundbar" data-trait="adventure" title="Adventure"></div>
                                            <div class="soundbar" data-trait="mystery" title="Mystery"></div>
                                            <div class="soundbar" data-trait="discipline" title="Discipline"></div>
                                            <div class="soundbar" data-trait="curiosity" title="Curiosity"></div>
                                            <div class="soundbar" data-trait="hustle" title="Hustle"></div>
                                            <div class="soundbar" data-trait="speed" title="Speed"></div>
                                            <div class="soundbar" data-trait="experimental" title="Experimental"></div>
                                            <div class="soundbar" data-trait="paranoia" title="Paranoia"></div>
                                            <div class="soundbar" data-trait="procrastination" title="Procrastination"></div>
                                            <div class="soundbar" data-trait="futuristic" title="Futuristic"></div>
                                        </div>
                                        <div class="soundbar-info">
                                            <span class="trait-count" id="traitCount">2 traits</span>
                                            <span class="possibilities-label">∞ combinations</span>
                                        </div>
                                    </div>

                                    <div class="trait-options">
                                        <div class="trait-option" data-dimension="technical" data-tooltip="Loves coding & engineering">🔧</div>
                                        <div class="trait-option" data-dimension="creativity" data-tooltip="Creative & artistic">🎨</div>
                                        <div class="trait-option selected" data-dimension="energy" data-tooltip="High energy & dynamic">⚡</div>
                                        <div class="trait-option" data-dimension="leadership" data-tooltip="Natural leader">👑</div>
                                        <div class="trait-option" data-dimension="analytical" data-tooltip="Data-driven & logical">🔬</div>
                                        <div class="trait-option selected" data-dimension="collaborative" data-tooltip="Team player">🤝</div>
                                        
                                        <div class="trait-option" data-dimension="adventure" data-tooltip="Seeks bold challenges">🏴‍☠️</div>
                                        <div class="trait-option" data-dimension="mystery" data-tooltip="Investigates complex problems">🕵️</div>
                                        <div class="trait-option" data-dimension="discipline" data-tooltip="Systematic & consistent">💪</div>
                                        <div class="trait-option" data-dimension="innovation" data-tooltip="Revolutionary thinker">🚀</div>
                                        <div class="trait-option" data-dimension="curiosity" data-tooltip="Always learning">🤔</div>
                                        <div class="trait-option" data-dimension="hustle" data-tooltip="Relentlessly driven">🔥</div>
                                        
                                        <div class="trait-option" data-dimension="speed" data-tooltip="Fast-paced execution">💨</div>
                                        <div class="trait-option" data-dimension="intensity" data-tooltip="Maximum focus">⚡</div>
                                        <div class="trait-option" data-dimension="experimental" data-tooltip="Tests weird ideas">🧪</div>
                                        <div class="trait-option" data-dimension="paranoia" data-tooltip="Security conscious">👀</div>
                                        <div class="trait-option" data-dimension="procrastination" data-tooltip="Does it later">😴</div>
                                        <div class="trait-option" data-dimension="futuristic" data-tooltip="AI & automation lover">🤖</div>
                                    </div>

                                    <!-- Advanced Section -->
                                    <div class="advanced-section">
                                        <button class="advanced-toggle" id="advancedToggle">
                                            ▶ Advanced
                                        </button>
                                        <div class="advanced-content" id="advancedContent">
                                            <div style="margin-bottom: 8px;">
                                                <strong>Are you a pro?</strong> Have a go at doing it the hard way
                                            </div>
                                            <button class="advanced-button" id="terminalModeBtn">
                                                Enter Terminal Mode
                                            </button>
                                        </div>
                                    </div>
                                </div>

                                <!-- Action Buttons -->
                                <div class="action-grid">
                                    <button class="action-button" id="generateBtn">
                                        Generate
                                        <div class="button-subtitle">G</div>
                                    </button>
                                    <button class="action-button" id="randomBtn">
                                        Random
                                        <div class="button-subtitle">R</div>
                                    </button>
                                    <button class="action-button secondary" id="resetBtn">
                                        Reset
                                        <div class="button-subtitle">ESC</div>
                                    </button>
                                    <button class="action-button secondary" id="saveBtn">
                                        Save
                                        <div class="button-subtitle">S</div>
                                    </button>
                                </div>
                            </div>

                            <!-- Back side - Terminal interface -->
                            <div class="trait-panel-back">
                                <div class="terminal-container">
                                    <div class="terminal-titlebar">
                                        <div class="terminal-buttons">
                                            <button class="terminal-button close" id="backToTraits"></button>
                                            <button class="terminal-button minimize"></button>
                                            <button class="terminal-button maximize"></button>
                                        </div>
                                        <div class="terminal-title">elliot@terminal — claude-code — 80×24</div>
                                    </div>
                                    <div class="terminal-header">
                                        Elliot's Terminal Experience
                                    </div>
                                    <div class="terminal-output" id="terminalOutput">
                                        <div class="terminal-ai">Buenas días Choom</div>
                                        <div class="terminal-ai"></div>
                                        <div class="terminal-ai">You've got a couple different ways to use this terminal</div>
                                        <div class="terminal-ai">To go through a question flow type: quest</div>
                                        <div class="terminal-ai">You can just ramble here about whatever you like and I'll</div>
                                        <div class="terminal-ai">find an El that works for you</div>
                                        <div class="terminal-ai">You can also copy and paste a JD</div>
                                        <div class="terminal-ai"></div>
                                        <div class="terminal-prompt">elliot@terminal ~ % _</div>
                                    </div>
                                    <div class="terminal-input-container">
                                        <span class="terminal-prompt-symbol">%</span>
                                        <input type="text" class="terminal-input" id="terminalInput" placeholder="Type 'quest' for guided flow or just start talking..." />
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Right Panel - Elliot Display -->
                    <div class="elliot-display">
                        <div class="helix-container">
                            <!-- Personality Matrix Label -->
                            <div class="matrix-label">Personality Matrix</div>
                            
                            <!-- Water ASCII Visualization - grace without force, finding natural paths -->
                            <div class="water-ascii" id="waterAscii">
                                <pre id="asciiContent"></pre>
                            </div>
                            
                            <div class="generation-path" id="generationPath"></div>
                            
                            <!-- Avatar Generation Label -->
                            <div class="avatar-label">[ Avatar Generation Space ]</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <section class="projects-section" id="projects">
        <div class="projects-header">
            <h2 class="projects-title">Projects</h2>
        </div>

        <ul class="projects-list">
            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">The Daoist Sage AI Agent <span class="project-status status-case-study">Case Study</span></span>
                    <span class="project-year">2025</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>AI Development & RAG Systems</h3>
                                <p>A case study on grounding AI memory using a dedicated RAG (Retrieval-Augmented Generation) system to solve challenges of hallucination and unreliable memory in AI trading agents.</p>
                                <p>The core challenge emerged from developing an AI crypto trading agent where memory issues and hallucination severely limited reliability. AI hallucination causes confident generation of factually incorrect information, while fickle memory creates inability to recall crucial details from knowledge bases or maintain coherent context.</p>
                                <p>The solution involved building a Daoist Sage Agent using RAG as its foundational memory and accuracy mechanism. As Product Manager and Lead Developer, I handled the full process from ideation to conceptual deployment.</p>
                                <p>The future vision includes processing complex internal documentation and providing specialized, fact-checked assistance in regulated industries where precision and verifiability are crucial.</p>
                                <p><a href="https://github.com/el-fuegoso/daobot" class="project-link" target="_blank" rel="noopener noreferrer">▶ View Code</a></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/daobot/agent-interface.jpg')">Agent Interface</div>
                                <div class="project-image" style="background-image: url('./images/daobot/rag-architecture.jpg')">RAG Architecture</div>
                                <div class="project-image" style="background-image: url('./images/daobot/memory-system.jpg')">Memory System</div>
                                <div class="project-image" style="background-image: url('./images/daobot/testing-results.jpg')">Testing Results</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>

            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">Eliza Trading Agent <span class="project-status status-pivoted">Pivoted</span></span>
                    <span class="project-year">2025</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>AI-Powered Memecoin Trading</h3>
                                <p>An attempt to develop an AI-powered memecoin trading bot to capitalize on Solana's volatility while managing risk.</p>
                                <p>The approach involved training Mistral 7B on Pump.fun launch patterns combined with Twitter sentiment analysis. Integration with 3Commas API as a provider allowed testing of hybrid DEX/CEX strategy through paper trading on the 3Commas platform.</p>
                                <p>The outcome was clear: the system was inconsistent and kept hallucinating on the signals being fed to it. The project was pivoted due to inability to achieve reliable trading consistency.</p>
                                <p>This failure led to valuable insights about AI reliability in financial applications and directly informed the development of the Daoist Sage Agent with its focus on grounded memory systems.</p>
                                <p><em>Project documentation available upon request</em></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/eliza/eliza-banner.jpg')">Eliza Banner</div>
                                <div class="project-image" style="background-image: url('./images/eliza/trading-interface.jpg')">Trading Interface</div>
                                <div class="project-image" style="background-image: url('./images/eliza/performance-metrics.jpg')">Performance Metrics</div>
                                <div class="project-image" style="background-image: url('./images/eliza/lessons-learned.jpg')">Lessons Learned</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>

            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">Kaiawhina Auckland</span>
                    <span class="project-year">2023 – 2024</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>Activism & Social Justice</h3>
                                <p>In 2023, as global calls for a Free Palestine grew louder, I realized my skills and privilege needed redirecting. Joining Kaiawhina Auckland, I committed to honoring Māori sovereignty, supporting Palestinian freedom, and advancing climate justice.</p>
                                <p>The work involves weekly marshal duties for activations, disrupting "business as usual" at corporate complicity sites, and learning that actions matter more than hashtags. The experience taught crucial lessons: data is power (using Signal to track police or counter protestors movements at demonstrations), access is activism (always providing wheelchair routes and live captions), and joy is resistance (singing waiata at 5am blockades).</p>
                                <p>This work reinforced that technology doesn't exist in a vacuum and provided hands-on experience in using tech skills for social justice organizing.</p>
                                <p><a href="https://www.instagram.com/kaiawhina_tamaki/" class="project-link" target="_blank" rel="noopener noreferrer">▶ Learn About Kaiawhina</a></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/kaiawhina/demonstration-photography.jpg')">Demonstration Photography</div>
                                <div class="project-image" style="background-image: url('./images/kaiawhina/community-organizing.jpg')">Community Organizing</div>
                                <div class="project-image" style="background-image: url('./images/kaiawhina/marshall-training.jpg')">Marshall Training</div>
                                <div class="project-image" style="background-image: url('./images/kaiawhina/solidarity-actions.jpg')">Solidarity Actions</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>

            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">Drama School 202: The Illusion</span>
                    <span class="project-year">2023</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>Black Box Theatre Performance</h3>
                                <p>A reimagining of Tony Kushner's baroque meta-theatrical fantasy as a contemporary meditation on love, artifice, and the transformative power of storytelling under director Leo Gene Peters.</p>
                                <p>Our approach centered on staging the unreal by building a 1:1 cave to bring the audience into the world. We performed costume quick-changes in full view to highlight theatrical artifice and projected text fragments from Kushner's stage directions onto actors' bodies. The production challenged actors to master 17th-century verse while finding modern emotional truth.</p>
                                <p>As Theogenes - The Lover, I connected with the verbs that brought the character to life and genuinely fell in love on stage. I also taught yoga to the company every other day, helping connect with breath and body.</p>
                                <p><em>Performance archived in personal collection</em></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/drama/performance-photography.jpg')">Performance Photography</div>
                                <div class="project-image" style="background-image: url('./images/drama/behind-the-scenes.jpg')">Behind-the-Scenes</div>
                                <div class="project-image" style="background-image: url('./images/drama/cast-images.jpg')">Cast Images</div>
                                <div class="project-image" style="background-image: url('./images/drama/set-design.jpg')">Set Design</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>

            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">Vipassana Journey <span class="project-status status-ongoing">Ongoing</span></span>
                    <span class="project-year">2022 – Present</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>Personal Practice & Mindfulness</h3>
                                <p>After burning out from building startups, I needed something no algorithm could provide. A way to sit with myself.</p>
                                <p>The practice involves 10 day silent retreats completed at Dhamma Medini, NZ, with an intention of twice daily meditation sits. The approach eschews apps and hacks in favor of just the breath, the body, and whatever arises.</p>
                                <p>The key insight: "It's not about achieving some perfect mental state, it's about seeing what's already there." This ongoing practice provides grounding and perspective that informs all other work.</p>
                                <p>This foundation of mindfulness and presence has become integral to my approach to technology, bringing intention and awareness to how I build and interact with digital systems.</p>
                                <p><a href="https://www.dhamma.org/en/index" class="project-link" target="_blank" rel="noopener noreferrer">▶ Learn More</a></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/vipassana/retreat-photography.jpg')">Retreat Photography</div>
                                <div class="project-image" style="background-image: url('./images/vipassana/meditation-hall.jpg')">Meditation Hall</div>
                                <div class="project-image" style="background-image: url('./images/vipassana/dhamma-medini.jpg')">Dhamma Medini</div>
                                <div class="project-image" style="background-image: url('./images/vipassana/silent-reflection.jpg')">Silent Reflection</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>

            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">Talent Army <span class="project-status status-award">Award Winner</span></span>
                    <span class="project-year">2022</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>Best UX Design, NZ Tech Innovation | Psychoactive</h3>
                                <p>A reimagining of tech recruitment as a dynamic growth journey, replacing sterile job boards with living stories of career transformation.</p>
                                <p>The narrative-driven web experience featured claymation-style 3D animations, spontaneous "Easter egg" movements, and visual storytelling for both employers and candidates. The intelligent job board included custom API syncing between Webflow and JobAdder in real-time, JetBoost filtering that felt like Tinder for dream jobs, and Kiwi-tech coded icons replacing generic briefcase symbols.</p>
                                <p>As Account Manager, I won the pitch against 4 agencies by demonstrating how storytelling reduces candidate drop-off. As Conductor, I managed 6 specialists across 3 timezones, and as Bridge Builder, I translated recruiter pain points into playful interactions.</p>
                                <p>The project was shortlisted for 2023 Webby Awards and became Talent Army's flagship client acquisition tool.</p>
                                <p><a href="https://www.talent.army/" class="project-link" target="_blank" rel="noopener noreferrer">▶ View Live Site</a></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/talent-army/homepage-design.jpg')">Homepage Design</div>
                                <div class="project-image" style="background-image: url('./images/talent-army/job-board-interface.jpg')">Job Board Interface</div>
                                <div class="project-image" style="background-image: url('./images/talent-army/3d-animation-examples.jpg')">3D Animation Examples</div>
                                <div class="project-image" style="background-image: url('./images/talent-army/awards-recognition.jpg')">Awards Recognition</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>

            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">Blackbird VC</span>
                    <span class="project-year">2022</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>Australia | Psychoactive</h3>
                                <p>Blackbird VC needed a digital presence as bold as their investments. One that would make founders feel seen, not just pitched to.</p>
                                <p>We abandoned the tired "suits shaking hands" aesthetic and built an electric visual language featuring handmade documentary photography of real founders and bespoke animations mimicking startup momentum. The functional artistry organized content like a gallery with no buried decks, and interactive founder stories triggered by scroll velocity.</p>
                                <p>My role as Deal Maker involved working with the development team and Blackbird to envision a website that was both achievable and visually stunning, creating a rebellion against traditional VC digital clichés.</p>
                                <p><a href="https://www.blackbird.vc/home-hub" class="project-link" target="_blank" rel="noopener noreferrer">▶ View Project</a></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/blackbird/homepage-design.jpg')">Homepage Design</div>
                                <div class="project-image" style="background-image: url('./images/blackbird/portfolio-layout.jpg')">Portfolio Layout</div>
                                <div class="project-image" style="background-image: url('./images/blackbird/founder-stories-interface.jpg')">Founder Stories Interface</div>
                                <div class="project-image" style="background-image: url('./images/blackbird/interactive-elements.jpg')">Interactive Elements</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>

            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">121 Festival</span>
                    <span class="project-year">2021</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>Entertainment Technology | Psychoactive</h3>
                                <p>Wellington's legendary Club 121 needed a website that could bottle their underground energy and pour it across screens nationwide. A digital mainstage for their debut festival.</p>
                                <p>The project featured psychedelic Kiwi immersion with native flora and fauna illustrations pulsing to ambient basslines, hover-triggered soundwave animations, and lineup reveals that felt like uncovering secret set times at the venue. The technical backbone included an Airtable/Zapier CMS allowing real-time vendor applications and volunteer coordination.</p>
                                <p>As Project Manager, I pitched the "digital doof" concept after attending 3 club nights for research. As Systems Architect, I streamlined 14 stakeholder workflows into one unified backend while balancing festival chaos with UX clarity.</p>
                                <p><em>Festival concluded - site archived</em></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/121-festival/homepage-design.jpg')">Homepage Design</div>
                                <div class="project-image" style="background-image: url('./images/121-festival/content-management-interface.jpg')">Content Management Interface</div>
                                <div class="project-image" style="background-image: url('./images/121-festival/interactive-elements.jpg')">Interactive Elements</div>
                                <div class="project-image" style="background-image: url('./images/121-festival/festival-branding.jpg')">Festival Branding</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>
        </ul>
    </section>

    <section class="contact-section" id="contact">
        <div class="contact-header">
            <h2 class="contact-title">Contact</h2>
        </div>
        
        <div class="contact-buttons">
            <a href="https://www.linkedin.com/in/elliot-james-lee" class="contact-button" target="_blank" rel="noopener noreferrer">
                <span>LinkedIn</span>
            </a>
            <a href="mailto:elliotjameslee8@gmail.com" class="contact-button">
                <span>Email</span>
            </a>
            <a href="https://www.instagram.com/elliot.james.lee/" class="contact-button" target="_blank" rel="noopener noreferrer">
                <span>Instagram</span>
            </a>
        </div>
    </section>

    <div class="performance-info" id="performanceInfo">
        Performance: Optimized
    </div>

    <!-- Configuration and main application scripts now in js/main.js -->
        const CONFIG = {
            artifacts: {
                hankies: { 
                    resolution: window.innerWidth < 768 ? 16 : 32, 
                    animationSpeed: 0.0013 
                },
                particles: { 
                    count: window.innerWidth < 768 ? 15000 : 45000, 
                    opacity: 0.4 
                },
                ascii: {
                    width: window.innerWidth < 768 ? 45 : 65,
                    height: window.innerWidth < 768 ? 45 : 65
                },
                metamorphosis: {
                    numLines: window.innerWidth < 768 ? 60 : 120,
                    lineSegments: window.innerWidth < 768 ? 90 : 180
                },
                sineWaves: {
                    layers: window.innerWidth < 768 ? 40 : 80,
                    points: window.innerWidth < 768 ? 100 : 200
                }
            },
            transitions: { duration: 1200, delay: 150 },
            titles: ["ELLIOT LEE", "PRODUCT MANAGER", "BUILDER", "ACCOUNT MANAGER", "HUMAN"]
        };

        // Performance monitoring configuration
        const PERFORMANCE_CONFIG = {
            battery: {
                lowThreshold: 0.2,
                criticalThreshold: 0.1
            },
            thermal: {
                throttleTemp: 45, // Celsius
                shutdownTemp: 55
            },
            network: {
                slowConnection: ['slow-2g', '2g'],
                fastConnection: ['4g', '5g']
            },
            performance: {
                targetFPS: 60,
                minFPS: 30
            }
        };

        // Mobile Performance Manager
        class MobilePerformanceManager {
            constructor() {
                this.isLowPower = false;
                this.isCriticalMode = false;
                this.currentFPS = 60;
                this.frameCount = 0;
                this.lastFPSUpdate = Date.now();
                this.originalConfig = this.backupConfig();
                this.setupMonitoring();
            }
            
            backupConfig() {
                return JSON.parse(JSON.stringify(CONFIG.artifacts));
            }
            
            async setupMonitoring() {
                // Battery API monitoring
                if ('getBattery' in navigator) {
                    try {
                        const battery = await navigator.getBattery();
                        this.monitorBattery(battery);
                    } catch (e) {
                        console.log('Battery API not available');
                    }
                }
                
                // Network connection monitoring
                if ('connection' in navigator) {
                    this.monitorConnection();
                }
                
                // Frame rate monitoring
                this.startFPSMonitoring();
                
                // Visibility change optimization
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        this.pauseHeavyAnimations();
                    } else {
                        this.resumeAnimations();
                    }
                });
                
                // Device memory monitoring (if available)
                if ('deviceMemory' in navigator && navigator.deviceMemory < 4) {
                    this.enableLowMemoryMode();
                }
            }
            
            monitorBattery(battery) {
                const checkBattery = () => {
                    const batteryInfo = {
                        level: battery.level,
                        charging: battery.charging,
                        chargingTime: battery.chargingTime,
                        dischargingTime: battery.dischargingTime
                    };
                    
                    if (battery.level < PERFORMANCE_CONFIG.battery.criticalThreshold) {
                        this.enableCriticalMode(batteryInfo);
                    } else if (battery.level < PERFORMANCE_CONFIG.battery.lowThreshold) {
                        this.enableLowPowerMode(batteryInfo);
                    } else if (!battery.charging && this.isLowPower) {
                        // Only disable low power if we're not charging and battery is good
                        this.disableLowPowerMode();
                    }
                };
                
                battery.addEventListener('levelchange', checkBattery);
                battery.addEventListener('chargingchange', checkBattery);
                checkBattery();
            }
            
            monitorConnection() {
                const connection = navigator.connection;
                const checkConnection = () => {
                    if (PERFORMANCE_CONFIG.network.slowConnection.includes(connection.effectiveType)) {
                        this.enableLowBandwidthMode();
                    } else if (PERFORMANCE_CONFIG.network.fastConnection.includes(connection.effectiveType)) {
                        this.disableLowBandwidthMode();
                    }
                };
                
                connection.addEventListener('change', checkConnection);
                checkConnection();
            }
            
            startFPSMonitoring() {
                const measureFPS = () => {
                    this.frameCount++;
                    const now = Date.now();
                    
                    if (now - this.lastFPSUpdate >= 1000) {
                        this.currentFPS = this.frameCount;
                        this.frameCount = 0;
                        this.lastFPSUpdate = now;
                        
                        // Adjust performance based on FPS
                        if (this.currentFPS < PERFORMANCE_CONFIG.performance.minFPS && !this.isLowPower) {
                            this.enablePerformanceMode();
                        }
                        
                        this.updatePerformanceIndicator();
                    }
                    
                    requestAnimationFrame(measureFPS);
                };
                measureFPS();
            }
            
            enableLowPowerMode(batteryInfo = null) {
                if (this.isLowPower) return;
                this.isLowPower = true;
                
                // Reduce particle counts by 75%
                CONFIG.artifacts.particles.count = Math.floor(this.originalConfig.particles.count * 0.25);
                CONFIG.artifacts.hankies.resolution = Math.floor(this.originalConfig.hankies.resolution * 0.5);
                CONFIG.artifacts.ascii.width = Math.floor(this.originalConfig.ascii.width * 0.7);
                CONFIG.artifacts.ascii.height = Math.floor(this.originalConfig.ascii.height * 0.7);
                CONFIG.artifacts.metamorphosis.numLines = Math.floor(this.originalConfig.metamorphosis.numLines * 0.5);
                CONFIG.artifacts.metamorphosis.lineSegments = Math.floor(this.originalConfig.metamorphosis.lineSegments * 0.5);
                CONFIG.artifacts.sineWaves.layers = Math.floor(this.originalConfig.sineWaves.layers * 0.5);
                CONFIG.artifacts.sineWaves.points = Math.floor(this.originalConfig.sineWaves.points * 0.5);
                
                // Reduce animation speeds
                CONFIG.artifacts.hankies.animationSpeed *= 0.5;
                
                // Show low power indicator
                const message = batteryInfo ? 
                    `Low Power Mode: ${Math.round(batteryInfo.level * 100)}% battery` : 
                    'Low Power Mode Active';
                this.showPowerModeIndicator(message, '#ff9500');
                
                // Restart current artifact with new settings
                this.restartCurrentArtifact();
                
                console.log('Low power mode enabled', batteryInfo);
            }
            
            enableCriticalMode(batteryInfo) {
                if (this.isCriticalMode) return;
                this.isCriticalMode = true;
                this.isLowPower = true;
                
                // Stop all animations except essential UI
                this.pauseAllArtifacts();
                this.showPowerModeIndicator(
                    `Critical Battery: ${Math.round(batteryInfo.level * 100)}% - Animations Paused`, 
                    '#ff3300'
                );
                console.log('Critical battery mode enabled', batteryInfo);
            }
            
            enablePerformanceMode() {
                // Automatically reduce settings when FPS drops
                CONFIG.artifacts.particles.count = Math.floor(CONFIG.artifacts.particles.count * 0.8);
                CONFIG.artifacts.hankies.resolution = Math.max(8, Math.floor(CONFIG.artifacts.hankies.resolution * 0.8));
                
                this.showPowerModeIndicator(`Performance Mode: ${this.currentFPS}fps`, '#ffa500');
                this.restartCurrentArtifact();
            }
            
            enableLowMemoryMode() {
                CONFIG.artifacts.particles.count = Math.floor(CONFIG.artifacts.particles.count * 0.6);
                CONFIG.artifacts.ascii.width = Math.floor(CONFIG.artifacts.ascii.width * 0.8);
                CONFIG.artifacts.ascii.height = Math.floor(CONFIG.artifacts.ascii.height * 0.8);
                
                this.showPowerModeIndicator('Low Memory Mode', '#ff6600');
                console.log('Low memory mode enabled');
            }
            
            enableLowBandwidthMode() {
                // Reduce update frequencies for network-dependent features
                CONFIG.transitions.duration = Math.min(CONFIG.transitions.duration * 1.5, 2000);
                this.showPowerModeIndicator('Slow Connection Detected', '#666666');
            }
            
            disableLowPowerMode() {
                if (!this.isLowPower) return;
                this.isLowPower = false;
                this.isCriticalMode = false;
                
                // Restore original settings
                CONFIG.artifacts = JSON.parse(JSON.stringify(this.originalConfig));
                
                this.hidePowerModeIndicator();
                this.restartCurrentArtifact();
                console.log('Low power mode disabled');
            }
            
            disableLowBandwidthMode() {
                CONFIG.transitions.duration = 1200; // Reset to default
            }
            
            pauseHeavyAnimations() {
                // Pause current artifact animations
                if (window.currentArtifactAnimation) {
                    cancelAnimationFrame(window.currentArtifactAnimation);
                }
                
                // Pause Three.js rendering
                Object.values(threeScenes).forEach(scene => {
                    if (scene.renderer && scene.renderer.setAnimationLoop) {
                        scene.renderer.setAnimationLoop(null);
                    }
                });
            }
            
            pauseAllArtifacts() {
                this.pauseHeavyAnimations();
                // Set black background to save energy
                document.body.style.background = '#000000';
            }
            
            resumeAnimations() {
                if (!this.isCriticalMode && !document.hidden) {
                    // Restart current artifact if not in critical mode
                    if (typeof artifacts !== 'undefined' && artifacts[currentArtifact]) {
                        artifacts[currentArtifact]();
                    }
                    
                    // Restore background
                    document.body.style.background = '';
                }
            }
            
            restartCurrentArtifact() {
                if (this.isCriticalMode) return;
                
                // Clean up current artifact
                if (threeScenes[`artifact-${currentArtifact + 1}`]?.cleanup) {
                    threeScenes[`artifact-${currentArtifact + 1}`].cleanup();
                }
                
                // Restart with new settings
                setTimeout(() => {
                    if (artifacts[currentArtifact]) {
                        artifacts[currentArtifact]();
                    }
                }, 100);
            }
            
            showPowerModeIndicator(message, color = '#ff9500') {
                let indicator = document.getElementById('powerModeIndicator');
                if (!indicator) {
                    indicator = document.createElement('div');
                    indicator.id = 'powerModeIndicator';
                    indicator.style.cssText = `
                        position: fixed;
                        top: 80px;
                        right: 20px;
                        background: ${color};
                        color: white;
                        padding: 8px 12px;
                        border-radius: 4px;
                        font-size: 12px;
                        z-index: 1002;
                        font-family: 'Roboto Mono', monospace;
                        max-width: 200px;
                        text-align: center;
                        animation: slideInRight 0.3s ease-out;
                    `;
                    document.body.appendChild(indicator);
                    
                    // Add animation
                    const style = document.createElement('style');
                    style.textContent = `
                        @keyframes slideInRight {
                            from { transform: translateX(100%); opacity: 0; }
                            to { transform: translateX(0); opacity: 1; }
                        }
                    `;
                    document.head.appendChild(style);
                } else {
                    indicator.style.background = color;
                }
                indicator.textContent = message;
            }
            
            hidePowerModeIndicator() {
                const indicator = document.getElementById('powerModeIndicator');
                if (indicator) {
                    indicator.style.animation = 'slideInRight 0.3s ease-out reverse';
                    setTimeout(() => indicator.remove(), 300);
                }
            }
            
            updatePerformanceIndicator() {
                const perfInfo = document.getElementById('performanceInfo');
                if (perfInfo) {
                    let status = 'Optimized';
                    let color = '#00ff00';
                    
                    if (this.isCriticalMode) {
                        status = 'Critical Battery';
                        color = '#ff3300';
                    } else if (this.isLowPower) {
                        status = 'Low Power';
                        color = '#ff9500';
                    } else if (this.currentFPS < PERFORMANCE_CONFIG.performance.minFPS) {
                        status = `${this.currentFPS}fps`;
                        color = '#ffa500';
                    }
                    
                    perfInfo.textContent = `Performance: ${status}`;
                    perfInfo.style.color = color;
                }
            }
        }

        // Enhanced Mobile Accessibility Manager
        class MobileAccessibilityManager {
            constructor() {
                this.setupMobileA11y();
                this.setupScreenReaderSupport();
                this.setupVoiceOverSupport();
                this.setupTalkBackSupport();
                this.addLiveRegions();
            }
            
            setupMobileA11y() {
                // Enhanced focus management for mobile
                document.addEventListener('focusin', (e) => {
                    const target = e.target;
                    
                    // Ensure focused element is visible on mobile
                    if (target.classList.contains('glitch-title') || 
                        target.classList.contains('spark-magic') ||
                        target.classList.contains('chat-control-btn')) {
                        target.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'center',
                            inline: 'nearest'
                        });
                    }
                    
                    // Add focus announcement for screen readers
                    if (target.hasAttribute('aria-label')) {
                        this.announceToScreenReader(`Focused: ${target.getAttribute('aria-label')}`);
                    }
                });
                
                // Enhanced keyboard navigation
                document.addEventListener('keydown', (e) => {
                    // Handle escape key to close modals
                    if (e.key === 'Escape') {
                        this.handleEscapeKey();
                    }
                    
                    // Handle arrow keys for artifact navigation
                    if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                        const activeElement = document.activeElement;
                        if (activeElement.classList.contains('glitch-title') || 
                            activeElement.classList.contains('spark-magic')) {
                            e.preventDefault();
                            
                            if (e.key === 'ArrowRight') {
                                changeEverything();
                                this.announceToScreenReader('Next experience loaded');
                            } else if (window.gestureManager?.previousArtifact) {
                                window.gestureManager.previousArtifact();
                                this.announceToScreenReader('Previous experience loaded');
                            }
                        }
                    }
                });
            }
            
            addLiveRegions() {
                // Create ARIA live region for dynamic announcements
                const liveRegion = document.createElement('div');
                liveRegion.setAttribute('aria-live', 'polite');
                liveRegion.setAttribute('aria-atomic', 'true');
                liveRegion.setAttribute('id', 'liveRegion');
                liveRegion.className = 'sr-only';
                liveRegion.style.cssText = `
                    position: absolute;
                    width: 1px;
                    height: 1px;
                    padding: 0;
                    margin: -1px;
                    overflow: hidden;
                    clip: rect(0, 0, 0, 0);
                    white-space: nowrap;
                    border: 0;
                `;
                document.body.appendChild(liveRegion);
                
                // Create assertive live region for urgent announcements
                const assertiveRegion = document.createElement('div');
                assertiveRegion.setAttribute('aria-live', 'assertive');
                assertiveRegion.setAttribute('aria-atomic', 'true');
                assertiveRegion.setAttribute('id', 'assertiveRegion');
                assertiveRegion.className = 'sr-only';
                assertiveRegion.style.cssText = liveRegion.style.cssText;
                document.body.appendChild(assertiveRegion);
            }
            
            setupScreenReaderSupport() {
                // Enhance artifact change announcements
                const originalChangeEverything = window.changeEverything;
                window.changeEverything = () => {
                    originalChangeEverything.call(window);
                    
                    setTimeout(() => {
                        const currentTitle = CONFIG.titles[currentTitleIndex];
                        const experienceNumber = currentArtifact + 1;
                        this.announceToScreenReader(
                            `Now showing experience ${experienceNumber}: ${currentTitle} with interactive artwork`
                        );
                    }, 500);
                };
                
                // Add landmarks and structure
                this.addLandmarkRoles();
                this.enhanceFormAccessibility();
            }
            
            addLandmarkRoles() {
                // Add main landmark
                const heroContainer = document.querySelector('.hero-container');
                if (heroContainer) {
                    heroContainer.setAttribute('role', 'main');
                    heroContainer.setAttribute('aria-label', 'Portfolio showcase with interactive art');
                }
                
                // Add navigation landmark
                const navBar = document.querySelector('.nav-bar');
                if (navBar) {
                    navBar.setAttribute('role', 'navigation');
                    navBar.setAttribute('aria-label', 'Main navigation');
                }
                
                // Add complementary landmarks for sections
                const contactSection = document.querySelector('.contact-section');
                if (contactSection) {
                    contactSection.setAttribute('role', 'complementary');
                    contactSection.setAttribute('aria-label', 'Contact information');
                }
                
                const projectsSection = document.querySelector('.projects-section');
                if (projectsSection) {
                    projectsSection.setAttribute('role', 'region');
                    projectsSection.setAttribute('aria-label', 'Featured projects');
                }
            }
            
            enhanceFormAccessibility() {
                // Enhance chat input
                const messageInput = document.getElementById('messageInput');
                if (messageInput) {
                    messageInput.setAttribute('aria-describedby', 'messageInputDesc');
                    
                    const description = document.createElement('div');
                    description.id = 'messageInputDesc';
                    description.className = 'sr-only';
                    description.textContent = 'Type your message and press Enter to send';
                    messageInput.parentNode.insertBefore(description, messageInput);
                }
                
                // Enhance project items
                document.querySelectorAll('.project-item').forEach((item, index) => {
                    item.setAttribute('role', 'button');
                    item.setAttribute('aria-expanded', 'false');
                    item.setAttribute('aria-describedby', `project-desc-${index}`);
                    item.setAttribute('tabindex', '0');
                    
                    const originalToggle = item.onclick;
                    item.onclick = function() {
                        originalToggle.call(this);
                        const isOpen = this.classList.contains('open');
                        this.setAttribute('aria-expanded', isOpen.toString());
                        
                        const action = isOpen ? 'expanded' : 'collapsed';
                        window.accessibilityManager.announceToScreenReader(
                            `Project ${this.querySelector('.project-header').textContent} ${action}`
                        );
                    };
                    
                    // Add keyboard support
                    item.addEventListener('keydown', (e) => {
                        if (e.key === ' ' || e.key === 'Enter') {
                            e.preventDefault();
                            item.click();
                        }
                    });
                });
            }
            
            setupVoiceOverSupport() {
                // Enhanced VoiceOver navigation for iOS
                document.querySelector('.glitch-title').setAttribute(
                    'aria-description', 
                    'Interactive title that cycles through different professional identities and changes the background artwork. Swipe or use arrow keys to navigate.'
                );
                
                document.querySelector('.spark-magic').setAttribute(
                    'aria-description',
                    'Alternative control to cycle through visual experiences'
                );
                
                // Add VoiceOver-specific hint text
                if (this.isIOSDevice()) {
                    const voiceOverHints = document.createElement('div');
                    voiceOverHints.className = 'sr-only';
                    voiceOverHints.textContent = 'VoiceOver users: Use flick gestures to navigate between elements, and double-tap to activate. Swipe left or right on the main area to change experiences.';
                    document.body.appendChild(voiceOverHints);
                }
            }
            
            setupTalkBackSupport() {
                // Enhanced TalkBack support for Android
                if (this.isAndroidDevice()) {
                    // Add content descriptions for TalkBack
                    document.querySelectorAll('[role="button"]').forEach(button => {
                        if (!button.hasAttribute('aria-description')) {
                            const label = button.getAttribute('aria-label') || button.textContent;
                            button.setAttribute('aria-description', `Button: ${label}`);
                        }
                    });
                    
                    // Add TalkBack-specific instructions
                    const talkBackHints = document.createElement('div');
                    talkBackHints.className = 'sr-only';
                    talkBackHints.textContent = 'TalkBack users: Use explore by touch to navigate, and double-tap to activate elements. Swipe gestures change the visual experience.';
                    document.body.appendChild(talkBackHints);
                }
            }
            
            announceToScreenReader(message, urgent = false) {
                const regionId = urgent ? 'assertiveRegion' : 'liveRegion';
                const region = document.getElementById(regionId);
                if (region) {
                    // Clear first to ensure the announcement triggers
                    region.textContent = '';
                    setTimeout(() => {
                        region.textContent = message;
                    }, 100);
                    
                    // Clear after announcement
                    setTimeout(() => {
                        region.textContent = '';
                    }, 3000);
                }
            }
            
            handleEscapeKey() {
                // Close any open modals or overlays
                const chatOverlay = document.querySelector('.chat-overlay.active');
                if (chatOverlay) {
                    chatOverlay.classList.remove('active');
                    this.announceToScreenReader('Chat closed');
                    return;
                }
                
                const terminalOverlay = document.getElementById('terminalOverlay');
                if (terminalOverlay && terminalOverlay.style.display === 'block') {
                    terminalOverlay.style.display = 'none';
                    this.announceToScreenReader('Terminal closed');
                    return;
                }
                
                // Close any expanded project items
                const openProjects = document.querySelectorAll('.project-item.open');
                if (openProjects.length > 0) {
                    openProjects.forEach(project => {
                        project.classList.remove('open');
                        project.setAttribute('aria-expanded', 'false');
                    });
                    this.announceToScreenReader('All projects collapsed');
                }
            }
            
            isIOSDevice() {
                return /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                       (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            }
            
            isAndroidDevice() {
                return /Android/.test(navigator.userAgent);
            }
            
            // Performance mode accessibility adjustments
            adjustForPerformanceMode() {
                if (window.performanceManager?.isLowPower) {
                    // Reduce animation announcements in low power mode
                    this.announceToScreenReader('Low power mode active - reduced animations for better battery life');
                }
                
                if (window.performanceManager?.isCriticalMode) {
                    this.announceToScreenReader('Critical battery mode - animations paused to conserve power', true);
                }
            }
        }

        // Global state
        let currentArtifact = 0;
        let currentTheme = 'light';
        let currentTitleIndex = 0;
        let isTweening = false;
        let artifacts = [];
        let threeScenes = {};
        let isTransitioning = false;
        let resizeTimeout;
        let performanceMonitor = { fps: 0, lastTime: 0, frameCount: 0 };

        // Performance monitoring
        function updatePerformanceInfo() {
            performanceMonitor.frameCount++;
            const currentTime = performance.now();
            
            if (currentTime > performanceMonitor.lastTime + 1000) {
                performanceMonitor.fps = Math.round((performanceMonitor.frameCount * 1000) / (currentTime - performanceMonitor.lastTime));
                performanceMonitor.frameCount = 0;
                performanceMonitor.lastTime = currentTime;
                
                const perfInfo = document.getElementById('performanceInfo');
                if (perfInfo) {
                    const quality = performanceMonitor.fps > 45 ? 'Excellent' : 
                                   performanceMonitor.fps > 30 ? 'Good' : 'Basic';
                    perfInfo.textContent = `Performance: ${quality} (${performanceMonitor.fps} FPS)`;
                }
            }
        }

        // Error handling wrapper
        function safeInitArtifact(artifactFunction, artifactId, fallback = null) {
            try {
                artifactFunction();
            } catch (error) {
                console.warn(`Artifact ${artifactId} initialization failed:`, error);
                if (fallback) {
                    fallback();
                } else {
                    // Show error fallback
                    const container = document.getElementById(artifactId);
                    if (container) {
                        container.innerHTML = '<div class="error-fallback">Unable to load visualization</div>';
                    }
                }
            }
        }

        // Enhanced cleanup function
        function enhancedCleanup(scene, renderer, container, animationFrameId) {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            
            if (scene) {
                scene.traverse((object) => {
                    if (object.geometry) {
                        object.geometry.dispose();
                    }
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(material => material.dispose());
                        } else {
                            object.material.dispose();
                        }
                    }
                });
            }
            
            if (renderer) {
                renderer.dispose();
                if (renderer.domElement && container && container.contains(renderer.domElement)) {
                    container.removeChild(renderer.domElement);
                }
            }
        }

        // Accessibility: Keyboard event handler
        function handleKeyPress(event) {
            if (event.key === ' ' || event.key === 'Enter') {
                event.preventDefault();
                changeEverything();
            }
        }

        // Title cycling system
        function cycleTitle() {
            const titleElement = document.querySelector('.glitch-title');
            
            currentTitleIndex = (currentTitleIndex + 1) % CONFIG.titles.length;
            const newTitle = CONFIG.titles[currentTitleIndex];
            
            gsap.to(titleElement, {
                duration: 1.2,
                text: {
                    value: newTitle,
                    delimiter: ""
                },
                ease: "none"
            });
        }

        // Combined function that changes both title and artifact
        function changeEverything() {
            if (isTransitioning) return;
            isTransitioning = true;
            
            // Trigger title glitch
            cycleTitle();
            
            // Change artifact with slight delay for dramatic effect
            setTimeout(() => {
                changeArtifact();
                setTimeout(() => {
                    isTransitioning = false;
                }, CONFIG.transitions.duration);
            }, CONFIG.transitions.delay);
            
            // Visual feedback for buttons
            const activeElement = document.activeElement;
            if (activeElement.classList.contains('spark-magic') || activeElement.classList.contains('glitch-title')) {
                activeElement.style.transform = 'scale(1.2)';
                setTimeout(() => {
                    activeElement.style.transform = '';
                }, 200);
            }
        }

        // Initialize artifacts
        function initializeArtifacts() {
            artifacts = [
                () => safeInitArtifact(initHankiesInTheWind, 'artifact-1'),
                () => safeInitArtifact(initAsciiBinaryFlow, 'artifact-2'),
                () => safeInitArtifact(initParticleVessel, 'artifact-3'),
                () => safeInitArtifact(initMetamorphosis, 'artifact-4'),
                () => safeInitArtifact(initLayeredSineWaves, 'artifact-5')
            ];
            
            // Initialize the first artifact
            artifacts[0]();
        }

        // Artifact 1: Enhanced HankiesInTheWind
        function initHankiesInTheWind() {
            const container = document.getElementById('artifact-1');
            if (container.hasChildNodes()) return;
            
            let scene, camera, renderer, lineGroups = [];
            let animationFrameId;
            
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ 
                antialias: !window.matchMedia('(max-width: 768px)').matches,
                powerPreference: "high-performance"
            });
            
            renderer.setSize(width, height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(currentTheme === 'dark' ? 0x1a1a1a : 0xF0EEE6);
            container.appendChild(renderer.domElement);
            
            camera.position.set(0, 0, 6);
            camera.lookAt(0, 0, 0);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(5, 5, 5);
            scene.add(ambientLight);
            scene.add(directionalLight);
            
            const mainGroup = new THREE.Group();
            scene.add(mainGroup);
            
            let time = 0;
            
            function createWaveSources(time, scale) {
                const result = [];
                const count = 5;
                
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const radius = scale * (1 + Math.sin(angle * 3) * 0.2);
                    
                    result.push({
                        position: [
                            Math.cos(angle) * radius,
                            0,
                            Math.sin(angle) * radius
                        ],
                        frequency: 2 + Math.sin(angle * 2),
                        amplitude: 0.3 + Math.cos(angle) * 0.1,
                        phase: time * 3 + angle
                    });
                }
                
                result.push({
                    position: [0, 0, 0],
                    frequency: 3,
                    amplitude: 0.4,
                    phase: time * 4
                });
                
                return result;
            }
            
            function createInterferenceField(sources, size, resolution, time) {
                const step = size / resolution;
                const heightMap = [];
                
                for (let i = 0; i <= resolution; i++) {
                    heightMap[i] = [];
                    const x = (i * step) - (size / 2);
                    
                    for (let j = 0; j <= resolution; j++) {
                        const z = (j * step) - (size / 2);
                        let height = 0;
                        
                        sources.forEach(({ position: [sx, sy, sz], frequency, amplitude, phase }) => {
                            const dx = x - sx;
                            const dz = z - sz;
                            const distance = Math.sqrt(dx * dx + dz * dz);
                            height += Math.sin(distance * frequency - time * 5 + phase) * 
                                     amplitude * Math.exp(-distance * 0.3);
                        });
                        
                        heightMap[i][j] = height;
                    }
                }
                
                const linesMaterial = new THREE.LineBasicMaterial({ 
                    color: currentTheme === 'dark' ? 0xffffff : 0x333333,
                    transparent: true,
                    opacity: 0.4
                });
                
                const linesGroup = new THREE.Group();
                
                // Create horizontal lines
                for (let i = 0; i <= resolution; i++) {
                    const geometry = new THREE.BufferGeometry();
                    const points = [];
                    const x = (i * step) - (size / 2);
                    
                    for (let j = 0; j <= resolution; j++) {
                        const z = (j * step) - (size / 2);
                        points.push(x, heightMap[i][j], z);
                    }
                    
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
                    const line = new THREE.Line(geometry, linesMaterial);
                    linesGroup.add(line);
                }
                
                // Create vertical lines
                for (let j = 0; j <= resolution; j++) {
                    const geometry = new THREE.BufferGeometry();
                    const points = [];
                    const z = (j * step) - (size / 2);
                    
                    for (let i = 0; i <= resolution; i++) {
                        const x = (i * step) - (size / 2);
                        points.push(x, heightMap[i][j], z);
                    }
                    
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
                    const line = new THREE.Line(geometry, linesMaterial);
                    linesGroup.add(line);
                }
                
                return linesGroup;
            }
            
            function animate() {
                animationFrameId = requestAnimationFrame(animate);
                time += CONFIG.artifacts.hankies.animationSpeed;
                
                updatePerformanceInfo();
                
                // Clear previous groups
                mainGroup.children.forEach(child => {
                    if (child instanceof THREE.Group) {
                        child.children.forEach(line => {
                            if (line.geometry) line.geometry.dispose();
                            if (line.material) line.material.dispose();
                        });
                        mainGroup.remove(child);
                    }
                });
                
                // Create new interference fields
                const sources1 = createWaveSources(time, 1.5);
                const field1 = createInterferenceField(sources1, 1.5 * 4, CONFIG.artifacts.hankies.resolution, time);
                mainGroup.add(field1);
                
                const sources2 = createWaveSources(time + 0.33, 0.8);
                const field2 = createInterferenceField(sources2, 0.8 * 4, CONFIG.artifacts.hankies.resolution, time + 0.33);
                field2.position.set(0, 1.5, 0);
                field2.rotation.set(Math.PI/6, 0, Math.PI/4);
                mainGroup.add(field2);
                
                mainGroup.rotation.y = Math.sin(time * 0.3) * 0.2;
                mainGroup.rotation.x = Math.cos(time * 0.2) * 0.1;
                
                renderer.render(scene, camera);
            }
            
            animate();
            
            // Store for cleanup
            threeScenes['artifact-1'] = {
                cleanup: () => enhancedCleanup(scene, renderer, container, animationFrameId)
            };
        }

        // Artifact 2: Enhanced AsciiBinaryFlow
        function initAsciiBinaryFlow() {
            const container = document.querySelector('#artifact-2 .ascii-container');
            if (container.dataset.initialized) return;
            container.dataset.initialized = 'true';
            
            let width = CONFIG.artifacts.ascii.width;
            let height = CONFIG.artifacts.ascii.height;
            let grid = [];
            let time = 0;
            let animationFrameId;
            
            function initGrid() {
                grid = [];
                for (let y = 0; y < height; y++) {
                    let row = [];
                    for (let x = 0; x < width; x++) {
                        row.push(' ');
                    }
                    grid.push(row);
                }
            }
            
            function render() {
                let html = '';
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        html += grid[y][x];
                    }
                    html += '<br>';
                }
                container.innerHTML = html;
            }
            
            function update() {
                initGrid();
                
                const blockSize = Math.floor(width * 0.46);
                const blockX = Math.floor(width / 2 - blockSize / 2);
                const blockY = Math.floor(height / 2 - blockSize / 2);
                const t = time * 0.005;
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        if (x >= blockX && x < blockX + blockSize && 
                            y >= blockY && y < blockY + blockSize) {
                            const innerDist = Math.min(
                                x - blockX, 
                                blockX + blockSize - x,
                                y - blockY,
                                blockY + blockSize - y
                            );
                            
                            const erosion = time * 0.0067;
                            if (innerDist > erosion) {
                                grid[y][x] = '1';
                            } else {
                                grid[y][x] = Math.random() > 0.8 ? '1' : '0';
                            }
                        } else {
                            const dx = x - width / 2;
                            const dy = y - height / 2;
                            const angle = Math.atan2(dy, dx);
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            const wave = Math.sin(dist * 0.2 - t + angle * 1.5);
                            const flow = Math.sin(x * 0.08 + y * 0.04 + t * 0.4);
                            
                            if (flow + wave > 0.4) {
                                grid[y][x] = '0';
                            } else if (flow + wave < -0.4) {
                                grid[y][x] = '~';
                            }
                        }
                    }
                }
                
                // Add cracks
                for (let i = 0; i < 5; i++) {
                    const crackX = blockX + Math.floor(Math.random() * blockSize);
                    const crackY = blockY + Math.floor(Math.random() * blockSize);
                    const length = Math.floor(Math.random() * 10) + 5;
                    let cx = Math.floor(crackX);
                    let cy = Math.floor(crackY);
                    
                    for (let j = 0; j < length; j++) {
                        if (cx >= 0 && cx < width && cy >= 0 && cy < height) {
                            grid[cy][cx] = '0';
                        }
                        cx += Math.floor(Math.random() * 3) - 1;
                        cy += Math.floor(Math.random() * 3) - 1;
                    }
                }
                
                time++;
            }
            
            function animate() {
                update();
                render();
                updatePerformanceInfo();
                animationFrameId = requestAnimationFrame(animate);
            }
            
            initGrid();
            animate();
            
            // Store for cleanup
            threeScenes['artifact-2'] = {
                cleanup: () => {
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    container.innerHTML = '';
                    container.dataset.initialized = '';
                }
            };
        }

        // Artifact 3: Enhanced ParticleVessel
        function initParticleVessel() {
            const container = document.getElementById('artifact-3');
            if (container.hasChildNodes()) return;
            
            let scene, camera, renderer, animationFrameId;
            const count = CONFIG.artifacts.particles.count;
            
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ 
                antialias: !window.matchMedia('(max-width: 768px)').matches,
                powerPreference: "high-performance"
            });
            
            renderer.setSize(width, height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(currentTheme === 'dark' ? 0x1a1a1a : 0xF0EEE6);
            container.appendChild(renderer.domElement);
            
            camera.position.z = 5;
            
            const particleMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    opacity: { value: CONFIG.artifacts.particles.opacity }
                },
                vertexShader: `
                    uniform float time;
                    attribute float size;
                    attribute vec3 customColor;
                    varying vec3 vColor;
                    
                    void main() {
                        vColor = customColor;
                        vec3 pos = position;
                        
                        float radius = length(pos.xz);
                        float angle = atan(pos.z, pos.x);
                        float height = pos.y;
                        
                        float vessel = smoothstep(0.3, 0.7, radius) * smoothstep(1.0, 0.7, radius);
                        
                        angle += time * 0.08;
                        
                        float space = sin(time * 0.3 + radius * 3.0) * 0.1;
                        
                        float newRadius = (radius + space) * vessel;
                        
                        vec3 newPos;
                        newPos.x = cos(angle) * newRadius;
                        newPos.z = sin(angle) * newRadius;
                        newPos.y = height * vessel - 1.2;
                        
                        newPos *= 2.75;
                        
                        vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);
                        gl_PointSize = size * (128.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform float opacity;
                    varying vec3 vColor;
                    void main() {
                        vec2 center = gl_PointCoord - vec2(0.5);
                        float dist = dot(center, center);
                        
                        if (dist > 0.25) discard;
                        
                        float alpha = (1.0 - smoothstep(0.2025, 0.25, dist)) * opacity;
                        gl_FragColor = vec4(vColor, alpha);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.NormalBlending
            });
            
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            
            let i3 = 0;
            for (let i = 0; i < count; i++) {
                const t = i / count;
                const radius = Math.pow(t, 0.5);
                const angle = t * Math.PI * 40;
                
                const vesselHeight = Math.sin(t * Math.PI) * 1.8;
                
                const randRadius = radius + (Math.random() - 0.5) * 0.05;
                const randAngle = angle + (Math.random() - 0.5) * 0.1;
                
                positions[i3] = Math.cos(randAngle) * randRadius;
                positions[i3 + 1] = vesselHeight;
                positions[i3 + 2] = Math.sin(randAngle) * randRadius;

                const shade = currentTheme === 'dark' ? 
                    (0.8 + Math.sqrt(radius) * 0.2 + Math.random() * 0.1) :
                    (0.1 + Math.sqrt(radius) * 0.1 + Math.random() * 0.02);
                colors[i3] = shade;
                colors[i3 + 1] = shade;
                colors[i3 + 2] = shade;

                sizes[i] = (1.0 - Math.abs(vesselHeight * 0.5)) * 0.2 + 0.1;
                
                i3 += 3;
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const points = new THREE.Points(geometry, particleMaterial);
            scene.add(points);
            
            const clock = new THREE.Clock();
            
            function animate() {
                animationFrameId = requestAnimationFrame(animate);
                
                const time = clock.getElapsedTime();
                particleMaterial.uniforms.time.value = time;
                
                updatePerformanceInfo();
                renderer.render(scene, camera);
            }
            
            animate();
            
            threeScenes['artifact-3'] = {
                cleanup: () => enhancedCleanup(scene, renderer, container, animationFrameId)
            };
        }

        // Artifact 4: Enhanced Metamorphosis
        function initMetamorphosis() {
            const canvas = document.querySelector('#artifact-4 canvas');
            if (canvas.dataset.initialized) return;
            canvas.dataset.initialized = 'true';
            
            const ctx = canvas.getContext('2d', { willReadFrequently: false });
            const width = canvas.width;
            const height = canvas.height;
            
            let animationFrameId;
            let time = 2000;
            
            const numLines = CONFIG.artifacts.metamorphosis.numLines;
            const lineSegments = CONFIG.artifacts.metamorphosis.lineSegments;
            const lineAlpha = 0.5;
            const lineWidth = 0.6;
            
            const forms = [
                // Form 1: Draped cloth-like shape
                (u, v, t) => {
                    const theta = u * Math.PI * 2;
                    const phi = v * Math.PI;
                    
                    let r = 120 + 30 * Math.sin(phi * 4 + theta * 2);
                    r += 20 * Math.sin(phi * 6) * Math.cos(theta * 3);
                    
                    let x = r * Math.sin(phi) * Math.cos(theta);
                    let y = r * Math.sin(phi) * Math.sin(theta);
                    let z = r * Math.cos(phi) + 20 * Math.sin(theta * 5 + phi * 3);
                    
                    return { x, y, z };
                },
                
                // Form 2: More angular folded shape
                (u, v, t) => {
                    const theta = u * Math.PI * 2;
                    const phi = v * Math.PI;
                    
                    let r = 150 + 20 * Math.cos(phi * 8);
                    r *= 0.8 + 0.2 * Math.abs(Math.cos(theta * 2));
                    
                    let x = r * Math.sin(phi) * Math.cos(theta);
                    let y = r * Math.sin(phi) * Math.sin(theta);
                    let z = r * Math.cos(phi) * (0.8 + 0.3 * Math.sin(theta * 4));
                    
                    return { x, y, z };
                },
                
                // Form 3: Organic bulbous shape
                (u, v, t) => {
                    const theta = u * Math.PI * 2;
                    const phi = v * Math.PI;
                    
                    let r = 120;
                    r += 50 * Math.sin(phi * 3) * Math.sin(theta * 2.5);
                    r += 30 * Math.cos(phi * 5 + theta);
                    
                    let x = r * Math.sin(phi) * Math.cos(theta);
                    let y = r * Math.sin(phi) * Math.sin(theta);
                    let z = r * Math.cos(phi);
                    
                    const hollow = Math.max(0, Math.sin(phi * 2 + theta * 3) - 0.7);
                    r *= 1 - hollow * 0.8;
                    
                    return { x, y, z };
                }
            ];
            
            function interpolateForms(formA, formB, u, v, t, blend) {
                const pointA = formA(u, v, t);
                const pointB = formB(u, v, t);
                
                return {
                    x: pointA.x * (1 - blend) + pointB.x * blend,
                    y: pointA.y * (1 - blend) + pointB.y * blend,
                    z: pointA.z * (1 - blend) + pointB.z * blend
                };
            }
            
            function getCurrentForm(u, v, t) {
                const totalForms = forms.length;
                const cycleTime = 600;
                const position = (t % (cycleTime * totalForms)) / cycleTime;
                const formIndex = Math.floor(position);
                const nextFormIndex = (formIndex + 1) % totalForms;
                
                let rawBlend = position - formIndex;
                const pauseTime = 0;
                const transitionTime = 1 - (pauseTime * 2);
                
                let blend;
                if (rawBlend < pauseTime) {
                    blend = 0;
                } else if (rawBlend > (1 - pauseTime)) {
                    blend = 1;
                } else {
                    const normalizedTime = (rawBlend - pauseTime) / transitionTime;
                    blend = normalizedTime < 0.5
                        ? 4 * normalizedTime * normalizedTime * normalizedTime
                        : 1 - Math.pow(-2 * normalizedTime + 2, 3) / 2;
                }
                
                return interpolateForms(
                    forms[formIndex], 
                    forms[nextFormIndex], 
                    u, v, t, blend
                );
            }
            
            function animate() {
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = currentTheme === 'dark' ? '#1a1a1a' : '#F0EEE6';
                ctx.fillRect(0, 0, width, height);
                
                const rotateX = Math.sin(time * 0.00025) * 0.5;
                const rotateY = Math.cos(time * 0.00025 * 0.7) * 0.3;
                const rotateZ = time * 0.00025 * 0.1;
                
                // Draw horizontal contour lines
                for (let i = 0; i < numLines; i++) {
                    const v = i / (numLines - 1);
                    
                    ctx.beginPath();
                    const strokeColor = currentTheme === 'dark' ? 'rgba(255, 255, 255, 0.5)' : 'rgba(51, 51, 51, 0.5)';
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = lineWidth;
                    
                    let lastPointVisible = false;
                    
                    for (let j = 0; j <= lineSegments; j++) {
                        const u = j / lineSegments;
                        
                        const point = getCurrentForm(u, v, time);
                        
                        const rotatedX = point.x * Math.cos(rotateZ) - point.y * Math.sin(rotateZ);
                        const rotatedY = point.x * Math.sin(rotateZ) + point.y * Math.cos(rotateZ);
                        const rotatedZ = point.z;
                        
                        const scale = 1.5 + rotatedZ * 0.001;
                        const projX = width / 2 + rotatedX * scale;
                        const projY = height / 2 + rotatedY * scale;
                        
                        const pointVisible = rotatedZ > -50;
                        
                        if (j === 0) {
                            if (pointVisible) {
                                ctx.moveTo(projX, projY);
                                lastPointVisible = true;
                            }
                        } else {
                            if (pointVisible && lastPointVisible) {
                                ctx.lineTo(projX, projY);
                            } else if (pointVisible && !lastPointVisible) {
                                ctx.moveTo(projX, projY);
                            }
                        }
                        
                        lastPointVisible = pointVisible;
                    }
                    
                    ctx.stroke();
                }
                
                // Draw vertical contour lines
                for (let i = 0; i < numLines * 0.3; i++) {
                    const u = i / (numLines * 0.3 - 1);
                    
                    ctx.beginPath();
                    const strokeColor = currentTheme === 'dark' ? 'rgba(255, 255, 255, 0.35)' : 'rgba(51, 51, 51, 0.35)';
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = lineWidth * 0.7;
                    
                    let lastPointVisible = false;
                    
                    for (let j = 0; j <= lineSegments * 0.5; j++) {
                        const v = j / (lineSegments * 0.5);
                        
                        const point = getCurrentForm(u, v, time);
                        
                        const rotatedX = point.x * Math.cos(rotateZ) - point.y * Math.sin(rotateZ);
                        const rotatedY = point.x * Math.sin(rotateZ) + point.y * Math.cos(rotateZ);
                        const rotatedZ = point.z;
                        
                        const scale = 1.5 + rotatedZ * 0.001;
                        const projX = width / 2 + rotatedX * scale;
                        const projY = height / 2 + rotatedY * scale;
                        
                        const pointVisible = rotatedZ > -50;
                        
                        if (j === 0) {
                            if (pointVisible) {
                                ctx.moveTo(projX, projY);
                                lastPointVisible = true;
                            }
                        } else {
                            if (pointVisible && lastPointVisible) {
                                ctx.lineTo(projX, projY);
                            } else if (pointVisible && !lastPointVisible) {
                                ctx.moveTo(projX, projY);
                            }
                        }
                        
                        lastPointVisible = pointVisible;
                    }
                    
                    ctx.stroke();
                }
                
                time += 0.5;
                updatePerformanceInfo();
                animationFrameId = requestAnimationFrame(animate);
            }
            
            animate();
            
            threeScenes['artifact-4'] = {
                cleanup: () => {
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    ctx.clearRect(0, 0, width, height);
                    canvas.dataset.initialized = '';
                }
            };
        }

        // Artifact 5: Enhanced LayeredSineWaves
        function initLayeredSineWaves() {
            const canvas = document.querySelector('#artifact-5 canvas');
            if (canvas.dataset.initialized) return;
            canvas.dataset.initialized = 'true';
            
            const ctx = canvas.getContext('2d', { willReadFrequently: false });
            const width = canvas.width;
            const height = canvas.height;
            
            let animationId;
            let time = 0;
            
            const layers = CONFIG.artifacts.sineWaves.layers;
            const points = CONFIG.artifacts.sineWaves.points;
            const waveAmplitude = 40;
            
            function draw() {
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = currentTheme === 'dark' ? '#1a1a1a' : '#F0EEE6';
                ctx.fillRect(0, 0, width, height);
                
                time += 0.01;
                
                // Draw each layer
                for (let layer = 0; layer < layers; layer++) {
                    const layerPosition = (layer / layers) * height * 0.8 + height * 0.1;
                    const layerFrequency = 0.5 + layer * 0.03;
                    const layerPhase = time * 0.2 + layer * 0.05;
                    const layerAmplitude = waveAmplitude * (0.5 + 0.5 * Math.sin(layer * 0.1 + time * 0.3));
                    
                    const baseOpacity = 0.2 + 0.6 * Math.pow(Math.sin((layer / layers) * Math.PI), 2);
                    const timeEffect = 0.2 * Math.sin(time * 0.4 + layer * 0.1);
                    const opacity = Math.min(0.9, Math.max(0.1, baseOpacity + timeEffect));
                    
                    ctx.beginPath();
                    const strokeColor = currentTheme === 'dark' ? 
                        `rgba(255, 255, 255, ${opacity})` : 
                        `rgba(50, 50, 50, ${opacity})`;
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = 0.6;
                    
                    for (let i = 0; i <= points; i++) {
                        const x = (i / points) * width;
                        
                        let y = layerPosition;
                        
                        y += layerAmplitude * Math.sin(x * 0.01 * layerFrequency + layerPhase);
                        y += layerAmplitude * 0.3 * Math.sin(x * 0.02 * layerFrequency + layerPhase * 1.5);
                        y += layerAmplitude * 0.2 * Math.sin(x * 0.04 * layerFrequency - layerPhase * 0.7);
                        y += layerAmplitude * 0.1 * Math.sin(x * 0.08 * layerFrequency + layerPhase * 2.3);
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    
                    ctx.stroke();
                }
                
                // Draw connecting lines
                for (let i = 0; i < width; i += 20) {
                    if (Math.random() < 0.4) {
                        ctx.beginPath();
                        
                        const opacity = 0.1 + 0.2 * Math.sin(i * 0.05 + time);
                        const strokeColor = currentTheme === 'dark' ? 
                            `rgba(255, 255, 255, ${opacity})` : 
                            `rgba(50, 50, 50, ${opacity})`;
                        ctx.strokeStyle = strokeColor;
                        ctx.lineWidth = 0.3;
                        
                        const startY = height * 0.1 + Math.random() * height * 0.2;
                        const endY = height * 0.7 + Math.random() * height * 0.2;
                        
                        ctx.moveTo(i, startY);
                        ctx.lineTo(i, endY);
                        ctx.stroke();
                    }
                }
                
                updatePerformanceInfo();
                animationId = requestAnimationFrame(draw);
            }
            
            draw();
            
            threeScenes['artifact-5'] = {
                cleanup: () => {
                    if (animationId) cancelAnimationFrame(animationId);
                    ctx.clearRect(0, 0, width, height);
                    canvas.dataset.initialized = '';
                }
            };
        }

        // Artifact switching
        function changeArtifact() {
            const currentElement = document.querySelector('.artifact.active');
            currentElement.classList.remove('active');
            
            // Clean up current artifact
            if (threeScenes[`artifact-${currentArtifact + 1}`] && 
                threeScenes[`artifact-${currentArtifact + 1}`].cleanup) {
                threeScenes[`artifact-${currentArtifact + 1}`].cleanup();
            }
            
            currentArtifact = (currentArtifact + 1) % artifacts.length;
            
            const nextElement = document.getElementById(`artifact-${currentArtifact + 1}`);
            nextElement.classList.add('active');
            
            // Initialize the new artifact
            setTimeout(() => {
                artifacts[currentArtifact]();
            }, 100);
        }

        // Smooth scrolling for navigation links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const target = document.getElementById(targetId);
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // Simple working project toggle function (KEEP THIS WORKING)
        function toggleProject(element) {
            // Close all other projects
            document.querySelectorAll('.project-item').forEach(item => {
                if (item !== element) {
                    item.classList.remove('open');
                }
            });
            
            // Toggle current project
            element.classList.toggle('open');
        }

        // Initialize everything
        function initialize() {
            // Hide loading screen
            const loadingScreen = document.getElementById('loadingScreen');
            setTimeout(() => {
                loadingScreen.classList.add('hidden');
            }, 1000);

            // Initialize artifacts
            initializeArtifacts();
            
            
            // Initialize enhanced mobile accessibility
            if (typeof MobileAccessibilityManager !== 'undefined') {
                window.accessibilityManager = new MobileAccessibilityManager();
                console.log('✅ Mobile accessibility manager initialized');
            }

            // Add click effects to buttons
            document.querySelectorAll('.cta-button').forEach(button => {
                button.addEventListener('click', function() {
                    this.style.transform = 'scale(0.95)';
                    setTimeout(() => {
                        this.style.transform = 'translateY(-2px)';
                    }, 100);
                });
            });
        }

        // Enhanced resize handler with debouncing
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // Update configuration for new screen size
                CONFIG.artifacts.particles.count = window.innerWidth < 768 ? 15000 : 45000;
                CONFIG.artifacts.hankies.resolution = window.innerWidth < 768 ? 16 : 32;
                CONFIG.artifacts.ascii.width = window.innerWidth < 768 ? 45 : 65;
                CONFIG.artifacts.ascii.height = window.innerWidth < 768 ? 45 : 65;
                CONFIG.artifacts.metamorphosis.numLines = window.innerWidth < 768 ? 60 : 120;
                CONFIG.artifacts.metamorphosis.lineSegments = window.innerWidth < 768 ? 90 : 180;
                CONFIG.artifacts.sineWaves.layers = window.innerWidth < 768 ? 40 : 80;
                CONFIG.artifacts.sineWaves.points = window.innerWidth < 768 ? 100 : 200;
                
                // Reinitialize current Three.js artifact on resize
                if (currentArtifact === 0 || currentArtifact === 2) {
                    if (threeScenes[`artifact-${currentArtifact + 1}`] && 
                        threeScenes[`artifact-${currentArtifact + 1}`].cleanup) {
                        threeScenes[`artifact-${currentArtifact + 1}`].cleanup();
                    }
                    setTimeout(() => {
                        artifacts[currentArtifact]();
                    }, 100);
                }
            }, 250);
        });

        // Enhanced Touch Gesture System for Mobile
        class TouchGestureManager {
            constructor() {
                this.startX = 0;
                this.startY = 0;
                this.startTime = 0;
                this.threshold = 50; // minimum swipe distance
                this.timeThreshold = 300; // maximum swipe time
                this.setupGestures();
                this.showMobileHints();
            }
            
            setupGestures() {
                const heroContainer = document.querySelector('.hero-container');
                let isDragging = false;
                
                heroContainer.addEventListener('touchstart', (e) => {
                    // Handle title/magic button taps
                    if (e.target.classList.contains('glitch-title') || e.target.classList.contains('spark-magic')) {
                        e.preventDefault();
                        changeEverything();
                        return;
                    }
                    
                    // Start gesture tracking
                    this.startX = e.touches[0].clientX;
                    this.startY = e.touches[0].clientY;
                    this.startTime = Date.now();
                    isDragging = false;
                }, { passive: false });
                
                heroContainer.addEventListener('touchmove', (e) => {
                    if (!this.startX || !this.startY) return;
                    
                    const currentX = e.touches[0].clientX;
                    const deltaX = Math.abs(currentX - this.startX);
                    
                    // Detect if user is actively swiping
                    if (deltaX > 10) {
                        isDragging = true;
                        // Add visual feedback during swipe
                        this.addSwipeVisualFeedback(currentX - this.startX);
                    }
                }, { passive: true });
                
                heroContainer.addEventListener('touchend', (e) => {
                    if (!this.startX || !this.startY) return;
                    
                    const endX = e.changedTouches[0].clientX;
                    const endY = e.changedTouches[0].clientY;
                    const endTime = Date.now();
                    
                    const deltaX = endX - this.startX;
                    const deltaY = endY - this.startY;
                    const deltaTime = endTime - this.startTime;
                    
                    // Remove any visual feedback
                    this.removeSwipeVisualFeedback();
                    
                    // Check if it's a valid swipe
                    if (Math.abs(deltaX) > Math.abs(deltaY) && 
                        Math.abs(deltaX) > this.threshold && 
                        deltaTime < this.timeThreshold &&
                        isDragging) {
                        
                        e.preventDefault();
                        
                        if (deltaX > 0) {
                            // Swipe right - previous artifact
                            this.previousArtifact();
                        } else {
                            // Swipe left - next artifact
                            this.nextArtifact();
                        }
                    }
                    
                    // Reset
                    this.startX = 0;
                    this.startY = 0;
                    this.startTime = 0;
                    isDragging = false;
                }, { passive: false });
            }
            
            nextArtifact() {
                if (!isTransitioning) {
                    changeEverything();
                    this.showSwipeSuccess('right');
                }
            }
            
            previousArtifact() {
                if (!isTransitioning) {
                    isTransitioning = true;
                    
                    // Cycle backwards through titles
                    currentTitleIndex = currentTitleIndex === 0 ? CONFIG.titles.length - 1 : currentTitleIndex - 1;
                    this.updateTitleText();
                    
                    // Cycle backwards through artifacts
                    setTimeout(() => {
                        const currentElement = document.querySelector('.artifact.active');
                        currentElement.classList.remove('active');
                        
                        if (threeScenes[`artifact-${currentArtifact + 1}`]?.cleanup) {
                            threeScenes[`artifact-${currentArtifact + 1}`].cleanup();
                        }
                        
                        currentArtifact = currentArtifact === 0 ? artifacts.length - 1 : currentArtifact - 1;
                        
                        const nextElement = document.getElementById(`artifact-${currentArtifact + 1}`);
                        nextElement.classList.add('active');
                        
                        setTimeout(() => {
                            artifacts[currentArtifact]();
                            isTransitioning = false;
                        }, 100);
                    }, CONFIG.transitions.delay);
                    
                    this.showSwipeSuccess('left');
                }
            }
            
            updateTitleText() {
                const titleElement = document.querySelector('.glitch-title');
                gsap.to(titleElement, {
                    duration: 1.2,
                    text: { value: CONFIG.titles[currentTitleIndex], delimiter: "" },
                    ease: "none"
                });
            }
            
            addSwipeVisualFeedback(deltaX) {
                const heroContainer = document.querySelector('.hero-container');
                const opacity = Math.min(Math.abs(deltaX) / 100, 0.3);
                
                if (deltaX > 0) {
                    heroContainer.style.background = `linear-gradient(90deg, rgba(102, 102, 102, ${opacity}) 0%, transparent 100%)`;
                } else {
                    heroContainer.style.background = `linear-gradient(-90deg, rgba(102, 102, 102, ${opacity}) 0%, transparent 100%)`;
                }
            }
            
            removeSwipeVisualFeedback() {
                const heroContainer = document.querySelector('.hero-container');
                heroContainer.style.background = '';
            }
            
            showSwipeSuccess(direction) {
                const indicator = document.createElement('div');
                indicator.style.cssText = `
                    position: fixed;
                    top: 50%;
                    ${direction === 'right' ? 'right: 20px;' : 'left: 20px;'}
                    transform: translateY(-50%);
                    background: rgba(102, 102, 102, 0.9);
                    color: white;
                    padding: 10px 15px;
                    border-radius: 25px;
                    font-size: 0.8rem;
                    z-index: 1002;
                    font-family: 'Roboto Mono', monospace;
                    animation: swipeSuccess 0.6s ease-out;
                `;
                indicator.textContent = direction === 'right' ? '← Previous' : 'Next →';
                document.body.appendChild(indicator);
                
                setTimeout(() => indicator.remove(), 600);
            }
            
            showMobileHints() {
                if (window.innerWidth <= 768) {
                    const hintsHTML = `
                        <div class="mobile-hints" style="
                            position: absolute;
                            bottom: 100px;
                            left: 50%;
                            transform: translateX(-50%);
                            color: rgba(51, 51, 51, 0.6);
                            font-size: 0.8rem;
                            text-align: center;
                            z-index: 10;
                            pointer-events: none;
                            animation: fadeInOut 4s ease-in-out infinite;
                        ">
                            ← Swipe to explore →<br>
                            <span style="font-size: 0.7rem;">Tap title to cycle</span>
                        </div>
                    `;
                    document.querySelector('.hero-content').insertAdjacentHTML('beforeend', hintsHTML);
                }
            }
        }
        
        // CSS animations for swipe feedback
        const swipeStyles = document.createElement('style');
        swipeStyles.textContent = `
            @keyframes swipeSuccess {
                0% { opacity: 0; transform: translateY(-50%) scale(0.8); }
                50% { opacity: 1; transform: translateY(-50%) scale(1.1); }
                100% { opacity: 0; transform: translateY(-50%) scale(1); }
            }
            
            @keyframes fadeInOut {
                0%, 100% { opacity: 0; }
                50% { opacity: 1; }
            }
            
            @media (max-width: 768px) {
                .mobile-hints {
                    display: block;
                }
            }
            
            @media (min-width: 769px) {
                .mobile-hints {
                    display: none;
                }
            }
        `;
        document.head.appendChild(swipeStyles);
        
        // Initialize gesture manager on mobile devices
        if (window.innerWidth <= 768 || 'ontouchstart' in window) {
            window.gestureManager = new TouchGestureManager();
        }

        // Initialize when page loads
        window.addEventListener('load', initialize);

        // Accessibility: Focus management
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Tab') {
                // Allow normal tab navigation
                return;
            }
            if (e.key === ' ' || e.key === 'Enter') {
                const activeElement = document.activeElement;
                if (activeElement.classList.contains('glitch-title') || 
                    activeElement.classList.contains('spark-magic')) {
                    e.preventDefault();
                    changeEverything();
                }
            }
        });

        // Performance optimization: Pause animations when page is not visible
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Page is hidden, consider pausing heavy animations
                console.log('Page hidden - animations continue for demo purposes');
            } else {
                // Page is visible again
                console.log('Page visible - all animations active');
            }
        });

        // Error boundary for global errors
        window.addEventListener('error', (e) => {
            console.warn('Global error caught:', e.error);
            // Could implement fallback here
        });

        // Service worker registration (commented out for demo)
        /*
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js').catch(console.error);
        }
        */

        // Terminal Experience Integration
        let terminalQuestionnaire = null;
        
        // Global chat variables - reuse same instance
        let globalChatUI = null;
        let globalConversationManager = null;
        let chatInitialized = false;
        
        // Global character terminal - reuse same instance
        let globalCharacterTerminal = null;
        
        // Single function to initialize character terminal
        function ensureCharacterTerminalInitialized() {
            if (globalCharacterTerminal) {
                return globalCharacterTerminal;
            }
            
            if (window.CharacterTerminal) {
                console.log('🖥️ Initializing global character terminal...');
                globalCharacterTerminal = new CharacterTerminal();
                console.log('✅ Global character terminal initialized');
                return globalCharacterTerminal;
            }
            
            console.warn('⚠️ CharacterTerminal class not available yet');
            return null;
        }
        
        // Expose globally for other scripts
        window.ensureCharacterTerminalInitialized = ensureCharacterTerminalInitialized;
        
        // Single function to initialize chat system
        function ensureChatInitialized() {
            if (chatInitialized && globalChatUI && globalConversationManager) {
                return { chatUI: globalChatUI, conversationManager: globalConversationManager };
            }
            
            if (window.ConversationManager && window.ChatUI) {
                console.log('🔧 Initializing global chat system...');
                globalChatUI = new ChatUI();
                globalConversationManager = new ConversationManager();
                
                globalChatUI.initialize();
                globalConversationManager.initialize(globalChatUI);
                globalConversationManager.loadStoredApiKey();
                
                chatInitialized = true;
                console.log('✅ Global chat system initialized');
                
                return { chatUI: globalChatUI, conversationManager: globalConversationManager };
            }
            
            console.warn('⚠️ Chat classes not available yet');
            return null;
        }

        function initializeTerminalExperience() {
            if (TerminalQuestionnaire.hasCompletedExperience()) {
                // User has already completed the experience, go directly to chat
                initializeConversation();
            } else {
                // Show terminal questionnaire
                terminalQuestionnaire = new TerminalQuestionnaire();
                terminalQuestionnaire.show();
            }
        }

        function initializeConversation() {
            // Use centralized chat initialization
            const chat = ensureChatInitialized();
            if (!chat) return;
            
            // Show the chat UI
            chat.chatUI.show();
            
            // Get user data for personalized greeting
            const userData = TerminalQuestionnaire.getUserData();
            if (userData && userData.userName) {
                // Add a personalized welcome message with safe property access
                let welcomeMessage = `Welcome back, ${userData.userName}! 🌟`;
                
                if (userData.analysis && userData.analysis.dominantTrait) {
                    welcomeMessage += ` Based on our chat, I know you're ${userData.analysis.dominantTrait}. What would you like to explore today?`;
                } else {
                    welcomeMessage += ` What would you like to explore today?`;
                }
                
                chat.chatUI.addMessage(welcomeMessage, 'assistant');
            }
        }

        // Navigation handlers
        document.addEventListener('DOMContentLoaded', function() {

            // Meet Your El button handler
            const meetYourElBtn = document.getElementById('meetYourElBtn');
            if (meetYourElBtn) {
                meetYourElBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    initializeTerminalExperience();
                });
            }
        });

        // Development helpers and shortcuts
        document.addEventListener('keydown', function(e) {
            // Reset user data (Ctrl+Shift+R)
            if (e.ctrlKey && e.shiftKey && e.key === 'R') {
                if (confirm('Reset terminal experience data? This will clear all stored user information.')) {
                    TerminalQuestionnaire.clearUserData();
                    location.reload();
                }
            }
            
            // Quick avatar test (Ctrl+Shift+T)
            if (e.ctrlKey && e.shiftKey && e.key === 'T') {
                e.preventDefault();
                showQuickAvatarTest();
            }
            
            // Quick chat reset (Ctrl+Shift+C) 
            if (e.ctrlKey && e.shiftKey && e.key === 'C') {
                e.preventDefault();
                if (confirm('Reset chat and start fresh conversation?')) {
                    resetChatExperience();
                }
            }
            
            // Debug API connection (Ctrl+Shift+D)
            if (e.ctrlKey && e.shiftKey && e.key === 'D') {
                e.preventDefault();
                debugApiConnection();
            }
        });

        function showQuickAvatarTest() {
            const testKeywords = prompt(`Quick Avatar Test - Enter keywords separated by commas:
            
Examples:
• technical, leadership, startup
• creative, innovation, design  
• collaborative, team, communication
• adventure, risk, exploration

Your keywords:`);
            
            if (!testKeywords) return;
            
            generateQuickAvatar(testKeywords);
        }

        async function generateQuickAvatar(keywords) {
            try {
                // Create mock responses based on keywords
                const mockResponses = generateMockResponses(keywords);
                
                // Initialize components if needed
                if (!window.testAnalyzer) {
                    window.testAnalyzer = new AdvancedPersonalityAnalyzer();
                    window.testAvatarService = new ClaudeAvatarService();
                    window.testAvatarDisplay = new AvatarDisplay();
                    
                    // Server-side API key handling - no client setup needed
                }
                
                // Generate personality analysis
                const personalityData = window.testAnalyzer.generatePersonalityInsights(mockResponses, 'QuickTest');
                
                // Debug: Log personality analysis results
                console.log('Personality Analysis Debug:', {
                    keywords: keywords,
                    responses: mockResponses,
                    scores: personalityData.scores,
                    archetype: personalityData.archetype.archetype.name,
                    confidence: personalityData.archetype.confidence,
                    reasoning: personalityData.archetype.reasoning
                });
                
                // API key is now handled server-side, so we can proceed directly
                
                // Show loading indicator
                showQuickLoadingIndicator();
                
                // Generate avatar with Claude
                const avatarData = await window.testAvatarService.generateAvatar(
                    personalityData,
                    { responses: mockResponses },
                    personalityData.archetype
                );
                
                // Hide loading indicator
                hideQuickLoadingIndicator();
                
                // Set the avatar for chat conversations
                window.setGeneratedAvatarForChat(avatarData);
                
                // Show avatar results
                window.testAvatarDisplay.show(avatarData, personalityData, () => {
                    console.log('Quick test avatar closed');
                });
                
            } catch (error) {
                hideQuickLoadingIndicator();
                console.error('Quick avatar test failed:', error);
                alert(`Avatar generation failed: ${error.message}`);
            }
        }

        function generateMockResponses(keywords) {
            const keywordList = keywords.toLowerCase().split(',').map(k => k.trim());
            
            // Generate responses that include the keywords naturally
            const responses = {
                question_0: `I'm a professional who works with ${keywordList.slice(0, 2).join(' and ')} in my daily role`,
                question_1: `I'm passionate about ${keywordList.slice(0, 3).join(', ')} and building solutions that incorporate these elements`,
                question_2: `I'd love to meet someone who revolutionized ${keywordList[0] || 'technology'} and discuss ${keywordList.slice(1, 3).join(' and ')}`,
                question_3: `I want to make an impact through ${keywordList.join(', ')} and help others succeed in these areas`
            };
            
            return responses;
        }

        function showQuickPersonalityResults(personalityData, keywords) {
            const archetype = personalityData.archetype.archetype;
            const message = `Quick Test Results for keywords: "${keywords}"

🎭 Archetype: ${archetype.name}
🎯 Confidence: ${Math.round(archetype.confidence * 100)}%
📊 Top Traits: ${personalityData.dominantTraits.map(t => t.trait).join(', ')}

${personalityData.personalityOverview}

To generate full Claude avatar, set up API key in the terminal experience or test suite.`;

            alert(message);
        }

        function showQuickLoadingIndicator() {
            if (document.getElementById('quickTestLoader')) return;
            
            const loader = document.createElement('div');
            loader.id = 'quickTestLoader';
            loader.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #1a1a1a;
                color: #00ff88;
                padding: 15px 25px;
                border-radius: 8px;
                font-family: 'Courier New', monospace;
                font-size: 14px;
                z-index: 10001;
                border: 2px solid #00ff88;
                box-shadow: 0 4px 12px rgba(0, 255, 136, 0.3);
            `;
            loader.innerHTML = `
                🤖 Generating Avatar...
                <div style="font-size: 12px; color: #666; margin-top: 5px;">
                    Quick Test Mode (Ctrl+Shift+T)
                </div>
            `;
            
            document.body.appendChild(loader);
        }

        function hideQuickLoadingIndicator() {
            const loader = document.getElementById('quickTestLoader');
            if (loader) {
                loader.remove();
            }
        }

        function resetChatExperience() {
            // Clear all stored data
            localStorage.removeItem('terminal_user_data');
            sessionStorage.removeItem('terminal_session');
            localStorage.removeItem('terminal_analytics');
            
            // Close any open terminals or avatars
            const existingTerminal = document.querySelector('.terminal-questionnaire');
            if (existingTerminal) {
                existingTerminal.remove();
            }
            
            const existingAvatar = document.querySelector('.avatar-display-overlay');
            if (existingAvatar) {
                existingAvatar.remove();
            }
            
            // Close any chat interfaces
            if (window.chatUI && typeof window.chatUI.hide === 'function') {
                window.chatUI.hide();
            }
            
            // Show success message
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: #00ff88;
                color: #1a1a1a;
                padding: 12px 24px;
                border-radius: 6px;
                font-family: 'Courier New', monospace;
                font-weight: bold;
                z-index: 10002;
                box-shadow: 0 4px 12px rgba(0, 255, 136, 0.3);
            `;
            notification.textContent = '✅ Chat experience reset - Ready for fresh start!';
            
            document.body.appendChild(notification);
            setTimeout(() => {
                notification.remove();
            }, 3000);
            
            console.log('Chat experience reset completed');
        }

        async function debugApiConnection() {
            if (!confirm('Test avatar generation system? This will verify the local template-based generation.')) {
                return;
            }
            
            try {
                showQuickLoadingIndicator();
                
                // Test local avatar generation instead of API
                const testService = new ClaudeAvatarService();
                const data = await testService.testConnection();
                hideQuickLoadingIndicator();
                
                if (data.success) {
                    alert(`✅ Connection Successful!

Message: ${data.message}
Model: ${data.model}
Response: ${data.response}

Your API key is working correctly!`);
                } else {
                    alert(`❌ Connection Failed

Error: ${data.error}
Details: ${data.details || 'No additional details'}

Debug Info:
${JSON.stringify(data.debug || {}, null, 2)}`);
                }
                
            } catch (error) {
                hideQuickLoadingIndicator();
                alert(`❌ Network Error: ${error.message}`);
            }
        }

        // Show keyboard shortcuts on load (development mode)
        if (window.location.hostname === 'localhost' || window.location.hostname.includes('127.0.0.1') || window.location.hostname.includes('vercel.app')) {
            setTimeout(() => {
                console.log(`
🚀 Development Shortcuts Available:
• Ctrl+Shift+R - Reset terminal experience data
• Ctrl+Shift+C - Reset chat and start fresh
• Ctrl+Shift+T - Quick avatar test with keywords (local generation)
• Ctrl+Shift+D - Test avatar generation system

Example quick test keywords:
- technical, leadership, startup
- creative, innovation, design
- collaborative, team, communication
- adventure, risk, exploration

Avatar generation now uses reliable local templates - no API needed!
                `);
            }, 2000);
        }

        // Function to set generated avatar for chat conversations
        window.setGeneratedAvatarForChat = function(avatarData) {
            try {
                // Use centralized chat initialization
                const chat = ensureChatInitialized();
                if (!chat) return;
                
                const { chatUI, conversationManager } = chat;
                
                // Set the avatar data in the Claude client
                conversationManager.client.setAvatarData(avatarData);
                
                // Update chat UI to show avatar
                chatUI.updateAvatarDisplay(avatarData);
                
                console.log(`🎭 Avatar "${avatarData.name}" is now active for chat conversations!`);
                
                // Show notification to user
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: var(--accent-color);
                    color: white;
                    padding: 12px 20px;
                    border-radius: 8px;
                    z-index: 10000;
                    font-size: 14px;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                `;
                notification.textContent = `🎭 ${avatarData.name} is ready to chat!`;
                document.body.appendChild(notification);
                
                // Fade in and out
                setTimeout(() => notification.style.opacity = '1', 100);
                setTimeout(() => {
                    notification.style.opacity = '0';
                    setTimeout(() => document.body.removeChild(notification), 300);
                }, 3000);
                
            } catch (error) {
                console.error('Failed to set avatar for chat:', error);
            }
        };

        // Load stored avatar on page load
        window.addEventListener('load', function() {
            // Use centralized chat initialization and load stored avatar
            const chat = ensureChatInitialized();
            if (chat) {
                const { conversationManager } = chat;
                if (conversationManager.client.loadStoredAvatar()) {
                    console.log('🎭 Stored avatar loaded for chat conversations');
                }
            }
        });

        // Chat circle functionality
        function initializeChatCircle() {
            const chatCircle = document.querySelector('.chat-circle');
            if (chatCircle) {
                chatCircle.addEventListener('click', function() {
                    initializeTerminalExperience();
                });
            }
        }

        // Initialize chat circle when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            initializeChatCircle();
        });
    </script>

    <!-- Trait Selector JavaScript -->
    <script>
        // Terminal interface class
        class Terminal {
            constructor() {
                this.output = document.getElementById('terminalOutput');
                this.input = document.getElementById('terminalInput');
                this.isProcessing = false;
                this.conversationHistory = [];
                this.init();
            }

            init() {
                if (!this.input) return; // Guard against missing elements
                
                this.input.addEventListener('keypress', (e) => {
                    if (e.key === 'Enter' && !this.isProcessing) {
                        this.processInput();
                    }
                });
            }

            async processInput() {
                const userInput = this.input.value.trim();
                if (!userInput) return;

                this.isProcessing = true;
                this.addToOutput(`<span class="terminal-user">elliot@localhost ~ % ${userInput}</span>`);
                this.input.value = '';
                this.showLoading();

                try {
                    // Build conversation context
                    this.conversationHistory.push({
                        role: 'user',
                        content: userInput
                    });

                    let response = await this.generateFallbackResponse(userInput);

                    this.hideLoading();
                    this.addToOutput(`<span class="terminal-ai">elliot@localhost ~ % ${response}</span>`);
                    
                    this.conversationHistory.push({
                        role: 'assistant',
                        content: response
                    });

                } catch (error) {
                    this.hideLoading();
                    this.addToOutput(`<span style="color: #ff6b6b;">ERROR: ${error.message}</span>`);
                } finally {
                    this.isProcessing = false;
                    this.addPrompt();
                }
            }

            async generateFallbackResponse(userInput) {
                await new Promise(resolve => setTimeout(resolve, 1500));
                
                const responses = [
                    "Analyzing your requirements... I see you're looking for someone with those specific qualities. What role would they be filling on your team?",
                    "Interesting combination of traits! Are you building a startup team or looking for someone for an established company?",
                    "Got it. Processing your persona requirements... Would you say this Elliot needs to be more collaborative or more independent?",
                    "Those are solid requirements. Let me know if you want me to generate a persona based on what you've described, or if you'd like to refine the traits further.",
                    "Understanding your needs... It sounds like you need someone who can balance technical skills with people skills. Anything else I should factor in?"
                ];
                
                return responses[Math.floor(Math.random() * responses.length)];
            }

            showLoading() {
                this.addToOutput(`<span class="terminal-loading">elliot@localhost ~ % Processing...</span>`);
            }

            hideLoading() {
                const loadingElements = this.output.querySelectorAll('.terminal-loading');
                loadingElements.forEach(el => el.remove());
            }

            addToOutput(html) {
                const div = document.createElement('div');
                div.innerHTML = html;
                this.output.appendChild(div);
                this.output.scrollTop = this.output.scrollHeight;
            }

            addPrompt() {
                this.addToOutput(`<span class="terminal-prompt">elliot@localhost ~ % _</span>`);
            }
        }

        // Water ASCII Animation Class
        class WaterASCII {
            constructor() {
                this.frame = 0;
                this.characters = '~≈≋⋿⊰⊱◟◝';
                this.rows = 30;
                this.cols = 60;
                this.centerPos = { x: 0.5, y: 0.5 };
                this.charactersLength = this.characters.length;
                this.charLengthDivide4 = this.charactersLength / 4;
                this.piTimes2 = Math.PI * 2;
                this.lastUpdate = 0;
                this.animationId = null;
                this.container = null;
                this.init();
            }

            init() {
                this.container = document.getElementById('asciiContent');
                if (this.container) {
                    this.startAnimation();
                }
            }

            startAnimation() {
                const animate = (currentTime) => {
                    this.lastUpdate += 16;
                    if (this.lastUpdate > 166) {
                        this.frame += 1;
                        this.generateAscii();
                        this.lastUpdate = 0;
                    }
                    this.animationId = requestAnimationFrame(animate);
                };
                this.animationId = requestAnimationFrame(animate);
            }

            stopAnimation() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
            }

            generateAscii() {
                if (!this.container) return;

                const rowsArray = [];
                const frameDiv4 = this.frame / 6.7;
                const frameDiv5 = this.frame / 8.3;
                const frameDiv8 = this.frame / 13.3;
                
                for (let y = 0; y < this.rows; y++) {
                    const yDivRows = y / this.rows;
                    const yDiv5 = y / 5;
                    const yDiv3 = y / 3;
                    let rowString = '';
                    let rowOpacity = 1;
                    
                    for (let x = 0; x < this.cols; x++) {
                        const xDivCols = x / this.cols;
                        const xDiv3 = x / 3;
                        const xDiv4 = x / 4;
                        
                        const dx = xDivCols - this.centerPos.x;
                        const dy = yDivRows - this.centerPos.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        const distTimes10 = dist * 10;
                        const distTimes5 = dist * 5;

                        const wave = Math.sin(xDiv3 + yDiv5 + frameDiv4 + distTimes10) + 
                                    Math.cos(xDiv4 - yDiv3 - frameDiv5) +
                                    Math.sin(frameDiv8 + xDivCols * this.piTimes2);

                        const charValue = (wave + 2) * this.charLengthDivide4 + distTimes5;
                        const charIndex = Math.floor(Math.abs(charValue)) % this.charactersLength;
                        
                        const opacity = Math.max(0.2, Math.min(0.8, 1 - dist + Math.sin(wave) / 3));
                        
                        if (x === 0) rowOpacity = opacity;
                        else rowOpacity = (rowOpacity + opacity) / 2;
                        
                        rowString += this.characters[charIndex];
                    }
                    
                    rowsArray.push({ text: rowString, opacity: rowOpacity });
                }

                this.container.innerHTML = rowsArray.map(row => 
                    `<div style="opacity: ${row.opacity}; margin: 0; line-height: 1;">${row.text}</div>`
                ).join('');
            }
        }

        class ElliotGenerator {
            constructor() {
                this.selectedTraits = new Set(['energy', 'collaborative']);
                this.isGenerating = false;
                this.currentElliot = null;
                this.waterAscii = null;
                this.terminal = null;
                this.init();
            }

            init() {
                // Initialize ASCII animation if container exists
                if (document.getElementById('asciiContent')) {
                    this.waterAscii = new WaterASCII();
                }
                
                // Initialize terminal if elements exist
                if (document.getElementById('terminalInput')) {
                    this.terminal = new Terminal();
                }

                // Add event listeners for trait options
                document.querySelectorAll('.trait-option').forEach(option => {
                    option.addEventListener('click', (e) => this.toggleTrait(e));
                });

                // Add event listeners for trait toggles
                document.querySelectorAll('.trait-toggle').forEach(toggle => {
                    toggle.addEventListener('click', (e) => this.toggleTraitSwitch(e));
                });

                // Add event listeners for sound bars
                document.querySelectorAll('.soundbar').forEach(bar => {
                    bar.addEventListener('click', (e) => this.toggleSoundbar(e));
                });

                // Add event listeners for action buttons
                const generateBtn = document.getElementById('generateBtn');
                const randomBtn = document.getElementById('randomBtn');
                const resetBtn = document.getElementById('resetBtn');
                const saveBtn = document.getElementById('saveBtn');

                if (generateBtn) generateBtn.addEventListener('click', () => {
                    this.triggerSoundbarPulse();
                    this.generateElliot();
                });
                if (randomBtn) randomBtn.addEventListener('click', () => {
                    this.triggerSoundbarPulse();
                    this.randomizeTraits();
                });
                if (resetBtn) resetBtn.addEventListener('click', () => {
                    this.triggerSoundbarPulse();
                    this.resetTraits();
                });
                if (saveBtn) saveBtn.addEventListener('click', () => {
                    this.triggerSoundbarPulse();
                    this.saveElliot();
                });

                // Add click handler for water ascii
                const waterAscii = document.getElementById('waterAscii');
                if (waterAscii) {
                    waterAscii.addEventListener('click', () => this.generateElliot());
                }

                // Advanced dropdown functionality
                const advancedToggle = document.getElementById('advancedToggle');
                if (advancedToggle) {
                    advancedToggle.addEventListener('click', () => this.toggleAdvancedDropdown());
                }

                // Terminal mode functionality
                const terminalModeBtn = document.getElementById('terminalModeBtn');
                const backToTraits = document.getElementById('backToTraits');
                
                if (terminalModeBtn) {
                    terminalModeBtn.addEventListener('click', () => this.enterTerminalMode());
                }
                if (backToTraits) {
                    backToTraits.addEventListener('click', () => this.exitTerminalMode());
                }

                // Keyboard shortcuts
                document.addEventListener('keydown', (e) => {
                    // Only if we're not in an input field
                    if (e.target.tagName === 'INPUT') return;
                    
                    if (e.key === 'g' || e.key === 'G') {
                        e.preventDefault();
                        this.triggerSoundbarPulse();
                        this.generateElliot();
                    } else if (e.key === 'r' || e.key === 'R') {
                        e.preventDefault();
                        this.triggerSoundbarPulse();
                        this.randomizeTraits();
                    } else if (e.key === 'Escape') {
                        e.preventDefault();
                        this.triggerSoundbarPulse();
                        this.resetTraits();
                    }
                });

                // Initialize display
                this.updateTraitDisplay();
                
                // Ensure default soundbars are properly activated
                setTimeout(() => {
                    const energyBar = document.querySelector('.soundbar[data-trait="energy"]');
                    const collabBar = document.querySelector('.soundbar[data-trait="collaborative"]');
                    if (energyBar) energyBar.classList.add('active');
                    if (collabBar) collabBar.classList.add('active');
                    this.updateTraitDisplay();
                }, 100);
            }

            toggleAdvancedDropdown() {
                const toggle = document.getElementById('advancedToggle');
                const content = document.getElementById('advancedContent');
                const grid = document.querySelector('.trait-selector-grid');
                if (!toggle || !content) return;
                
                if (content.classList.contains('show')) {
                    content.classList.remove('show');
                    toggle.textContent = '▶ Advanced';
                    if (grid) grid.classList.remove('expanded');
                } else {
                    content.classList.add('show');
                    toggle.textContent = '▼ Advanced';
                    if (grid) grid.classList.add('expanded');
                }
            }

            enterTerminalMode() {
                const panel = document.getElementById('traitPanel');
                if (panel) {
                    panel.classList.add('flipped');
                    
                    setTimeout(() => {
                        const terminalInput = document.getElementById('terminalInput');
                        if (terminalInput) terminalInput.focus();
                    }, 400);
                }
            }

            exitTerminalMode() {
                const panel = document.getElementById('traitPanel');
                if (panel) {
                    panel.classList.remove('flipped');
                }
            }

            toggleSoundbar(e) {
                const bar = e.currentTarget;
                const trait = bar.dataset.trait;
                
                if (this.selectedTraits.has(trait)) {
                    this.selectedTraits.delete(trait);
                } else {
                    this.selectedTraits.add(trait);
                }
                
                // Update corresponding UI elements
                const toggle = document.querySelector(`[data-trait="${trait}"]`);
                if (toggle && toggle.classList.contains('trait-toggle')) {
                    toggle.classList.toggle('active', this.selectedTraits.has(trait));
                }
                
                const option = document.querySelector(`[data-dimension="${trait}"]`);
                if (option) {
                    option.classList.toggle('selected', this.selectedTraits.has(trait));
                }
                
                this.updateTraitDisplay();
            }

            toggleTrait(e) {
                const option = e.currentTarget;
                const trait = option.dataset.dimension;

                if (option.classList.contains('selected')) {
                    option.classList.remove('selected');
                    this.selectedTraits.delete(trait);
                } else {
                    option.classList.add('selected');
                    this.selectedTraits.add(trait);
                }

                // Update corresponding sound bar
                const soundbar = document.querySelector(`.soundbar[data-trait="${trait}"]`);
                if (soundbar) {
                    soundbar.classList.toggle('active', this.selectedTraits.has(trait));
                }

                this.updateTraitDisplay();
            }

            toggleTraitSwitch(e) {
                const toggle = e.currentTarget;
                const trait = toggle.dataset.trait;
                
                toggle.classList.toggle('active');
                
                if (toggle.classList.contains('active')) {
                    this.selectedTraits.add(trait);
                } else {
                    this.selectedTraits.delete(trait);
                }
                
                // Update corresponding sound bar
                const soundbar = document.querySelector(`.soundbar[data-trait="${trait}"]`);
                if (soundbar) {
                    soundbar.classList.toggle('active', this.selectedTraits.has(trait));
                }
                
                // Update corresponding trait option
                const option = document.querySelector(`[data-dimension="${trait}"]`);
                if (option) {
                    option.classList.toggle('selected', this.selectedTraits.has(trait));
                }
                
                this.updateTraitDisplay();
            }

            updateTraitDisplay() {
                // Update selection count
                const count = this.selectedTraits.size;
                const selectionCount = document.querySelector('.selection-count');
                const traitCount = document.getElementById('traitCount');
                
                if (selectionCount) selectionCount.textContent = `${count}/18`;
                if (traitCount) traitCount.textContent = `${count} trait${count !== 1 ? 's' : ''}`;

                // Update sound bars based on selected traits
                const soundbars = document.querySelectorAll('.soundbar');
                soundbars.forEach(bar => {
                    const trait = bar.dataset.trait;
                    const isActive = this.selectedTraits.has(trait);
                    
                    bar.classList.toggle('active', isActive);
                    
                    // Set height based on trait and activity
                    if (isActive) {
                        const defaultHeight = getComputedStyle(bar).getPropertyValue('--default-height') || '20px';
                        bar.style.height = defaultHeight;
                        bar.style.setProperty('--bar-height', defaultHeight);
                        const pulseHeight = parseInt(defaultHeight) + 15 + 'px';
                        bar.style.setProperty('--pulse-height', pulseHeight);
                    } else {
                        bar.style.height = '8px';
                    }
                });

                const waterAscii = document.getElementById('waterAscii');
                if (waterAscii) {
                    if (count > 0) {
                        waterAscii.classList.add('active');
                    } else {
                        waterAscii.classList.remove('active');
                    }
                }

                // Trigger pulse animation for active bars
                this.triggerSoundbarPulse();

                // Update possibilities label based on trait count
                const possibilities = count > 0 ? Math.pow(2, Math.min(count, 10)) : '∞';
                const possibilitiesLabel = document.querySelector('.possibilities-label');
                if (possibilitiesLabel) {
                    possibilitiesLabel.textContent = `${possibilities} combination${possibilities !== 1 ? 's' : ''}`;
                }
            }

            triggerSoundbarPulse() {
                const soundbars = document.querySelectorAll('.soundbar.active');
                soundbars.forEach((bar, index) => {
                    setTimeout(() => {
                        bar.classList.add('pulse');
                        setTimeout(() => {
                            bar.classList.remove('pulse');
                        }, 400);
                    }, index * 30);
                });
            }

            async generateElliot() {
                if (this.isGenerating) return;

                this.isGenerating = true;
                this.showGeneratingState();

                try {
                    const elliotData = await this.generateDemoElliot();
                    this.displayElliot(elliotData);
                } catch (error) {
                    console.error('Generation failed:', error);
                    this.showError();
                } finally {
                    this.isGenerating = false;
                    this.hideGeneratingState();
                }
            }

            async generateDemoElliot() {
                await new Promise(resolve => setTimeout(resolve, 2500));

                const variants = [
                    {
                        name: "Elliot the Creator",
                        title: "Creative AI Builder",
                        description: "Builds AI with artistic flair",
                        avatar: "🎨",
                        traits: ["Creative", "Builder", "Visionary"]
                    },
                    {
                        name: "Elliot the Connector",
                        title: "Empathetic Product Lead",
                        description: "Bridges teams with understanding",
                        avatar: "🤝",
                        traits: ["Empathetic", "Leader", "Collaborator"]
                    },
                    {
                        name: "Elliot the Innovator",
                        title: "Strategic Builder",
                        description: "Architecting the future",
                        avatar: "⚡",
                        traits: ["Strategic", "Innovative", "Technical"]
                    },
                    {
                        name: "Elliot the Analyzer",
                        title: "Data-Driven Strategist",
                        description: "Turns data into decisions",
                        avatar: "🔬",
                        traits: ["Analytical", "Precise", "Methodical"]
                    },
                    {
                        name: "Elliot the Catalyst",
                        title: "High-Energy Transformer",
                        description: "Energizes teams to achieve more",
                        avatar: "🚀",
                        traits: ["Energetic", "Motivational", "Dynamic"]
                    }
                ];

                // Select based on traits if possible
                const selectedTraits = Array.from(this.selectedTraits);
                if (selectedTraits.includes('energy')) {
                    return variants[4]; // Catalyst
                } else if (selectedTraits.includes('analytical')) {
                    return variants[3]; // Analyzer
                } else if (selectedTraits.includes('innovation')) {
                    return variants[2]; // Innovator
                } else if (selectedTraits.includes('collaborative')) {
                    return variants[1]; // Connector
                } else {
                    return variants[0]; // Creator
                }
            }

            showGeneratingState() {
                // Activate all sound bars for generation
                const soundbars = document.querySelectorAll('.soundbar');
                soundbars.forEach(bar => {
                    bar.classList.add('generating');
                });
                
                // Show generation path
                const generationPath = document.getElementById('generationPath');
                if (generationPath) generationPath.classList.add('active');
                
                // Activate water ascii generating animation
                const waterAscii = document.getElementById('waterAscii');
                if (waterAscii) waterAscii.classList.add('generating');

                // Update generate button
                const btn = document.getElementById('generateBtn');
                if (btn) {
                    btn.classList.add('generating');
                    btn.innerHTML = `Generating...<div class="button-subtitle">...</div>`;
                }
            }

            hideGeneratingState() {
                // Remove generating state from sound bars
                const soundbars = document.querySelectorAll('.soundbar');
                soundbars.forEach(bar => {
                    bar.classList.remove('generating');
                });
                
                // Hide generation animations
                const generationPath = document.getElementById('generationPath');
                if (generationPath) generationPath.classList.remove('active');
                
                // Remove water ascii generating state
                const waterAscii = document.getElementById('waterAscii');
                if (waterAscii) waterAscii.classList.remove('generating');
                
                // Reset generate button
                const btn = document.getElementById('generateBtn');
                if (btn) {
                    btn.classList.remove('generating');
                    btn.innerHTML = `Generate<div class="button-subtitle">G</div>`;
                }
            }

            displayElliot(elliotData) {
                this.currentElliot = elliotData;

                // Create success pulse in sound bars
                const soundbars = document.querySelectorAll('.soundbar');
                soundbars.forEach((bar, index) => {
                    setTimeout(() => {
                        bar.style.background = 'var(--gold)';
                        setTimeout(() => {
                            bar.style.background = bar.classList.contains('active') ? 'var(--amber)' : '#ddd';
                        }, 200);
                    }, index * 50);
                });

                // Show success message in console
                console.log('Generated Elliot:', elliotData);
            }

            showError() {
                console.error('Generation failed');
            }

            randomizeTraits() {
                // Clear current selection
                document.querySelectorAll('.trait-option').forEach(option => {
                    option.classList.remove('selected');
                });
                document.querySelectorAll('.trait-toggle').forEach(toggle => {
                    toggle.classList.remove('active');
                });
                document.querySelectorAll('.soundbar').forEach(bar => {
                    bar.classList.remove('active');
                    bar.style.height = '8px';
                });
                this.selectedTraits.clear();

                // Get all available traits
                const allTraits = Array.from(document.querySelectorAll('.soundbar')).map(bar => bar.dataset.trait);
                
                // Randomly select 3-6 traits
                const count = 3 + Math.floor(Math.random() * 4);
                const selectedTraits = [];
                
                while (selectedTraits.length < count && selectedTraits.length < allTraits.length) {
                    const randomTrait = allTraits[Math.floor(Math.random() * allTraits.length)];
                    if (!selectedTraits.includes(randomTrait)) {
                        selectedTraits.push(randomTrait);
                        this.selectedTraits.add(randomTrait);
                    }
                }

                // Update UI elements for selected traits
                selectedTraits.forEach(trait => {
                    // Update sound bar
                    const soundbar = document.querySelector(`.soundbar[data-trait="${trait}"]`);
                    if (soundbar) {
                        soundbar.classList.add('active');
                    }
                    
                    // Update toggle if exists
                    const toggle = document.querySelector(`[data-trait="${trait}"]`);
                    if (toggle && toggle.classList.contains('trait-toggle')) {
                        toggle.classList.add('active');
                    }
                    
                    // Update option if exists
                    const option = document.querySelector(`[data-dimension="${trait}"]`);
                    if (option) {
                        option.classList.add('selected');
                    }
                });

                this.updateTraitDisplay();
            }

            resetTraits() {
                document.querySelectorAll('.trait-option').forEach(option => {
                    option.classList.remove('selected');
                });
                document.querySelectorAll('.trait-toggle').forEach(toggle => {
                    toggle.classList.remove('active');
                });
                document.querySelectorAll('.soundbar').forEach(bar => {
                    bar.classList.remove('active');
                    bar.style.height = '8px';
                });
                
                this.selectedTraits.clear();
                this.selectedTraits.add('energy');
                this.selectedTraits.add('collaborative');
                
                // Reset to default selections
                const energyOption = document.querySelector('[data-dimension="energy"]');
                const collabOption = document.querySelector('[data-dimension="collaborative"]');
                const energyToggle = document.querySelector('[data-trait="energy"]');
                const energyBar = document.querySelector('.soundbar[data-trait="energy"]');
                const collabBar = document.querySelector('.soundbar[data-trait="collaborative"]');
                
                if (energyOption) energyOption.classList.add('selected');
                if (collabOption) collabOption.classList.add('selected');
                if (energyToggle) energyToggle.classList.add('active');
                if (energyBar) energyBar.classList.add('active');
                if (collabBar) collabBar.classList.add('active');
                
                this.updateTraitDisplay();
            }

            saveElliot() {
                if (this.currentElliot) {
                    const data = JSON.stringify(this.currentElliot, null, 2);
                    console.log('Saved Elliot:', data);
                    
                    // Visual feedback
                    const btn = document.getElementById('saveBtn');
                    if (btn) {
                        const original = btn.innerHTML;
                        btn.innerHTML = `Saved!<div class="button-subtitle">✓</div>`;
                        setTimeout(() => {
                            btn.innerHTML = original;
                        }, 1500);
                    }

                    // Try to copy to clipboard
                    try {
                        navigator.clipboard.writeText(data);
                        console.log('Elliot data copied to clipboard');
                    } catch (err) {
                        console.log('Clipboard access not available');
                    }
                } else {
                    console.log('No Elliot to save - generate one first!');
                }
            }
        }

        // Initialize trait selector when DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            // Only initialize if trait selector elements exist
            if (document.querySelector('.trait-selector-container')) {
                new ElliotGenerator();
            }
        });
    </script>

    <!-- Chat Circle -->
    <div class="chat-circle" title="Start Chat Experience">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M8 12H16M8 8H16M8 16H13M7 4V2.5C7 2.22386 7.22386 2 7.5 2H16.5C16.7761 2 17 2.22386 17 2.5V4M7 4H17M7 4C5.89543 4 5 4.89543 5 6V18C5 19.1046 5.89543 20 7 20H17C18.1046 20 19 19.1046 19 18V6C19 4.89543 18.1046 4 17 4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </div>

    <style>
        .chat-circle {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            background: var(--accent-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            transition: all var(--transition-speed) ease;
            z-index: 1000;
            color: white;
        }

        .chat-circle:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.2);
            background: var(--text-color);
        }

        .chat-circle svg {
            transition: transform var(--transition-speed) ease;
        }

        .chat-circle:hover svg {
            transform: scale(1.1);
        }

        /* Pulse animation for attention */
        .chat-circle::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 50%;
            background: var(--accent-color);
            animation: pulse-ring 2s infinite;
            z-index: -1;
        }

        @keyframes pulse-ring {
            0% {
                transform: scale(1);
                opacity: 0.7;
            }
            70% {
                transform: scale(1.3);
                opacity: 0;
            }
            100% {
                transform: scale(1.3);
                opacity: 0;
            }
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .chat-circle {
                bottom: 20px;
                right: 20px;
                width: 60px;
                height: 60px;
                touch-action: manipulation;
                -webkit-tap-highlight-color: transparent;
            }
            
            .chat-circle svg {
                width: 28px;
                height: 28px;
            }
            
            /* Ensure better touch targets */
            .chat-circle::before {
                animation: pulse-ring 3s infinite;
            }
        }
        
        @media (max-width: 480px) {
            .chat-circle {
                bottom: 16px;
                right: 16px;
                width: 56px;
                height: 56px;
            }
        }
    </style>
    
    <!-- Main Application JavaScript -->
    <script src="js/main.js"></script>
    <script src="js/trait-selector.js"></script>
    
    <script>
        // Initialize the application after DOM is loaded
        document.addEventListener('DOMContentLoaded', () => {
            initialize();
        });
    </script>
</body>
</html>