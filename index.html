<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Elliot Lee - Portfolio</title>
    <meta name="description" content="Interactive portfolio showcasing generative art and creative coding">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/Flip.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/TextPlugin.min.js"></script>
    <link rel="stylesheet" href="css/conversation.css?v=4">
    <script src="js/conversation/claude-client.js?v=4"></script>
    <script src="js/conversation/avatar-generator.js?v=3"></script>
    <script src="js/conversation/chat-ui.js?v=5"></script>
    <script src="js/conversation/conversation-manager.js?v=4"></script>
    <script src="js/terminal-experience/DataCollector.js?v=3"></script>
    <script src="js/terminal-experience/AdvancedPersonalityAnalyzer.js?v=3"></script>
    <script src="js/terminal-experience/TemplateAvatarGenerator.js?v=3"></script>
    <script src="js/terminal-experience/ClaudeAvatarService.js?v=3"></script>
    <script src="js/terminal-experience/AvatarDisplay.js?v=3"></script>
    <script src="js/terminal-experience/CharacterTerminal.js?v=5"></script>
    <script src="js/terminal-experience/TerminalQuestionnaire.js?v=4"></script>
    <style>
        :root {
            --bg-color: #F0EEE6;
            --text-color: #333;
            --accent-color: #666;
            --nav-bg: rgba(240, 238, 230, 0.95);
            --transition-speed: 0.3s;
        }

        :root.dark {
            --bg-color: #1a1a1a;
            --text-color: #fff;
            --accent-color: #ff4444;
            --nav-bg: rgba(26, 26, 26, 0.95);
        }

        html {
            margin: 0;
            padding: 0;
            scroll-behavior: smooth;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        @import url('https://fonts.googleapis.com/css2?family=Roboto+Mono:wght@300;400;500;600;700;900&display=swap');
        @import url('https://fonts.googleapis.com/css2?family=Poppins:wght@900&display=swap');
        
        body {
            font-family: 'Roboto Mono', monospace;
            background: var(--bg-color);
            color: var(--text-color);
            overflow-x: hidden;
            transition: background var(--transition-speed) ease, color var(--transition-speed) ease;
            cursor: crosshair;
        }

        /* Loading Screen */
        .loading-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: var(--bg-color);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            transition: opacity 0.5s ease;
        }

        .loading-screen.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loader {
            font-size: 1rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 2px;
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 1; }
        }

        .hero-container {
            position: relative;
            height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg-color);
        }

        .nav-bar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 1000;
            padding: 20px 40px;
            display: flex;
            justify-content: flex-start;
            align-items: center;
            background: var(--bg-color);
            backdrop-filter: none;
            gap: 40px;
        }

        .nav-logo {
            font-size: 1.2rem;
            font-weight: 900;
            color: var(--text-color);
            text-transform: uppercase;
            letter-spacing: -1px;
            line-height: 0.8;
            transition: color var(--transition-speed) ease;
        }

        .nav-center {
            display: flex;
            align-items: center;
            gap: 30px;
        }

        .nav-item {
            color: var(--text-color);
            text-decoration: none;
            font-weight: 400;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: color var(--transition-speed);
            position: relative;
        }

        .nav-item:hover {
            color: #004225;
        }

        .nav-item:focus {
            outline: 2px solid var(--accent-color);
            outline-offset: 4px;
        }

        .artifact-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        .artifact {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            transition: opacity 0.8s ease-in-out;
        }

        .artifact.active {
            opacity: 1;
        }

        .hero-content {
            text-align: center;
            z-index: 10;
            position: relative;
            width: 100%;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .glitch-title {
            font-size: clamp(2.5rem, 6vw, 6rem);
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: #004225;
            margin-bottom: 40px;
            position: relative;
            display: inline-block;
            cursor: pointer;
            transition: all var(--transition-speed) ease;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
            font-family: 'Poppins', sans-serif;
            min-height: 1.2em;
            -webkit-text-stroke: 1px #004225;
            text-stroke: 1px #004225;
            font-stretch: ultra-expanded;
            outline: none;
            border-radius: 8px;
        }

        .glitch-title:hover,
        .glitch-title:focus {
            transform: scale(1.05);
            outline: none;
        }

        .click-hint {
            font-size: 0.8rem;
            opacity: 0.6;
            margin-top: -10px;
            margin-bottom: 20px;
            font-style: italic;
        }

        .cta-buttons {
            display: flex;
            gap: 20px;
            justify-content: center;
            margin-bottom: 40px;
            flex-wrap: wrap;
        }

        .cta-button {
            padding: 15px 40px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            text-decoration: none;
            border-radius: 50px;
            font-weight: 600;
            transition: all var(--transition-speed);
            border: none;
            cursor: pointer;
            font-size: 0.9rem;
            outline: none;
        }

        .cta-button:hover,
        .cta-button:focus {
            background: var(--accent-color);
            color: #fff;
            transform: translateY(-2px);
        }

        .cta-button:focus {
            outline: 3px solid var(--accent-color);
            outline-offset: 4px;
        }

        .spark-magic {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            font-size: 1.2rem;
            color: #000000;
            background: transparent;
            font-weight: 700;
            cursor: pointer;
            transition: transform var(--transition-speed) ease;
            padding: 15px 30px;
            border-radius: 25px;
            border: none;
            outline: none;
            align-self: flex-end;
            margin-right: 60px;
        }

        .spark-magic:hover,
        .spark-magic:focus {
            transform: scale(1.05);
            outline: none;
        }

        /* ASCII Flow Styles */
        .ascii-container {
            font-family: 'Courier New', monospace;
            line-height: 0.85;
            letter-spacing: 0.05em;
            color: rgba(51, 51, 51, 0.85);
            user-select: none;
            width: 100%;
            height: 100%;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        /* Canvas Styles */
        .canvas-container {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
        }

        .canvas-container canvas {
            max-width: 100%;
            max-height: 100%;
        }

        /* Performance indicator */
        .performance-info {
            position: fixed;
            bottom: 20px;
            left: 20px;
            font-size: 0.7rem;
            opacity: 0.5;
            z-index: 1001;
            pointer-events: none;
        }

        /* Error fallback */
        .error-fallback {
            display: flex;
            justify-content: center;
            align-items: center;
            width: 100%;
            height: 100%;
            font-size: 1.2rem;
            opacity: 0.6;
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .nav-bar {
                padding: 15px 20px;
                gap: 20px;
            }
            
            .nav-center {
                gap: 20px;
            }
            
            .nav-item {
                font-size: 0.8rem;
            }

            .glitch-title {
                font-size: clamp(2rem, 8vw, 4rem);
                margin-bottom: 30px;
            }

            .spark-magic {
                margin-right: 20px;
                font-size: 1rem;
            }

            .cta-buttons {
                flex-direction: column;
                align-items: center;
                gap: 15px;
            }

            .cta-button {
                padding: 12px 30px;
                font-size: 0.85rem;
            }

            .click-hint {
                font-size: 0.7rem;
            }
        }

        @media (max-width: 480px) {
            .nav-bar {
                padding: 10px 15px;
            }

            .nav-logo {
                font-size: 1rem;
            }

            .glitch-title {
                font-size: clamp(1.8rem, 10vw, 3rem);
            }
        }

        /* Reduced motion support */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation-duration: 0.01ms !important;
                animation-iteration-count: 1 !important;
                transition-duration: 0.01ms !important;
            }
        }

        /* High contrast mode */
        @media (prefers-contrast: high) {
            :root {
                --accent-color: #0066cc;
            }
            
            .glitch-title {
                -webkit-text-stroke: 2px #000;
                text-stroke: 2px #000;
            }
        }

        /* Projects Section */
        .projects-section {
            min-height: 100vh;
            padding: 80px 40px 40px;
            background: var(--bg-color);
            position: relative;
            z-index: 100;
        }

        .projects-header {
            margin-bottom: 60px;
        }

        .projects-title {
            font-size: 2.5rem;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: -1px;
            color: var(--text-color);
            text-align: left;
        }

        .projects-list {
            list-style: none;
            padding: 0;
            margin: 0;
            max-width: 1200px;
            margin-left: auto;
            margin-right: auto;
        }

        .project-item {
            border-top: 1px solid rgba(51, 51, 51, 0.4);
            border-bottom: 1px solid rgba(51, 51, 51, 0.4);
            cursor: pointer;
            transition: all 0.3s ease;
            list-style: none;
            margin-top: -1px;
        }

        .project-item:first-child {
            margin-top: 0;
        }

        .project-item:hover {
            background: #004225;
            color: white;
            transform: translateX(10px);
        }

        .project-item.open {
            background: transparent;
            color: var(--text-color);
        }

        .project-header {
            padding: 15px 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 400;
            font-size: 1.2rem;
        }

        .project-title {
            transition: color 0.3s ease;
            font-weight: 500;
        }

        .project-year {
            font-size: 1rem;
            opacity: 0.8;
            font-weight: 300;
        }

        .project-content {
            display: none;
            padding: 20px 10px 40px 10px;
            color: var(--text-color);
            background: transparent;
        }

        .project-item.open .project-content {
            display: block;
        }

        .project-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 60px;
        }

        .project-description {
            font-size: 0.95rem;
            line-height: 1.7;
        }

        .project-description h3 {
            font-size: 1.3rem;
            margin-bottom: 20px;
            font-weight: 600;
            color: var(--text-color);
        }

        .project-description p {
            margin-bottom: 20px;
        }

        .project-link {
            color: var(--accent-color);
            text-decoration: underline;
            font-weight: 600;
            transition: color var(--transition-speed);
        }

        .project-link:hover {
            color: #004225;
        }

        .project-gallery {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 20px;
        }

        .project-image {
            width: 100%;
            height: 150px;
            background: rgba(51, 51, 51, 0.1);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            opacity: 0.7;
            border: 1px solid rgba(51, 51, 51, 0.2);
            transition: all var(--transition-speed);
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
        }

        .project-image:hover {
            background: rgba(51, 51, 51, 0.2);
            transform: translateY(-2px);
        }

        /* When images are loaded, hide the text */
        .project-image.has-image {
            color: transparent;
        }

        /* Status badges */
        .project-status {
            display: inline-block;
            padding: 4px 12px;
            border-radius: 12px;
            font-size: 0.7rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-left: 10px;
        }

        .status-pivoted {
            background: rgba(255, 165, 0, 0.2);
            color: #ff6b35;
        }

        .status-ongoing {
            background: rgba(0, 255, 0, 0.2);
            color: #00cc44;
        }

        .status-case-study {
            background: rgba(0, 123, 255, 0.2);
            color: #007bff;
        }

        .status-award {
            background: rgba(255, 215, 0, 0.2);
            color: #ff8c00;
        }

        /* Dark theme adjustments for projects */
        :root.dark .project-item {
            border-top-color: rgba(255, 255, 255, 0.4);
            border-bottom-color: rgba(255, 255, 255, 0.4);
        }

        :root.dark .project-image {
            background: rgba(255, 255, 255, 0.1);
            border-color: rgba(255, 255, 255, 0.2);
        }

        :root.dark .project-image:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Contact Section */
        .contact-section {
            min-height: 50vh;
            padding: 80px 40px;
            background: var(--bg-color);
        }

        .contact-header {
            margin-bottom: 60px;
        }

        .contact-title {
            font-size: 2.5rem;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: -1px;
            color: var(--text-color);
            text-align: left;
        }

        .contact-buttons {
            display: flex;
            gap: 30px;
            flex-wrap: wrap;
        }

        .contact-button {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            font-size: 1.2rem;
            color: var(--text-color);
            background: transparent;
            font-weight: 700;
            cursor: pointer;
            transition: transform var(--transition-speed) ease;
            padding: 15px 30px;
            border-radius: 25px;
            border: none;
            outline: none;
            text-decoration: none;
            font-family: 'Roboto Mono', monospace;
        }

        .contact-button:hover,
        .contact-button:focus {
            transform: scale(1.05);
            outline: none;
        }

        @media (max-width: 768px) {
            .contact-section {
                padding: 60px 20px;
            }

            .contact-title {
                font-size: 2rem;
            }

            .contact-buttons {
                flex-direction: column;
                align-items: flex-start;
                gap: 20px;
            }

            .contact-button {
                font-size: 1rem;
                padding: 12px 25px;
            }

            .project-grid {
                grid-template-columns: 1fr;
                gap: 40px;
            }

            .projects-section {
                padding: 60px 20px 40px;
            }

            .projects-title {
                font-size: 2rem;
            }

            .project-header {
                padding: 12px 5px;
                font-size: 1.1rem;
            }

            .project-content {
                padding: 15px 5px 30px 5px;
            }
        }

        /* Build Your El Section */
        .build-your-el-section {
            padding: 80px 20px;
            background: var(--bg-color);
            position: relative;
        }

        .build-el-header {
            text-align: left;
            margin-bottom: 60px;
        }

        .build-el-title {
            font-size: 2.5rem;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: -1px;
            color: var(--text-color);
            margin-bottom: 16px;
        }

        .build-el-subtitle {
            font-size: 1.2rem;
            color: var(--accent-color);
            font-weight: 400;
            margin: 0;
            text-transform: none;
        }

        .build-el-container {
            max-width: 1200px;
            margin: 0 auto;
            text-align: center;
        }

        .cards-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 40px;
            margin-bottom: 60px;
        }

        .el-card {
            position: relative;
            aspect-ratio: 1;
            border: 2px solid var(--text-color);
            border-radius: 0;
            cursor: pointer;
            transition: all 0.3s ease;
            overflow: hidden;
            background: var(--bg-color);
        }

        .el-card:hover {
            transform: translateY(-8px);
            box-shadow: 0 12px 24px rgba(0, 0, 0, 0.1);
        }

        .el-card:hover .card-icon {
            opacity: 0;
        }

        .card-icon-container {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .card-icon {
            width: 80px;
            height: 80px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            z-index: 2;
            position: relative;
        }

        .discovery-icon {
            background: #fbbf24;
        }

        .matching-icon {
            background: #10b981;
        }

        .introduction-icon {
            background: #8b5cf6;
        }

        .icon-svg {
            width: 40px;
            height: 40px;
        }

        .card-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 30px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s ease;
            text-align: center;
        }

        .el-card:hover .card-overlay {
            opacity: 1;
        }

        .card-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin-bottom: 16px;
            color: white;
        }

        .card-description {
            font-size: 0.95rem;
            line-height: 1.6;
            color: rgba(255, 255, 255, 0.9);
        }

        .cta-container {
            display: flex;
            justify-content: center;
        }

        .meet-your-el-btn {
            background: var(--text-color);
            color: var(--bg-color);
            border: none;
            padding: 20px 40px;
            font-size: 1.1rem;
            font-weight: 600;
            font-family: 'Roboto Mono', monospace;
            text-transform: uppercase;
            letter-spacing: 1px;
            cursor: pointer;
            transition: all 0.3s ease;
            border-radius: 8px;
            position: relative;
            overflow: hidden;
        }

        .meet-your-el-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
        }

        .btn-content {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        /* Navigation Mobile Optimizations */
        @media (max-width: 768px) {
            .nav-bar {
                padding: 12px 20px;
            }
            
            .nav-item {
                padding: 12px 16px;
                font-size: 0.9rem;
                touch-action: manipulation;
                -webkit-tap-highlight-color: transparent;
            }
            
        }

        /* Build Your El Section Responsive */
        @media (max-width: 768px) {
            .build-your-el-section {
                padding: 60px 20px;
            }

            .build-el-header {
                margin-bottom: 40px;
            }

            .build-el-title {
                font-size: 2rem;
            }

            .build-el-subtitle {
                font-size: 1.1rem;
            }

            .cards-grid {
                grid-template-columns: 1fr;
                gap: 30px;
                margin-bottom: 40px;
            }

            .el-card {
                max-width: 350px;
                margin: 0 auto;
            }

            .card-overlay {
                padding: 20px;
            }

            .card-title {
                font-size: 1.3rem;
                margin-bottom: 12px;
            }

            .card-description {
                font-size: 0.9rem;
            }

            .meet-your-el-btn {
                padding: 16px 32px;
                font-size: 1rem;
            }
        }

        @media (max-width: 480px) {
            .card-overlay {
                opacity: 1;
                background: rgba(0, 0, 0, 0.7);
            }

            .card-icon {
                width: 60px;
                height: 60px;
            }

            .icon-svg {
                width: 30px;
                height: 30px;
            }
        }
    </style>
</head>
<body>
    <div class="loading-screen" id="loadingScreen">
        <div class="loader">Loading Experience...</div>
    </div>

    <nav class="nav-bar">
        <div class="nav-logo">
            EL
        </div>
        
        <div class="nav-center">
            <a href="#home" class="nav-item">HOME</a>
            <a href="#projects" class="nav-item">PROJECTS</a>
            <a href="#contact" class="nav-item">CONTACT</a>
        </div>
    </nav>

    <div class="hero-container" id="home">
        <!-- Artifact containers -->
        <div class="artifact-container">
            <!-- Artifact 1: HankiesInTheWind (Three.js interference patterns) -->
            <div class="artifact active" id="artifact-1"></div>
            
            <!-- Artifact 2: AsciiBinaryFlow -->
            <div class="artifact" id="artifact-2">
                <div class="ascii-container"></div>
            </div>
            
            <!-- Artifact 3: ParticleVessel (Three.js particles) -->
            <div class="artifact" id="artifact-3"></div>
            
            <!-- Artifact 4: Metamorphosis (Canvas 3D forms) -->
            <div class="artifact" id="artifact-4">
                <div class="canvas-container">
                    <canvas width="550" height="550"></canvas>
                </div>
            </div>
            
            <!-- Artifact 5: LayeredSineWaves (Canvas sine waves) -->
            <div class="artifact" id="artifact-5">
                <div class="canvas-container">
                    <canvas width="550" height="550"></canvas>
                </div>
            </div>
        </div>
        
        <div class="hero-content">
            <h1 class="glitch-title" 
                onclick="changeEverything()" 
                onkeydown="handleKeyPress(event)"
                role="button" 
                tabindex="0"
                aria-label="Click to cycle through titles and change background art">
                ELLIOT LEE
            </h1>
            
            <div class="spark-magic" 
                 onclick="changeEverything()"
                 onkeydown="handleKeyPress(event)"
                 role="button"
                 tabindex="0"
                 aria-label="Change experience">
                <span>[click me]</span>
            </div>
        </div>
    </div>

    <!-- Build Your El Section -->
    <section class="build-your-el-section" id="build-your-el">
        <div class="build-el-container">
            <!-- Section Header -->
            <div class="build-el-header">
                <h2 class="build-el-title">Create</h2>
                <p class="build-el-subtitle">Have you ever thought about making your own AI?</p>
            </div>
            
            <!-- Cards Grid -->
            <div class="cards-grid">
                <!-- Card 1: Discovery Conversation -->
                <div class="el-card" data-card="0">
                    <div class="card-icon-container">
                        <div class="card-icon discovery-icon">
                            <svg class="icon-svg" viewBox="0 0 40 40" fill="none">
                                <path d="M20 4C14.48 4 10 8.48 10 14C10 19.52 14.48 24 20 24C25.52 24 30 19.52 30 14C30 8.48 25.52 4 20 4ZM20 21C16.13 21 13 17.87 13 14C13 10.13 16.13 7 20 7C23.87 7 27 10.13 27 14C27 17.87 23.87 21 20 21Z" fill="black"/>
                                <circle cx="17" cy="12" r="1.5" fill="black"/>
                                <circle cx="23" cy="12" r="1.5" fill="black"/>
                                <path d="M16 16C16.5 17 18 18 20 18C22 18 23.5 17 24 16" stroke="black" stroke-width="1.5" stroke-linecap="round"/>
                                <path d="M12 26C12 29 15 32 20 32C25 32 28 29 28 26" stroke="black" stroke-width="2" stroke-linecap="round"/>
                            </svg>
                        </div>
                        <div class="card-overlay">
                            <h3 class="card-title">Discovery Conversation</h3>
                            <p class="card-description">Blue chats with you to understand your project needs, team dynamics, and the specific challenges you're trying to solve.</p>
                        </div>
                    </div>
                </div>

                <!-- Card 2: Persona Matching -->
                <div class="el-card" data-card="1">
                    <div class="card-icon-container">
                        <div class="card-icon matching-icon">
                            <svg class="icon-svg" viewBox="0 0 40 40" fill="none">
                                <path d="M15 6C10.58 6 7 9.58 7 14V20C7 24.42 10.58 28 15 28H16V34L22 28H25C29.42 28 33 24.42 33 20V14C33 9.58 29.42 6 25 6H15Z" fill="black"/>
                                <circle cx="15" cy="16" r="2" fill="#10b981"/>
                                <circle cx="25" cy="16" r="2" fill="#10b981"/>
                                <path d="M15 20C15 22 17 24 20 24C23 24 25 22 25 20" stroke="#10b981" stroke-width="2" stroke-linecap="round"/>
                            </svg>
                        </div>
                        <div class="card-overlay">
                            <h3 class="card-title">Persona Matching</h3>
                            <p class="card-description">Based on your conversation, we'll surface the version of Elliot that best fits your context - whether that's the strategist, builder, or creative.</p>
                        </div>
                    </div>
                </div>

                <!-- Card 3: Perfect Introduction -->
                <div class="el-card" data-card="2">
                    <div class="card-icon-container">
                        <div class="card-icon introduction-icon">
                            <svg class="icon-svg" viewBox="0 0 40 40" fill="none">
                                <path d="M20 4L22.5 14H32L24.5 20L27 30L20 24L13 30L15.5 20L8 14H17.5L20 4Z" fill="black"/>
                                <path d="M12 32H28" stroke="black" stroke-width="2" stroke-linecap="round"/>
                                <path d="M14 36H26" stroke="black" stroke-width="2" stroke-linecap="round"/>
                            </svg>
                        </div>
                        <div class="card-overlay">
                            <h3 class="card-title">Perfect Introduction</h3>
                            <p class="card-description">Get a personalized introduction to the exact Elliot you need, with relevant experience and approach tailored to your situation.</p>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Call to Action -->
            <div class="cta-container">
                <button id="meetYourElBtn" class="meet-your-el-btn">
                    <span class="btn-content">
                        <span>MEET YOUR EL</span>
                        <span>🐕</span>
                    </span>
                </button>
            </div>
        </div>
    </section>

    <section class="projects-section" id="projects">
        <div class="projects-header">
            <h2 class="projects-title">Projects</h2>
        </div>

        <ul class="projects-list">
            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">The Daoist Sage AI Agent <span class="project-status status-case-study">Case Study</span></span>
                    <span class="project-year">2025</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>AI Development & RAG Systems</h3>
                                <p>A case study on grounding AI memory using a dedicated RAG (Retrieval-Augmented Generation) system to solve challenges of hallucination and unreliable memory in AI trading agents.</p>
                                <p>The core challenge emerged from developing an AI crypto trading agent where memory issues and hallucination severely limited reliability. AI hallucination causes confident generation of factually incorrect information, while fickle memory creates inability to recall crucial details from knowledge bases or maintain coherent context.</p>
                                <p>The solution involved building a Daoist Sage Agent using RAG as its foundational memory and accuracy mechanism. As Product Manager and Lead Developer, I handled the full process from ideation to conceptual deployment.</p>
                                <p>The future vision includes processing complex internal documentation and providing specialized, fact-checked assistance in regulated industries where precision and verifiability are crucial.</p>
                                <p><a href="https://github.com/el-fuegoso/daobot" class="project-link" target="_blank" rel="noopener noreferrer">▶ View Code</a></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/daobot/agent-interface.jpg')">Agent Interface</div>
                                <div class="project-image" style="background-image: url('./images/daobot/rag-architecture.jpg')">RAG Architecture</div>
                                <div class="project-image" style="background-image: url('./images/daobot/memory-system.jpg')">Memory System</div>
                                <div class="project-image" style="background-image: url('./images/daobot/testing-results.jpg')">Testing Results</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>

            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">Eliza Trading Agent <span class="project-status status-pivoted">Pivoted</span></span>
                    <span class="project-year">2025</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>AI-Powered Memecoin Trading</h3>
                                <p>An attempt to develop an AI-powered memecoin trading bot to capitalize on Solana's volatility while managing risk.</p>
                                <p>The approach involved training Mistral 7B on Pump.fun launch patterns combined with Twitter sentiment analysis. Integration with 3Commas API as a provider allowed testing of hybrid DEX/CEX strategy through paper trading on the 3Commas platform.</p>
                                <p>The outcome was clear: the system was inconsistent and kept hallucinating on the signals being fed to it. The project was pivoted due to inability to achieve reliable trading consistency.</p>
                                <p>This failure led to valuable insights about AI reliability in financial applications and directly informed the development of the Daoist Sage Agent with its focus on grounded memory systems.</p>
                                <p><em>Project documentation available upon request</em></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/eliza/eliza-banner.jpg')">Eliza Banner</div>
                                <div class="project-image" style="background-image: url('./images/eliza/trading-interface.jpg')">Trading Interface</div>
                                <div class="project-image" style="background-image: url('./images/eliza/performance-metrics.jpg')">Performance Metrics</div>
                                <div class="project-image" style="background-image: url('./images/eliza/lessons-learned.jpg')">Lessons Learned</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>

            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">Kaiawhina Auckland</span>
                    <span class="project-year">2023 – 2024</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>Activism & Social Justice</h3>
                                <p>In 2023, as global calls for a Free Palestine grew louder, I realized my skills and privilege needed redirecting. Joining Kaiawhina Auckland, I committed to honoring Māori sovereignty, supporting Palestinian freedom, and advancing climate justice.</p>
                                <p>The work involves weekly marshal duties for activations, disrupting "business as usual" at corporate complicity sites, and learning that actions matter more than hashtags. The experience taught crucial lessons: data is power (using Signal to track police or counter protestors movements at demonstrations), access is activism (always providing wheelchair routes and live captions), and joy is resistance (singing waiata at 5am blockades).</p>
                                <p>This work reinforced that technology doesn't exist in a vacuum and provided hands-on experience in using tech skills for social justice organizing.</p>
                                <p><a href="https://www.instagram.com/kaiawhina_tamaki/" class="project-link" target="_blank" rel="noopener noreferrer">▶ Learn About Kaiawhina</a></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/kaiawhina/demonstration-photography.jpg')">Demonstration Photography</div>
                                <div class="project-image" style="background-image: url('./images/kaiawhina/community-organizing.jpg')">Community Organizing</div>
                                <div class="project-image" style="background-image: url('./images/kaiawhina/marshall-training.jpg')">Marshall Training</div>
                                <div class="project-image" style="background-image: url('./images/kaiawhina/solidarity-actions.jpg')">Solidarity Actions</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>

            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">Drama School 202: The Illusion</span>
                    <span class="project-year">2023</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>Black Box Theatre Performance</h3>
                                <p>A reimagining of Tony Kushner's baroque meta-theatrical fantasy as a contemporary meditation on love, artifice, and the transformative power of storytelling under director Leo Gene Peters.</p>
                                <p>Our approach centered on staging the unreal by building a 1:1 cave to bring the audience into the world. We performed costume quick-changes in full view to highlight theatrical artifice and projected text fragments from Kushner's stage directions onto actors' bodies. The production challenged actors to master 17th-century verse while finding modern emotional truth.</p>
                                <p>As Theogenes - The Lover, I connected with the verbs that brought the character to life and genuinely fell in love on stage. I also taught yoga to the company every other day, helping connect with breath and body.</p>
                                <p><em>Performance archived in personal collection</em></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/drama/performance-photography.jpg')">Performance Photography</div>
                                <div class="project-image" style="background-image: url('./images/drama/behind-the-scenes.jpg')">Behind-the-Scenes</div>
                                <div class="project-image" style="background-image: url('./images/drama/cast-images.jpg')">Cast Images</div>
                                <div class="project-image" style="background-image: url('./images/drama/set-design.jpg')">Set Design</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>

            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">Vipassana Journey <span class="project-status status-ongoing">Ongoing</span></span>
                    <span class="project-year">2022 – Present</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>Personal Practice & Mindfulness</h3>
                                <p>After burning out from building startups, I needed something no algorithm could provide. A way to sit with myself.</p>
                                <p>The practice involves 10 day silent retreats completed at Dhamma Medini, NZ, with an intention of twice daily meditation sits. The approach eschews apps and hacks in favor of just the breath, the body, and whatever arises.</p>
                                <p>The key insight: "It's not about achieving some perfect mental state, it's about seeing what's already there." This ongoing practice provides grounding and perspective that informs all other work.</p>
                                <p>This foundation of mindfulness and presence has become integral to my approach to technology, bringing intention and awareness to how I build and interact with digital systems.</p>
                                <p><a href="https://www.dhamma.org/en/index" class="project-link" target="_blank" rel="noopener noreferrer">▶ Learn More</a></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/vipassana/retreat-photography.jpg')">Retreat Photography</div>
                                <div class="project-image" style="background-image: url('./images/vipassana/meditation-hall.jpg')">Meditation Hall</div>
                                <div class="project-image" style="background-image: url('./images/vipassana/dhamma-medini.jpg')">Dhamma Medini</div>
                                <div class="project-image" style="background-image: url('./images/vipassana/silent-reflection.jpg')">Silent Reflection</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>

            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">Talent Army <span class="project-status status-award">Award Winner</span></span>
                    <span class="project-year">2022</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>Best UX Design, NZ Tech Innovation | Psychoactive</h3>
                                <p>A reimagining of tech recruitment as a dynamic growth journey, replacing sterile job boards with living stories of career transformation.</p>
                                <p>The narrative-driven web experience featured claymation-style 3D animations, spontaneous "Easter egg" movements, and visual storytelling for both employers and candidates. The intelligent job board included custom API syncing between Webflow and JobAdder in real-time, JetBoost filtering that felt like Tinder for dream jobs, and Kiwi-tech coded icons replacing generic briefcase symbols.</p>
                                <p>As Account Manager, I won the pitch against 4 agencies by demonstrating how storytelling reduces candidate drop-off. As Conductor, I managed 6 specialists across 3 timezones, and as Bridge Builder, I translated recruiter pain points into playful interactions.</p>
                                <p>The project was shortlisted for 2023 Webby Awards and became Talent Army's flagship client acquisition tool.</p>
                                <p><a href="https://www.talent.army/" class="project-link" target="_blank" rel="noopener noreferrer">▶ View Live Site</a></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/talent-army/homepage-design.jpg')">Homepage Design</div>
                                <div class="project-image" style="background-image: url('./images/talent-army/job-board-interface.jpg')">Job Board Interface</div>
                                <div class="project-image" style="background-image: url('./images/talent-army/3d-animation-examples.jpg')">3D Animation Examples</div>
                                <div class="project-image" style="background-image: url('./images/talent-army/awards-recognition.jpg')">Awards Recognition</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>

            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">Blackbird VC</span>
                    <span class="project-year">2022</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>Australia | Psychoactive</h3>
                                <p>Blackbird VC needed a digital presence as bold as their investments. One that would make founders feel seen, not just pitched to.</p>
                                <p>We abandoned the tired "suits shaking hands" aesthetic and built an electric visual language featuring handmade documentary photography of real founders and bespoke animations mimicking startup momentum. The functional artistry organized content like a gallery with no buried decks, and interactive founder stories triggered by scroll velocity.</p>
                                <p>My role as Deal Maker involved working with the development team and Blackbird to envision a website that was both achievable and visually stunning, creating a rebellion against traditional VC digital clichés.</p>
                                <p><a href="https://www.blackbird.vc/home-hub" class="project-link" target="_blank" rel="noopener noreferrer">▶ View Project</a></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/blackbird/homepage-design.jpg')">Homepage Design</div>
                                <div class="project-image" style="background-image: url('./images/blackbird/portfolio-layout.jpg')">Portfolio Layout</div>
                                <div class="project-image" style="background-image: url('./images/blackbird/founder-stories-interface.jpg')">Founder Stories Interface</div>
                                <div class="project-image" style="background-image: url('./images/blackbird/interactive-elements.jpg')">Interactive Elements</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>

            <li class="project-item" onclick="toggleProject(this)">
                <div class="project-header">
                    <span class="project-title">121 Festival</span>
                    <span class="project-year">2021</span>
                </div>
                <div class="project-details">
                    <div class="project-content">
                        <div class="project-grid">
                            <div class="project-description">
                                <h3>Entertainment Technology | Psychoactive</h3>
                                <p>Wellington's legendary Club 121 needed a website that could bottle their underground energy and pour it across screens nationwide. A digital mainstage for their debut festival.</p>
                                <p>The project featured psychedelic Kiwi immersion with native flora and fauna illustrations pulsing to ambient basslines, hover-triggered soundwave animations, and lineup reveals that felt like uncovering secret set times at the venue. The technical backbone included an Airtable/Zapier CMS allowing real-time vendor applications and volunteer coordination.</p>
                                <p>As Project Manager, I pitched the "digital doof" concept after attending 3 club nights for research. As Systems Architect, I streamlined 14 stakeholder workflows into one unified backend while balancing festival chaos with UX clarity.</p>
                                <p><em>Festival concluded - site archived</em></p>
                            </div>
                            <div class="project-gallery">
                                <div class="project-image" style="background-image: url('./images/121-festival/homepage-design.jpg')">Homepage Design</div>
                                <div class="project-image" style="background-image: url('./images/121-festival/content-management-interface.jpg')">Content Management Interface</div>
                                <div class="project-image" style="background-image: url('./images/121-festival/interactive-elements.jpg')">Interactive Elements</div>
                                <div class="project-image" style="background-image: url('./images/121-festival/festival-branding.jpg')">Festival Branding</div>
                            </div>
                        </div>
                    </div>
                </div>
            </li>
        </ul>
    </section>

    <section class="contact-section" id="contact">
        <div class="contact-header">
            <h2 class="contact-title">Contact</h2>
        </div>
        
        <div class="contact-buttons">
            <a href="https://www.linkedin.com/in/elliot-james-lee" class="contact-button" target="_blank" rel="noopener noreferrer">
                <span>LinkedIn</span>
            </a>
            <a href="mailto:elliotjameslee8@gmail.com" class="contact-button">
                <span>Email</span>
            </a>
            <a href="https://www.instagram.com/elliot.james.lee/" class="contact-button" target="_blank" rel="noopener noreferrer">
                <span>Instagram</span>
            </a>
        </div>
    </section>

    <div class="performance-info" id="performanceInfo">
        Performance: Optimized
    </div>

    <script>
        // Configuration object
        const CONFIG = {
            artifacts: {
                hankies: { 
                    resolution: window.innerWidth < 768 ? 16 : 32, 
                    animationSpeed: 0.0013 
                },
                particles: { 
                    count: window.innerWidth < 768 ? 15000 : 45000, 
                    opacity: 0.4 
                },
                ascii: {
                    width: window.innerWidth < 768 ? 45 : 65,
                    height: window.innerWidth < 768 ? 45 : 65
                },
                metamorphosis: {
                    numLines: window.innerWidth < 768 ? 60 : 120,
                    lineSegments: window.innerWidth < 768 ? 90 : 180
                },
                sineWaves: {
                    layers: window.innerWidth < 768 ? 40 : 80,
                    points: window.innerWidth < 768 ? 100 : 200
                }
            },
            transitions: { duration: 1200, delay: 150 },
            titles: ["ELLIOT LEE", "PRODUCT MANAGER", "BUILDER", "ACCOUNT MANAGER", "HUMAN"]
        };

        // Performance monitoring configuration
        const PERFORMANCE_CONFIG = {
            battery: {
                lowThreshold: 0.2,
                criticalThreshold: 0.1
            },
            thermal: {
                throttleTemp: 45, // Celsius
                shutdownTemp: 55
            },
            network: {
                slowConnection: ['slow-2g', '2g'],
                fastConnection: ['4g', '5g']
            },
            performance: {
                targetFPS: 60,
                minFPS: 30
            }
        };

        // Mobile Performance Manager
        class MobilePerformanceManager {
            constructor() {
                this.isLowPower = false;
                this.isCriticalMode = false;
                this.currentFPS = 60;
                this.frameCount = 0;
                this.lastFPSUpdate = Date.now();
                this.originalConfig = this.backupConfig();
                this.setupMonitoring();
            }
            
            backupConfig() {
                return JSON.parse(JSON.stringify(CONFIG.artifacts));
            }
            
            async setupMonitoring() {
                // Battery API monitoring
                if ('getBattery' in navigator) {
                    try {
                        const battery = await navigator.getBattery();
                        this.monitorBattery(battery);
                    } catch (e) {
                        console.log('Battery API not available');
                    }
                }
                
                // Network connection monitoring
                if ('connection' in navigator) {
                    this.monitorConnection();
                }
                
                // Frame rate monitoring
                this.startFPSMonitoring();
                
                // Visibility change optimization
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        this.pauseHeavyAnimations();
                    } else {
                        this.resumeAnimations();
                    }
                });
                
                // Device memory monitoring (if available)
                if ('deviceMemory' in navigator && navigator.deviceMemory < 4) {
                    this.enableLowMemoryMode();
                }
            }
            
            monitorBattery(battery) {
                const checkBattery = () => {
                    const batteryInfo = {
                        level: battery.level,
                        charging: battery.charging,
                        chargingTime: battery.chargingTime,
                        dischargingTime: battery.dischargingTime
                    };
                    
                    if (battery.level < PERFORMANCE_CONFIG.battery.criticalThreshold) {
                        this.enableCriticalMode(batteryInfo);
                    } else if (battery.level < PERFORMANCE_CONFIG.battery.lowThreshold) {
                        this.enableLowPowerMode(batteryInfo);
                    } else if (!battery.charging && this.isLowPower) {
                        // Only disable low power if we're not charging and battery is good
                        this.disableLowPowerMode();
                    }
                };
                
                battery.addEventListener('levelchange', checkBattery);
                battery.addEventListener('chargingchange', checkBattery);
                checkBattery();
            }
            
            monitorConnection() {
                const connection = navigator.connection;
                const checkConnection = () => {
                    if (PERFORMANCE_CONFIG.network.slowConnection.includes(connection.effectiveType)) {
                        this.enableLowBandwidthMode();
                    } else if (PERFORMANCE_CONFIG.network.fastConnection.includes(connection.effectiveType)) {
                        this.disableLowBandwidthMode();
                    }
                };
                
                connection.addEventListener('change', checkConnection);
                checkConnection();
            }
            
            startFPSMonitoring() {
                const measureFPS = () => {
                    this.frameCount++;
                    const now = Date.now();
                    
                    if (now - this.lastFPSUpdate >= 1000) {
                        this.currentFPS = this.frameCount;
                        this.frameCount = 0;
                        this.lastFPSUpdate = now;
                        
                        // Adjust performance based on FPS
                        if (this.currentFPS < PERFORMANCE_CONFIG.performance.minFPS && !this.isLowPower) {
                            this.enablePerformanceMode();
                        }
                        
                        this.updatePerformanceIndicator();
                    }
                    
                    requestAnimationFrame(measureFPS);
                };
                measureFPS();
            }
            
            enableLowPowerMode(batteryInfo = null) {
                if (this.isLowPower) return;
                this.isLowPower = true;
                
                // Reduce particle counts by 75%
                CONFIG.artifacts.particles.count = Math.floor(this.originalConfig.particles.count * 0.25);
                CONFIG.artifacts.hankies.resolution = Math.floor(this.originalConfig.hankies.resolution * 0.5);
                CONFIG.artifacts.ascii.width = Math.floor(this.originalConfig.ascii.width * 0.7);
                CONFIG.artifacts.ascii.height = Math.floor(this.originalConfig.ascii.height * 0.7);
                CONFIG.artifacts.metamorphosis.numLines = Math.floor(this.originalConfig.metamorphosis.numLines * 0.5);
                CONFIG.artifacts.metamorphosis.lineSegments = Math.floor(this.originalConfig.metamorphosis.lineSegments * 0.5);
                CONFIG.artifacts.sineWaves.layers = Math.floor(this.originalConfig.sineWaves.layers * 0.5);
                CONFIG.artifacts.sineWaves.points = Math.floor(this.originalConfig.sineWaves.points * 0.5);
                
                // Reduce animation speeds
                CONFIG.artifacts.hankies.animationSpeed *= 0.5;
                
                // Show low power indicator
                const message = batteryInfo ? 
                    `Low Power Mode: ${Math.round(batteryInfo.level * 100)}% battery` : 
                    'Low Power Mode Active';
                this.showPowerModeIndicator(message, '#ff9500');
                
                // Restart current artifact with new settings
                this.restartCurrentArtifact();
                
                console.log('Low power mode enabled', batteryInfo);
            }
            
            enableCriticalMode(batteryInfo) {
                if (this.isCriticalMode) return;
                this.isCriticalMode = true;
                this.isLowPower = true;
                
                // Stop all animations except essential UI
                this.pauseAllArtifacts();
                this.showPowerModeIndicator(
                    `Critical Battery: ${Math.round(batteryInfo.level * 100)}% - Animations Paused`, 
                    '#ff3300'
                );
                console.log('Critical battery mode enabled', batteryInfo);
            }
            
            enablePerformanceMode() {
                // Automatically reduce settings when FPS drops
                CONFIG.artifacts.particles.count = Math.floor(CONFIG.artifacts.particles.count * 0.8);
                CONFIG.artifacts.hankies.resolution = Math.max(8, Math.floor(CONFIG.artifacts.hankies.resolution * 0.8));
                
                this.showPowerModeIndicator(`Performance Mode: ${this.currentFPS}fps`, '#ffa500');
                this.restartCurrentArtifact();
            }
            
            enableLowMemoryMode() {
                CONFIG.artifacts.particles.count = Math.floor(CONFIG.artifacts.particles.count * 0.6);
                CONFIG.artifacts.ascii.width = Math.floor(CONFIG.artifacts.ascii.width * 0.8);
                CONFIG.artifacts.ascii.height = Math.floor(CONFIG.artifacts.ascii.height * 0.8);
                
                this.showPowerModeIndicator('Low Memory Mode', '#ff6600');
                console.log('Low memory mode enabled');
            }
            
            enableLowBandwidthMode() {
                // Reduce update frequencies for network-dependent features
                CONFIG.transitions.duration = Math.min(CONFIG.transitions.duration * 1.5, 2000);
                this.showPowerModeIndicator('Slow Connection Detected', '#666666');
            }
            
            disableLowPowerMode() {
                if (!this.isLowPower) return;
                this.isLowPower = false;
                this.isCriticalMode = false;
                
                // Restore original settings
                CONFIG.artifacts = JSON.parse(JSON.stringify(this.originalConfig));
                
                this.hidePowerModeIndicator();
                this.restartCurrentArtifact();
                console.log('Low power mode disabled');
            }
            
            disableLowBandwidthMode() {
                CONFIG.transitions.duration = 1200; // Reset to default
            }
            
            pauseHeavyAnimations() {
                // Pause current artifact animations
                if (window.currentArtifactAnimation) {
                    cancelAnimationFrame(window.currentArtifactAnimation);
                }
                
                // Pause Three.js rendering
                Object.values(threeScenes).forEach(scene => {
                    if (scene.renderer && scene.renderer.setAnimationLoop) {
                        scene.renderer.setAnimationLoop(null);
                    }
                });
            }
            
            pauseAllArtifacts() {
                this.pauseHeavyAnimations();
                // Set black background to save energy
                document.body.style.background = '#000000';
            }
            
            resumeAnimations() {
                if (!this.isCriticalMode && !document.hidden) {
                    // Restart current artifact if not in critical mode
                    if (typeof artifacts !== 'undefined' && artifacts[currentArtifact]) {
                        artifacts[currentArtifact]();
                    }
                    
                    // Restore background
                    document.body.style.background = '';
                }
            }
            
            restartCurrentArtifact() {
                if (this.isCriticalMode) return;
                
                // Clean up current artifact
                if (threeScenes[`artifact-${currentArtifact + 1}`]?.cleanup) {
                    threeScenes[`artifact-${currentArtifact + 1}`].cleanup();
                }
                
                // Restart with new settings
                setTimeout(() => {
                    if (artifacts[currentArtifact]) {
                        artifacts[currentArtifact]();
                    }
                }, 100);
            }
            
            showPowerModeIndicator(message, color = '#ff9500') {
                let indicator = document.getElementById('powerModeIndicator');
                if (!indicator) {
                    indicator = document.createElement('div');
                    indicator.id = 'powerModeIndicator';
                    indicator.style.cssText = `
                        position: fixed;
                        top: 80px;
                        right: 20px;
                        background: ${color};
                        color: white;
                        padding: 8px 12px;
                        border-radius: 4px;
                        font-size: 12px;
                        z-index: 1002;
                        font-family: 'Roboto Mono', monospace;
                        max-width: 200px;
                        text-align: center;
                        animation: slideInRight 0.3s ease-out;
                    `;
                    document.body.appendChild(indicator);
                    
                    // Add animation
                    const style = document.createElement('style');
                    style.textContent = `
                        @keyframes slideInRight {
                            from { transform: translateX(100%); opacity: 0; }
                            to { transform: translateX(0); opacity: 1; }
                        }
                    `;
                    document.head.appendChild(style);
                } else {
                    indicator.style.background = color;
                }
                indicator.textContent = message;
            }
            
            hidePowerModeIndicator() {
                const indicator = document.getElementById('powerModeIndicator');
                if (indicator) {
                    indicator.style.animation = 'slideInRight 0.3s ease-out reverse';
                    setTimeout(() => indicator.remove(), 300);
                }
            }
            
            updatePerformanceIndicator() {
                const perfInfo = document.getElementById('performanceInfo');
                if (perfInfo) {
                    let status = 'Optimized';
                    let color = '#00ff00';
                    
                    if (this.isCriticalMode) {
                        status = 'Critical Battery';
                        color = '#ff3300';
                    } else if (this.isLowPower) {
                        status = 'Low Power';
                        color = '#ff9500';
                    } else if (this.currentFPS < PERFORMANCE_CONFIG.performance.minFPS) {
                        status = `${this.currentFPS}fps`;
                        color = '#ffa500';
                    }
                    
                    perfInfo.textContent = `Performance: ${status}`;
                    perfInfo.style.color = color;
                }
            }
        }

        // Enhanced Mobile Accessibility Manager
        class MobileAccessibilityManager {
            constructor() {
                this.setupMobileA11y();
                this.setupScreenReaderSupport();
                this.setupVoiceOverSupport();
                this.setupTalkBackSupport();
                this.addLiveRegions();
            }
            
            setupMobileA11y() {
                // Enhanced focus management for mobile
                document.addEventListener('focusin', (e) => {
                    const target = e.target;
                    
                    // Ensure focused element is visible on mobile
                    if (target.classList.contains('glitch-title') || 
                        target.classList.contains('spark-magic') ||
                        target.classList.contains('chat-control-btn')) {
                        target.scrollIntoView({ 
                            behavior: 'smooth', 
                            block: 'center',
                            inline: 'nearest'
                        });
                    }
                    
                    // Add focus announcement for screen readers
                    if (target.hasAttribute('aria-label')) {
                        this.announceToScreenReader(`Focused: ${target.getAttribute('aria-label')}`);
                    }
                });
                
                // Enhanced keyboard navigation
                document.addEventListener('keydown', (e) => {
                    // Handle escape key to close modals
                    if (e.key === 'Escape') {
                        this.handleEscapeKey();
                    }
                    
                    // Handle arrow keys for artifact navigation
                    if (e.key === 'ArrowLeft' || e.key === 'ArrowRight') {
                        const activeElement = document.activeElement;
                        if (activeElement.classList.contains('glitch-title') || 
                            activeElement.classList.contains('spark-magic')) {
                            e.preventDefault();
                            
                            if (e.key === 'ArrowRight') {
                                changeEverything();
                                this.announceToScreenReader('Next experience loaded');
                            } else if (window.gestureManager?.previousArtifact) {
                                window.gestureManager.previousArtifact();
                                this.announceToScreenReader('Previous experience loaded');
                            }
                        }
                    }
                });
            }
            
            addLiveRegions() {
                // Create ARIA live region for dynamic announcements
                const liveRegion = document.createElement('div');
                liveRegion.setAttribute('aria-live', 'polite');
                liveRegion.setAttribute('aria-atomic', 'true');
                liveRegion.setAttribute('id', 'liveRegion');
                liveRegion.className = 'sr-only';
                liveRegion.style.cssText = `
                    position: absolute;
                    width: 1px;
                    height: 1px;
                    padding: 0;
                    margin: -1px;
                    overflow: hidden;
                    clip: rect(0, 0, 0, 0);
                    white-space: nowrap;
                    border: 0;
                `;
                document.body.appendChild(liveRegion);
                
                // Create assertive live region for urgent announcements
                const assertiveRegion = document.createElement('div');
                assertiveRegion.setAttribute('aria-live', 'assertive');
                assertiveRegion.setAttribute('aria-atomic', 'true');
                assertiveRegion.setAttribute('id', 'assertiveRegion');
                assertiveRegion.className = 'sr-only';
                assertiveRegion.style.cssText = liveRegion.style.cssText;
                document.body.appendChild(assertiveRegion);
            }
            
            setupScreenReaderSupport() {
                // Enhance artifact change announcements
                const originalChangeEverything = window.changeEverything;
                window.changeEverything = () => {
                    originalChangeEverything.call(window);
                    
                    setTimeout(() => {
                        const currentTitle = CONFIG.titles[currentTitleIndex];
                        const experienceNumber = currentArtifact + 1;
                        this.announceToScreenReader(
                            `Now showing experience ${experienceNumber}: ${currentTitle} with interactive artwork`
                        );
                    }, 500);
                };
                
                // Add landmarks and structure
                this.addLandmarkRoles();
                this.enhanceFormAccessibility();
            }
            
            addLandmarkRoles() {
                // Add main landmark
                const heroContainer = document.querySelector('.hero-container');
                if (heroContainer) {
                    heroContainer.setAttribute('role', 'main');
                    heroContainer.setAttribute('aria-label', 'Portfolio showcase with interactive art');
                }
                
                // Add navigation landmark
                const navBar = document.querySelector('.nav-bar');
                if (navBar) {
                    navBar.setAttribute('role', 'navigation');
                    navBar.setAttribute('aria-label', 'Main navigation');
                }
                
                // Add complementary landmarks for sections
                const contactSection = document.querySelector('.contact-section');
                if (contactSection) {
                    contactSection.setAttribute('role', 'complementary');
                    contactSection.setAttribute('aria-label', 'Contact information');
                }
                
                const projectsSection = document.querySelector('.projects-section');
                if (projectsSection) {
                    projectsSection.setAttribute('role', 'region');
                    projectsSection.setAttribute('aria-label', 'Featured projects');
                }
            }
            
            enhanceFormAccessibility() {
                // Enhance chat input
                const messageInput = document.getElementById('messageInput');
                if (messageInput) {
                    messageInput.setAttribute('aria-describedby', 'messageInputDesc');
                    
                    const description = document.createElement('div');
                    description.id = 'messageInputDesc';
                    description.className = 'sr-only';
                    description.textContent = 'Type your message and press Enter to send';
                    messageInput.parentNode.insertBefore(description, messageInput);
                }
                
                // Enhance project items
                document.querySelectorAll('.project-item').forEach((item, index) => {
                    item.setAttribute('role', 'button');
                    item.setAttribute('aria-expanded', 'false');
                    item.setAttribute('aria-describedby', `project-desc-${index}`);
                    item.setAttribute('tabindex', '0');
                    
                    const originalToggle = item.onclick;
                    item.onclick = function() {
                        originalToggle.call(this);
                        const isOpen = this.classList.contains('open');
                        this.setAttribute('aria-expanded', isOpen.toString());
                        
                        const action = isOpen ? 'expanded' : 'collapsed';
                        window.accessibilityManager.announceToScreenReader(
                            `Project ${this.querySelector('.project-header').textContent} ${action}`
                        );
                    };
                    
                    // Add keyboard support
                    item.addEventListener('keydown', (e) => {
                        if (e.key === ' ' || e.key === 'Enter') {
                            e.preventDefault();
                            item.click();
                        }
                    });
                });
            }
            
            setupVoiceOverSupport() {
                // Enhanced VoiceOver navigation for iOS
                document.querySelector('.glitch-title').setAttribute(
                    'aria-description', 
                    'Interactive title that cycles through different professional identities and changes the background artwork. Swipe or use arrow keys to navigate.'
                );
                
                document.querySelector('.spark-magic').setAttribute(
                    'aria-description',
                    'Alternative control to cycle through visual experiences'
                );
                
                // Add VoiceOver-specific hint text
                if (this.isIOSDevice()) {
                    const voiceOverHints = document.createElement('div');
                    voiceOverHints.className = 'sr-only';
                    voiceOverHints.textContent = 'VoiceOver users: Use flick gestures to navigate between elements, and double-tap to activate. Swipe left or right on the main area to change experiences.';
                    document.body.appendChild(voiceOverHints);
                }
            }
            
            setupTalkBackSupport() {
                // Enhanced TalkBack support for Android
                if (this.isAndroidDevice()) {
                    // Add content descriptions for TalkBack
                    document.querySelectorAll('[role="button"]').forEach(button => {
                        if (!button.hasAttribute('aria-description')) {
                            const label = button.getAttribute('aria-label') || button.textContent;
                            button.setAttribute('aria-description', `Button: ${label}`);
                        }
                    });
                    
                    // Add TalkBack-specific instructions
                    const talkBackHints = document.createElement('div');
                    talkBackHints.className = 'sr-only';
                    talkBackHints.textContent = 'TalkBack users: Use explore by touch to navigate, and double-tap to activate elements. Swipe gestures change the visual experience.';
                    document.body.appendChild(talkBackHints);
                }
            }
            
            announceToScreenReader(message, urgent = false) {
                const regionId = urgent ? 'assertiveRegion' : 'liveRegion';
                const region = document.getElementById(regionId);
                if (region) {
                    // Clear first to ensure the announcement triggers
                    region.textContent = '';
                    setTimeout(() => {
                        region.textContent = message;
                    }, 100);
                    
                    // Clear after announcement
                    setTimeout(() => {
                        region.textContent = '';
                    }, 3000);
                }
            }
            
            handleEscapeKey() {
                // Close any open modals or overlays
                const chatOverlay = document.querySelector('.chat-overlay.active');
                if (chatOverlay) {
                    chatOverlay.classList.remove('active');
                    this.announceToScreenReader('Chat closed');
                    return;
                }
                
                const terminalOverlay = document.getElementById('terminalOverlay');
                if (terminalOverlay && terminalOverlay.style.display === 'block') {
                    terminalOverlay.style.display = 'none';
                    this.announceToScreenReader('Terminal closed');
                    return;
                }
                
                // Close any expanded project items
                const openProjects = document.querySelectorAll('.project-item.open');
                if (openProjects.length > 0) {
                    openProjects.forEach(project => {
                        project.classList.remove('open');
                        project.setAttribute('aria-expanded', 'false');
                    });
                    this.announceToScreenReader('All projects collapsed');
                }
            }
            
            isIOSDevice() {
                return /iPad|iPhone|iPod/.test(navigator.userAgent) || 
                       (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            }
            
            isAndroidDevice() {
                return /Android/.test(navigator.userAgent);
            }
            
            // Performance mode accessibility adjustments
            adjustForPerformanceMode() {
                if (window.performanceManager?.isLowPower) {
                    // Reduce animation announcements in low power mode
                    this.announceToScreenReader('Low power mode active - reduced animations for better battery life');
                }
                
                if (window.performanceManager?.isCriticalMode) {
                    this.announceToScreenReader('Critical battery mode - animations paused to conserve power', true);
                }
            }
        }

        // Global state
        let currentArtifact = 0;
        let currentTheme = 'light';
        let currentTitleIndex = 0;
        let isTweening = false;
        let artifacts = [];
        let threeScenes = {};
        let isTransitioning = false;
        let resizeTimeout;
        let performanceMonitor = { fps: 0, lastTime: 0, frameCount: 0 };

        // Performance monitoring
        function updatePerformanceInfo() {
            performanceMonitor.frameCount++;
            const currentTime = performance.now();
            
            if (currentTime > performanceMonitor.lastTime + 1000) {
                performanceMonitor.fps = Math.round((performanceMonitor.frameCount * 1000) / (currentTime - performanceMonitor.lastTime));
                performanceMonitor.frameCount = 0;
                performanceMonitor.lastTime = currentTime;
                
                const perfInfo = document.getElementById('performanceInfo');
                if (perfInfo) {
                    const quality = performanceMonitor.fps > 45 ? 'Excellent' : 
                                   performanceMonitor.fps > 30 ? 'Good' : 'Basic';
                    perfInfo.textContent = `Performance: ${quality} (${performanceMonitor.fps} FPS)`;
                }
            }
        }

        // Error handling wrapper
        function safeInitArtifact(artifactFunction, artifactId, fallback = null) {
            try {
                artifactFunction();
            } catch (error) {
                console.warn(`Artifact ${artifactId} initialization failed:`, error);
                if (fallback) {
                    fallback();
                } else {
                    // Show error fallback
                    const container = document.getElementById(artifactId);
                    if (container) {
                        container.innerHTML = '<div class="error-fallback">Unable to load visualization</div>';
                    }
                }
            }
        }

        // Enhanced cleanup function
        function enhancedCleanup(scene, renderer, container, animationFrameId) {
            if (animationFrameId) cancelAnimationFrame(animationFrameId);
            
            if (scene) {
                scene.traverse((object) => {
                    if (object.geometry) {
                        object.geometry.dispose();
                    }
                    if (object.material) {
                        if (Array.isArray(object.material)) {
                            object.material.forEach(material => material.dispose());
                        } else {
                            object.material.dispose();
                        }
                    }
                });
            }
            
            if (renderer) {
                renderer.dispose();
                if (renderer.domElement && container && container.contains(renderer.domElement)) {
                    container.removeChild(renderer.domElement);
                }
            }
        }

        // Accessibility: Keyboard event handler
        function handleKeyPress(event) {
            if (event.key === ' ' || event.key === 'Enter') {
                event.preventDefault();
                changeEverything();
            }
        }

        // Title cycling system
        function cycleTitle() {
            const titleElement = document.querySelector('.glitch-title');
            
            currentTitleIndex = (currentTitleIndex + 1) % CONFIG.titles.length;
            const newTitle = CONFIG.titles[currentTitleIndex];
            
            gsap.to(titleElement, {
                duration: 1.2,
                text: {
                    value: newTitle,
                    delimiter: ""
                },
                ease: "none"
            });
        }

        // Combined function that changes both title and artifact
        function changeEverything() {
            if (isTransitioning) return;
            isTransitioning = true;
            
            // Trigger title glitch
            cycleTitle();
            
            // Change artifact with slight delay for dramatic effect
            setTimeout(() => {
                changeArtifact();
                setTimeout(() => {
                    isTransitioning = false;
                }, CONFIG.transitions.duration);
            }, CONFIG.transitions.delay);
            
            // Visual feedback for buttons
            const activeElement = document.activeElement;
            if (activeElement.classList.contains('spark-magic') || activeElement.classList.contains('glitch-title')) {
                activeElement.style.transform = 'scale(1.2)';
                setTimeout(() => {
                    activeElement.style.transform = '';
                }, 200);
            }
        }

        // Initialize artifacts
        function initializeArtifacts() {
            artifacts = [
                () => safeInitArtifact(initHankiesInTheWind, 'artifact-1'),
                () => safeInitArtifact(initAsciiBinaryFlow, 'artifact-2'),
                () => safeInitArtifact(initParticleVessel, 'artifact-3'),
                () => safeInitArtifact(initMetamorphosis, 'artifact-4'),
                () => safeInitArtifact(initLayeredSineWaves, 'artifact-5')
            ];
            
            // Initialize the first artifact
            artifacts[0]();
        }

        // Artifact 1: Enhanced HankiesInTheWind
        function initHankiesInTheWind() {
            const container = document.getElementById('artifact-1');
            if (container.hasChildNodes()) return;
            
            let scene, camera, renderer, lineGroups = [];
            let animationFrameId;
            
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ 
                antialias: !window.matchMedia('(max-width: 768px)').matches,
                powerPreference: "high-performance"
            });
            
            renderer.setSize(width, height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(currentTheme === 'dark' ? 0x1a1a1a : 0xF0EEE6);
            container.appendChild(renderer.domElement);
            
            camera.position.set(0, 0, 6);
            camera.lookAt(0, 0, 0);
            
            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.6);
            directionalLight.position.set(5, 5, 5);
            scene.add(ambientLight);
            scene.add(directionalLight);
            
            const mainGroup = new THREE.Group();
            scene.add(mainGroup);
            
            let time = 0;
            
            function createWaveSources(time, scale) {
                const result = [];
                const count = 5;
                
                for (let i = 0; i < count; i++) {
                    const angle = (i / count) * Math.PI * 2;
                    const radius = scale * (1 + Math.sin(angle * 3) * 0.2);
                    
                    result.push({
                        position: [
                            Math.cos(angle) * radius,
                            0,
                            Math.sin(angle) * radius
                        ],
                        frequency: 2 + Math.sin(angle * 2),
                        amplitude: 0.3 + Math.cos(angle) * 0.1,
                        phase: time * 3 + angle
                    });
                }
                
                result.push({
                    position: [0, 0, 0],
                    frequency: 3,
                    amplitude: 0.4,
                    phase: time * 4
                });
                
                return result;
            }
            
            function createInterferenceField(sources, size, resolution, time) {
                const step = size / resolution;
                const heightMap = [];
                
                for (let i = 0; i <= resolution; i++) {
                    heightMap[i] = [];
                    const x = (i * step) - (size / 2);
                    
                    for (let j = 0; j <= resolution; j++) {
                        const z = (j * step) - (size / 2);
                        let height = 0;
                        
                        sources.forEach(({ position: [sx, sy, sz], frequency, amplitude, phase }) => {
                            const dx = x - sx;
                            const dz = z - sz;
                            const distance = Math.sqrt(dx * dx + dz * dz);
                            height += Math.sin(distance * frequency - time * 5 + phase) * 
                                     amplitude * Math.exp(-distance * 0.3);
                        });
                        
                        heightMap[i][j] = height;
                    }
                }
                
                const linesMaterial = new THREE.LineBasicMaterial({ 
                    color: currentTheme === 'dark' ? 0xffffff : 0x333333,
                    transparent: true,
                    opacity: 0.4
                });
                
                const linesGroup = new THREE.Group();
                
                // Create horizontal lines
                for (let i = 0; i <= resolution; i++) {
                    const geometry = new THREE.BufferGeometry();
                    const points = [];
                    const x = (i * step) - (size / 2);
                    
                    for (let j = 0; j <= resolution; j++) {
                        const z = (j * step) - (size / 2);
                        points.push(x, heightMap[i][j], z);
                    }
                    
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
                    const line = new THREE.Line(geometry, linesMaterial);
                    linesGroup.add(line);
                }
                
                // Create vertical lines
                for (let j = 0; j <= resolution; j++) {
                    const geometry = new THREE.BufferGeometry();
                    const points = [];
                    const z = (j * step) - (size / 2);
                    
                    for (let i = 0; i <= resolution; i++) {
                        const x = (i * step) - (size / 2);
                        points.push(x, heightMap[i][j], z);
                    }
                    
                    geometry.setAttribute('position', new THREE.Float32BufferAttribute(points, 3));
                    const line = new THREE.Line(geometry, linesMaterial);
                    linesGroup.add(line);
                }
                
                return linesGroup;
            }
            
            function animate() {
                animationFrameId = requestAnimationFrame(animate);
                time += CONFIG.artifacts.hankies.animationSpeed;
                
                updatePerformanceInfo();
                
                // Clear previous groups
                mainGroup.children.forEach(child => {
                    if (child instanceof THREE.Group) {
                        child.children.forEach(line => {
                            if (line.geometry) line.geometry.dispose();
                            if (line.material) line.material.dispose();
                        });
                        mainGroup.remove(child);
                    }
                });
                
                // Create new interference fields
                const sources1 = createWaveSources(time, 1.5);
                const field1 = createInterferenceField(sources1, 1.5 * 4, CONFIG.artifacts.hankies.resolution, time);
                mainGroup.add(field1);
                
                const sources2 = createWaveSources(time + 0.33, 0.8);
                const field2 = createInterferenceField(sources2, 0.8 * 4, CONFIG.artifacts.hankies.resolution, time + 0.33);
                field2.position.set(0, 1.5, 0);
                field2.rotation.set(Math.PI/6, 0, Math.PI/4);
                mainGroup.add(field2);
                
                mainGroup.rotation.y = Math.sin(time * 0.3) * 0.2;
                mainGroup.rotation.x = Math.cos(time * 0.2) * 0.1;
                
                renderer.render(scene, camera);
            }
            
            animate();
            
            // Store for cleanup
            threeScenes['artifact-1'] = {
                cleanup: () => enhancedCleanup(scene, renderer, container, animationFrameId)
            };
        }

        // Artifact 2: Enhanced AsciiBinaryFlow
        function initAsciiBinaryFlow() {
            const container = document.querySelector('#artifact-2 .ascii-container');
            if (container.dataset.initialized) return;
            container.dataset.initialized = 'true';
            
            let width = CONFIG.artifacts.ascii.width;
            let height = CONFIG.artifacts.ascii.height;
            let grid = [];
            let time = 0;
            let animationFrameId;
            
            function initGrid() {
                grid = [];
                for (let y = 0; y < height; y++) {
                    let row = [];
                    for (let x = 0; x < width; x++) {
                        row.push(' ');
                    }
                    grid.push(row);
                }
            }
            
            function render() {
                let html = '';
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        html += grid[y][x];
                    }
                    html += '<br>';
                }
                container.innerHTML = html;
            }
            
            function update() {
                initGrid();
                
                const blockSize = Math.floor(width * 0.46);
                const blockX = Math.floor(width / 2 - blockSize / 2);
                const blockY = Math.floor(height / 2 - blockSize / 2);
                const t = time * 0.005;
                
                for (let y = 0; y < height; y++) {
                    for (let x = 0; x < width; x++) {
                        if (x >= blockX && x < blockX + blockSize && 
                            y >= blockY && y < blockY + blockSize) {
                            const innerDist = Math.min(
                                x - blockX, 
                                blockX + blockSize - x,
                                y - blockY,
                                blockY + blockSize - y
                            );
                            
                            const erosion = time * 0.0067;
                            if (innerDist > erosion) {
                                grid[y][x] = '1';
                            } else {
                                grid[y][x] = Math.random() > 0.8 ? '1' : '0';
                            }
                        } else {
                            const dx = x - width / 2;
                            const dy = y - height / 2;
                            const angle = Math.atan2(dy, dx);
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            
                            const wave = Math.sin(dist * 0.2 - t + angle * 1.5);
                            const flow = Math.sin(x * 0.08 + y * 0.04 + t * 0.4);
                            
                            if (flow + wave > 0.4) {
                                grid[y][x] = '0';
                            } else if (flow + wave < -0.4) {
                                grid[y][x] = '~';
                            }
                        }
                    }
                }
                
                // Add cracks
                for (let i = 0; i < 5; i++) {
                    const crackX = blockX + Math.floor(Math.random() * blockSize);
                    const crackY = blockY + Math.floor(Math.random() * blockSize);
                    const length = Math.floor(Math.random() * 10) + 5;
                    let cx = Math.floor(crackX);
                    let cy = Math.floor(crackY);
                    
                    for (let j = 0; j < length; j++) {
                        if (cx >= 0 && cx < width && cy >= 0 && cy < height) {
                            grid[cy][cx] = '0';
                        }
                        cx += Math.floor(Math.random() * 3) - 1;
                        cy += Math.floor(Math.random() * 3) - 1;
                    }
                }
                
                time++;
            }
            
            function animate() {
                update();
                render();
                updatePerformanceInfo();
                animationFrameId = requestAnimationFrame(animate);
            }
            
            initGrid();
            animate();
            
            // Store for cleanup
            threeScenes['artifact-2'] = {
                cleanup: () => {
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    container.innerHTML = '';
                    container.dataset.initialized = '';
                }
            };
        }

        // Artifact 3: Enhanced ParticleVessel
        function initParticleVessel() {
            const container = document.getElementById('artifact-3');
            if (container.hasChildNodes()) return;
            
            let scene, camera, renderer, animationFrameId;
            const count = CONFIG.artifacts.particles.count;
            
            const width = window.innerWidth;
            const height = window.innerHeight;
            
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ 
                antialias: !window.matchMedia('(max-width: 768px)').matches,
                powerPreference: "high-performance"
            });
            
            renderer.setSize(width, height);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.setClearColor(currentTheme === 'dark' ? 0x1a1a1a : 0xF0EEE6);
            container.appendChild(renderer.domElement);
            
            camera.position.z = 5;
            
            const particleMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    opacity: { value: CONFIG.artifacts.particles.opacity }
                },
                vertexShader: `
                    uniform float time;
                    attribute float size;
                    attribute vec3 customColor;
                    varying vec3 vColor;
                    
                    void main() {
                        vColor = customColor;
                        vec3 pos = position;
                        
                        float radius = length(pos.xz);
                        float angle = atan(pos.z, pos.x);
                        float height = pos.y;
                        
                        float vessel = smoothstep(0.3, 0.7, radius) * smoothstep(1.0, 0.7, radius);
                        
                        angle += time * 0.08;
                        
                        float space = sin(time * 0.3 + radius * 3.0) * 0.1;
                        
                        float newRadius = (radius + space) * vessel;
                        
                        vec3 newPos;
                        newPos.x = cos(angle) * newRadius;
                        newPos.z = sin(angle) * newRadius;
                        newPos.y = height * vessel - 1.2;
                        
                        newPos *= 2.75;
                        
                        vec4 mvPosition = modelViewMatrix * vec4(newPos, 1.0);
                        gl_PointSize = size * (128.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    uniform float opacity;
                    varying vec3 vColor;
                    void main() {
                        vec2 center = gl_PointCoord - vec2(0.5);
                        float dist = dot(center, center);
                        
                        if (dist > 0.25) discard;
                        
                        float alpha = (1.0 - smoothstep(0.2025, 0.25, dist)) * opacity;
                        gl_FragColor = vec4(vColor, alpha);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.NormalBlending
            });
            
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            
            let i3 = 0;
            for (let i = 0; i < count; i++) {
                const t = i / count;
                const radius = Math.pow(t, 0.5);
                const angle = t * Math.PI * 40;
                
                const vesselHeight = Math.sin(t * Math.PI) * 1.8;
                
                const randRadius = radius + (Math.random() - 0.5) * 0.05;
                const randAngle = angle + (Math.random() - 0.5) * 0.1;
                
                positions[i3] = Math.cos(randAngle) * randRadius;
                positions[i3 + 1] = vesselHeight;
                positions[i3 + 2] = Math.sin(randAngle) * randRadius;

                const shade = currentTheme === 'dark' ? 
                    (0.8 + Math.sqrt(radius) * 0.2 + Math.random() * 0.1) :
                    (0.1 + Math.sqrt(radius) * 0.1 + Math.random() * 0.02);
                colors[i3] = shade;
                colors[i3 + 1] = shade;
                colors[i3 + 2] = shade;

                sizes[i] = (1.0 - Math.abs(vesselHeight * 0.5)) * 0.2 + 0.1;
                
                i3 += 3;
            }
            
            const geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('customColor', new THREE.BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
            
            const points = new THREE.Points(geometry, particleMaterial);
            scene.add(points);
            
            const clock = new THREE.Clock();
            
            function animate() {
                animationFrameId = requestAnimationFrame(animate);
                
                const time = clock.getElapsedTime();
                particleMaterial.uniforms.time.value = time;
                
                updatePerformanceInfo();
                renderer.render(scene, camera);
            }
            
            animate();
            
            threeScenes['artifact-3'] = {
                cleanup: () => enhancedCleanup(scene, renderer, container, animationFrameId)
            };
        }

        // Artifact 4: Enhanced Metamorphosis
        function initMetamorphosis() {
            const canvas = document.querySelector('#artifact-4 canvas');
            if (canvas.dataset.initialized) return;
            canvas.dataset.initialized = 'true';
            
            const ctx = canvas.getContext('2d', { willReadFrequently: false });
            const width = canvas.width;
            const height = canvas.height;
            
            let animationFrameId;
            let time = 2000;
            
            const numLines = CONFIG.artifacts.metamorphosis.numLines;
            const lineSegments = CONFIG.artifacts.metamorphosis.lineSegments;
            const lineAlpha = 0.5;
            const lineWidth = 0.6;
            
            const forms = [
                // Form 1: Draped cloth-like shape
                (u, v, t) => {
                    const theta = u * Math.PI * 2;
                    const phi = v * Math.PI;
                    
                    let r = 120 + 30 * Math.sin(phi * 4 + theta * 2);
                    r += 20 * Math.sin(phi * 6) * Math.cos(theta * 3);
                    
                    let x = r * Math.sin(phi) * Math.cos(theta);
                    let y = r * Math.sin(phi) * Math.sin(theta);
                    let z = r * Math.cos(phi) + 20 * Math.sin(theta * 5 + phi * 3);
                    
                    return { x, y, z };
                },
                
                // Form 2: More angular folded shape
                (u, v, t) => {
                    const theta = u * Math.PI * 2;
                    const phi = v * Math.PI;
                    
                    let r = 150 + 20 * Math.cos(phi * 8);
                    r *= 0.8 + 0.2 * Math.abs(Math.cos(theta * 2));
                    
                    let x = r * Math.sin(phi) * Math.cos(theta);
                    let y = r * Math.sin(phi) * Math.sin(theta);
                    let z = r * Math.cos(phi) * (0.8 + 0.3 * Math.sin(theta * 4));
                    
                    return { x, y, z };
                },
                
                // Form 3: Organic bulbous shape
                (u, v, t) => {
                    const theta = u * Math.PI * 2;
                    const phi = v * Math.PI;
                    
                    let r = 120;
                    r += 50 * Math.sin(phi * 3) * Math.sin(theta * 2.5);
                    r += 30 * Math.cos(phi * 5 + theta);
                    
                    let x = r * Math.sin(phi) * Math.cos(theta);
                    let y = r * Math.sin(phi) * Math.sin(theta);
                    let z = r * Math.cos(phi);
                    
                    const hollow = Math.max(0, Math.sin(phi * 2 + theta * 3) - 0.7);
                    r *= 1 - hollow * 0.8;
                    
                    return { x, y, z };
                }
            ];
            
            function interpolateForms(formA, formB, u, v, t, blend) {
                const pointA = formA(u, v, t);
                const pointB = formB(u, v, t);
                
                return {
                    x: pointA.x * (1 - blend) + pointB.x * blend,
                    y: pointA.y * (1 - blend) + pointB.y * blend,
                    z: pointA.z * (1 - blend) + pointB.z * blend
                };
            }
            
            function getCurrentForm(u, v, t) {
                const totalForms = forms.length;
                const cycleTime = 600;
                const position = (t % (cycleTime * totalForms)) / cycleTime;
                const formIndex = Math.floor(position);
                const nextFormIndex = (formIndex + 1) % totalForms;
                
                let rawBlend = position - formIndex;
                const pauseTime = 0;
                const transitionTime = 1 - (pauseTime * 2);
                
                let blend;
                if (rawBlend < pauseTime) {
                    blend = 0;
                } else if (rawBlend > (1 - pauseTime)) {
                    blend = 1;
                } else {
                    const normalizedTime = (rawBlend - pauseTime) / transitionTime;
                    blend = normalizedTime < 0.5
                        ? 4 * normalizedTime * normalizedTime * normalizedTime
                        : 1 - Math.pow(-2 * normalizedTime + 2, 3) / 2;
                }
                
                return interpolateForms(
                    forms[formIndex], 
                    forms[nextFormIndex], 
                    u, v, t, blend
                );
            }
            
            function animate() {
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = currentTheme === 'dark' ? '#1a1a1a' : '#F0EEE6';
                ctx.fillRect(0, 0, width, height);
                
                const rotateX = Math.sin(time * 0.00025) * 0.5;
                const rotateY = Math.cos(time * 0.00025 * 0.7) * 0.3;
                const rotateZ = time * 0.00025 * 0.1;
                
                // Draw horizontal contour lines
                for (let i = 0; i < numLines; i++) {
                    const v = i / (numLines - 1);
                    
                    ctx.beginPath();
                    const strokeColor = currentTheme === 'dark' ? 'rgba(255, 255, 255, 0.5)' : 'rgba(51, 51, 51, 0.5)';
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = lineWidth;
                    
                    let lastPointVisible = false;
                    
                    for (let j = 0; j <= lineSegments; j++) {
                        const u = j / lineSegments;
                        
                        const point = getCurrentForm(u, v, time);
                        
                        const rotatedX = point.x * Math.cos(rotateZ) - point.y * Math.sin(rotateZ);
                        const rotatedY = point.x * Math.sin(rotateZ) + point.y * Math.cos(rotateZ);
                        const rotatedZ = point.z;
                        
                        const scale = 1.5 + rotatedZ * 0.001;
                        const projX = width / 2 + rotatedX * scale;
                        const projY = height / 2 + rotatedY * scale;
                        
                        const pointVisible = rotatedZ > -50;
                        
                        if (j === 0) {
                            if (pointVisible) {
                                ctx.moveTo(projX, projY);
                                lastPointVisible = true;
                            }
                        } else {
                            if (pointVisible && lastPointVisible) {
                                ctx.lineTo(projX, projY);
                            } else if (pointVisible && !lastPointVisible) {
                                ctx.moveTo(projX, projY);
                            }
                        }
                        
                        lastPointVisible = pointVisible;
                    }
                    
                    ctx.stroke();
                }
                
                // Draw vertical contour lines
                for (let i = 0; i < numLines * 0.3; i++) {
                    const u = i / (numLines * 0.3 - 1);
                    
                    ctx.beginPath();
                    const strokeColor = currentTheme === 'dark' ? 'rgba(255, 255, 255, 0.35)' : 'rgba(51, 51, 51, 0.35)';
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = lineWidth * 0.7;
                    
                    let lastPointVisible = false;
                    
                    for (let j = 0; j <= lineSegments * 0.5; j++) {
                        const v = j / (lineSegments * 0.5);
                        
                        const point = getCurrentForm(u, v, time);
                        
                        const rotatedX = point.x * Math.cos(rotateZ) - point.y * Math.sin(rotateZ);
                        const rotatedY = point.x * Math.sin(rotateZ) + point.y * Math.cos(rotateZ);
                        const rotatedZ = point.z;
                        
                        const scale = 1.5 + rotatedZ * 0.001;
                        const projX = width / 2 + rotatedX * scale;
                        const projY = height / 2 + rotatedY * scale;
                        
                        const pointVisible = rotatedZ > -50;
                        
                        if (j === 0) {
                            if (pointVisible) {
                                ctx.moveTo(projX, projY);
                                lastPointVisible = true;
                            }
                        } else {
                            if (pointVisible && lastPointVisible) {
                                ctx.lineTo(projX, projY);
                            } else if (pointVisible && !lastPointVisible) {
                                ctx.moveTo(projX, projY);
                            }
                        }
                        
                        lastPointVisible = pointVisible;
                    }
                    
                    ctx.stroke();
                }
                
                time += 0.5;
                updatePerformanceInfo();
                animationFrameId = requestAnimationFrame(animate);
            }
            
            animate();
            
            threeScenes['artifact-4'] = {
                cleanup: () => {
                    if (animationFrameId) cancelAnimationFrame(animationFrameId);
                    ctx.clearRect(0, 0, width, height);
                    canvas.dataset.initialized = '';
                }
            };
        }

        // Artifact 5: Enhanced LayeredSineWaves
        function initLayeredSineWaves() {
            const canvas = document.querySelector('#artifact-5 canvas');
            if (canvas.dataset.initialized) return;
            canvas.dataset.initialized = 'true';
            
            const ctx = canvas.getContext('2d', { willReadFrequently: false });
            const width = canvas.width;
            const height = canvas.height;
            
            let animationId;
            let time = 0;
            
            const layers = CONFIG.artifacts.sineWaves.layers;
            const points = CONFIG.artifacts.sineWaves.points;
            const waveAmplitude = 40;
            
            function draw() {
                ctx.clearRect(0, 0, width, height);
                ctx.fillStyle = currentTheme === 'dark' ? '#1a1a1a' : '#F0EEE6';
                ctx.fillRect(0, 0, width, height);
                
                time += 0.01;
                
                // Draw each layer
                for (let layer = 0; layer < layers; layer++) {
                    const layerPosition = (layer / layers) * height * 0.8 + height * 0.1;
                    const layerFrequency = 0.5 + layer * 0.03;
                    const layerPhase = time * 0.2 + layer * 0.05;
                    const layerAmplitude = waveAmplitude * (0.5 + 0.5 * Math.sin(layer * 0.1 + time * 0.3));
                    
                    const baseOpacity = 0.2 + 0.6 * Math.pow(Math.sin((layer / layers) * Math.PI), 2);
                    const timeEffect = 0.2 * Math.sin(time * 0.4 + layer * 0.1);
                    const opacity = Math.min(0.9, Math.max(0.1, baseOpacity + timeEffect));
                    
                    ctx.beginPath();
                    const strokeColor = currentTheme === 'dark' ? 
                        `rgba(255, 255, 255, ${opacity})` : 
                        `rgba(50, 50, 50, ${opacity})`;
                    ctx.strokeStyle = strokeColor;
                    ctx.lineWidth = 0.6;
                    
                    for (let i = 0; i <= points; i++) {
                        const x = (i / points) * width;
                        
                        let y = layerPosition;
                        
                        y += layerAmplitude * Math.sin(x * 0.01 * layerFrequency + layerPhase);
                        y += layerAmplitude * 0.3 * Math.sin(x * 0.02 * layerFrequency + layerPhase * 1.5);
                        y += layerAmplitude * 0.2 * Math.sin(x * 0.04 * layerFrequency - layerPhase * 0.7);
                        y += layerAmplitude * 0.1 * Math.sin(x * 0.08 * layerFrequency + layerPhase * 2.3);
                        
                        if (i === 0) {
                            ctx.moveTo(x, y);
                        } else {
                            ctx.lineTo(x, y);
                        }
                    }
                    
                    ctx.stroke();
                }
                
                // Draw connecting lines
                for (let i = 0; i < width; i += 20) {
                    if (Math.random() < 0.4) {
                        ctx.beginPath();
                        
                        const opacity = 0.1 + 0.2 * Math.sin(i * 0.05 + time);
                        const strokeColor = currentTheme === 'dark' ? 
                            `rgba(255, 255, 255, ${opacity})` : 
                            `rgba(50, 50, 50, ${opacity})`;
                        ctx.strokeStyle = strokeColor;
                        ctx.lineWidth = 0.3;
                        
                        const startY = height * 0.1 + Math.random() * height * 0.2;
                        const endY = height * 0.7 + Math.random() * height * 0.2;
                        
                        ctx.moveTo(i, startY);
                        ctx.lineTo(i, endY);
                        ctx.stroke();
                    }
                }
                
                updatePerformanceInfo();
                animationId = requestAnimationFrame(draw);
            }
            
            draw();
            
            threeScenes['artifact-5'] = {
                cleanup: () => {
                    if (animationId) cancelAnimationFrame(animationId);
                    ctx.clearRect(0, 0, width, height);
                    canvas.dataset.initialized = '';
                }
            };
        }

        // Artifact switching
        function changeArtifact() {
            const currentElement = document.querySelector('.artifact.active');
            currentElement.classList.remove('active');
            
            // Clean up current artifact
            if (threeScenes[`artifact-${currentArtifact + 1}`] && 
                threeScenes[`artifact-${currentArtifact + 1}`].cleanup) {
                threeScenes[`artifact-${currentArtifact + 1}`].cleanup();
            }
            
            currentArtifact = (currentArtifact + 1) % artifacts.length;
            
            const nextElement = document.getElementById(`artifact-${currentArtifact + 1}`);
            nextElement.classList.add('active');
            
            // Initialize the new artifact
            setTimeout(() => {
                artifacts[currentArtifact]();
            }, 100);
        }

        // Smooth scrolling for navigation links
        document.querySelectorAll('a[href^="#"]').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                e.preventDefault();
                const targetId = this.getAttribute('href').substring(1);
                const target = document.getElementById(targetId);
                if (target) {
                    target.scrollIntoView({
                        behavior: 'smooth',
                        block: 'start'
                    });
                }
            });
        });

        // Simple working project toggle function (KEEP THIS WORKING)
        function toggleProject(element) {
            // Close all other projects
            document.querySelectorAll('.project-item').forEach(item => {
                if (item !== element) {
                    item.classList.remove('open');
                }
            });
            
            // Toggle current project
            element.classList.toggle('open');
        }

        // Initialize everything
        function initialize() {
            // Hide loading screen
            const loadingScreen = document.getElementById('loadingScreen');
            setTimeout(() => {
                loadingScreen.classList.add('hidden');
            }, 1000);

            // Initialize artifacts
            initializeArtifacts();
            
            // Initialize performance manager for mobile optimization
            if (typeof MobilePerformanceManager !== 'undefined') {
                window.performanceManager = new MobilePerformanceManager();
                console.log('✅ Mobile performance manager initialized');
            }
            
            // Initialize enhanced mobile accessibility
            if (typeof MobileAccessibilityManager !== 'undefined') {
                window.accessibilityManager = new MobileAccessibilityManager();
                console.log('✅ Mobile accessibility manager initialized');
            }

            // Add click effects to buttons
            document.querySelectorAll('.cta-button').forEach(button => {
                button.addEventListener('click', function() {
                    this.style.transform = 'scale(0.95)';
                    setTimeout(() => {
                        this.style.transform = 'translateY(-2px)';
                    }, 100);
                });
            });
        }

        // Enhanced resize handler with debouncing
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(() => {
                // Update configuration for new screen size
                CONFIG.artifacts.particles.count = window.innerWidth < 768 ? 15000 : 45000;
                CONFIG.artifacts.hankies.resolution = window.innerWidth < 768 ? 16 : 32;
                CONFIG.artifacts.ascii.width = window.innerWidth < 768 ? 45 : 65;
                CONFIG.artifacts.ascii.height = window.innerWidth < 768 ? 45 : 65;
                CONFIG.artifacts.metamorphosis.numLines = window.innerWidth < 768 ? 60 : 120;
                CONFIG.artifacts.metamorphosis.lineSegments = window.innerWidth < 768 ? 90 : 180;
                CONFIG.artifacts.sineWaves.layers = window.innerWidth < 768 ? 40 : 80;
                CONFIG.artifacts.sineWaves.points = window.innerWidth < 768 ? 100 : 200;
                
                // Reinitialize current Three.js artifact on resize
                if (currentArtifact === 0 || currentArtifact === 2) {
                    if (threeScenes[`artifact-${currentArtifact + 1}`] && 
                        threeScenes[`artifact-${currentArtifact + 1}`].cleanup) {
                        threeScenes[`artifact-${currentArtifact + 1}`].cleanup();
                    }
                    setTimeout(() => {
                        artifacts[currentArtifact]();
                    }, 100);
                }
            }, 250);
        });

        // Enhanced Touch Gesture System for Mobile
        class TouchGestureManager {
            constructor() {
                this.startX = 0;
                this.startY = 0;
                this.startTime = 0;
                this.threshold = 50; // minimum swipe distance
                this.timeThreshold = 300; // maximum swipe time
                this.setupGestures();
                this.showMobileHints();
            }
            
            setupGestures() {
                const heroContainer = document.querySelector('.hero-container');
                let isDragging = false;
                
                heroContainer.addEventListener('touchstart', (e) => {
                    // Handle title/magic button taps
                    if (e.target.classList.contains('glitch-title') || e.target.classList.contains('spark-magic')) {
                        e.preventDefault();
                        changeEverything();
                        return;
                    }
                    
                    // Start gesture tracking
                    this.startX = e.touches[0].clientX;
                    this.startY = e.touches[0].clientY;
                    this.startTime = Date.now();
                    isDragging = false;
                }, { passive: false });
                
                heroContainer.addEventListener('touchmove', (e) => {
                    if (!this.startX || !this.startY) return;
                    
                    const currentX = e.touches[0].clientX;
                    const deltaX = Math.abs(currentX - this.startX);
                    
                    // Detect if user is actively swiping
                    if (deltaX > 10) {
                        isDragging = true;
                        // Add visual feedback during swipe
                        this.addSwipeVisualFeedback(currentX - this.startX);
                    }
                }, { passive: true });
                
                heroContainer.addEventListener('touchend', (e) => {
                    if (!this.startX || !this.startY) return;
                    
                    const endX = e.changedTouches[0].clientX;
                    const endY = e.changedTouches[0].clientY;
                    const endTime = Date.now();
                    
                    const deltaX = endX - this.startX;
                    const deltaY = endY - this.startY;
                    const deltaTime = endTime - this.startTime;
                    
                    // Remove any visual feedback
                    this.removeSwipeVisualFeedback();
                    
                    // Check if it's a valid swipe
                    if (Math.abs(deltaX) > Math.abs(deltaY) && 
                        Math.abs(deltaX) > this.threshold && 
                        deltaTime < this.timeThreshold &&
                        isDragging) {
                        
                        e.preventDefault();
                        
                        if (deltaX > 0) {
                            // Swipe right - previous artifact
                            this.previousArtifact();
                        } else {
                            // Swipe left - next artifact
                            this.nextArtifact();
                        }
                    }
                    
                    // Reset
                    this.startX = 0;
                    this.startY = 0;
                    this.startTime = 0;
                    isDragging = false;
                }, { passive: false });
            }
            
            nextArtifact() {
                if (!isTransitioning) {
                    changeEverything();
                    this.showSwipeSuccess('right');
                }
            }
            
            previousArtifact() {
                if (!isTransitioning) {
                    isTransitioning = true;
                    
                    // Cycle backwards through titles
                    currentTitleIndex = currentTitleIndex === 0 ? CONFIG.titles.length - 1 : currentTitleIndex - 1;
                    this.updateTitleText();
                    
                    // Cycle backwards through artifacts
                    setTimeout(() => {
                        const currentElement = document.querySelector('.artifact.active');
                        currentElement.classList.remove('active');
                        
                        if (threeScenes[`artifact-${currentArtifact + 1}`]?.cleanup) {
                            threeScenes[`artifact-${currentArtifact + 1}`].cleanup();
                        }
                        
                        currentArtifact = currentArtifact === 0 ? artifacts.length - 1 : currentArtifact - 1;
                        
                        const nextElement = document.getElementById(`artifact-${currentArtifact + 1}`);
                        nextElement.classList.add('active');
                        
                        setTimeout(() => {
                            artifacts[currentArtifact]();
                            isTransitioning = false;
                        }, 100);
                    }, CONFIG.transitions.delay);
                    
                    this.showSwipeSuccess('left');
                }
            }
            
            updateTitleText() {
                const titleElement = document.querySelector('.glitch-title');
                gsap.to(titleElement, {
                    duration: 1.2,
                    text: { value: CONFIG.titles[currentTitleIndex], delimiter: "" },
                    ease: "none"
                });
            }
            
            addSwipeVisualFeedback(deltaX) {
                const heroContainer = document.querySelector('.hero-container');
                const opacity = Math.min(Math.abs(deltaX) / 100, 0.3);
                
                if (deltaX > 0) {
                    heroContainer.style.background = `linear-gradient(90deg, rgba(102, 102, 102, ${opacity}) 0%, transparent 100%)`;
                } else {
                    heroContainer.style.background = `linear-gradient(-90deg, rgba(102, 102, 102, ${opacity}) 0%, transparent 100%)`;
                }
            }
            
            removeSwipeVisualFeedback() {
                const heroContainer = document.querySelector('.hero-container');
                heroContainer.style.background = '';
            }
            
            showSwipeSuccess(direction) {
                const indicator = document.createElement('div');
                indicator.style.cssText = `
                    position: fixed;
                    top: 50%;
                    ${direction === 'right' ? 'right: 20px;' : 'left: 20px;'}
                    transform: translateY(-50%);
                    background: rgba(102, 102, 102, 0.9);
                    color: white;
                    padding: 10px 15px;
                    border-radius: 25px;
                    font-size: 0.8rem;
                    z-index: 1002;
                    font-family: 'Roboto Mono', monospace;
                    animation: swipeSuccess 0.6s ease-out;
                `;
                indicator.textContent = direction === 'right' ? '← Previous' : 'Next →';
                document.body.appendChild(indicator);
                
                setTimeout(() => indicator.remove(), 600);
            }
            
            showMobileHints() {
                if (window.innerWidth <= 768) {
                    const hintsHTML = `
                        <div class="mobile-hints" style="
                            position: absolute;
                            bottom: 100px;
                            left: 50%;
                            transform: translateX(-50%);
                            color: rgba(51, 51, 51, 0.6);
                            font-size: 0.8rem;
                            text-align: center;
                            z-index: 10;
                            pointer-events: none;
                            animation: fadeInOut 4s ease-in-out infinite;
                        ">
                            ← Swipe to explore →<br>
                            <span style="font-size: 0.7rem;">Tap title to cycle</span>
                        </div>
                    `;
                    document.querySelector('.hero-content').insertAdjacentHTML('beforeend', hintsHTML);
                }
            }
        }
        
        // CSS animations for swipe feedback
        const swipeStyles = document.createElement('style');
        swipeStyles.textContent = `
            @keyframes swipeSuccess {
                0% { opacity: 0; transform: translateY(-50%) scale(0.8); }
                50% { opacity: 1; transform: translateY(-50%) scale(1.1); }
                100% { opacity: 0; transform: translateY(-50%) scale(1); }
            }
            
            @keyframes fadeInOut {
                0%, 100% { opacity: 0; }
                50% { opacity: 1; }
            }
            
            @media (max-width: 768px) {
                .mobile-hints {
                    display: block;
                }
            }
            
            @media (min-width: 769px) {
                .mobile-hints {
                    display: none;
                }
            }
        `;
        document.head.appendChild(swipeStyles);
        
        // Initialize gesture manager on mobile devices
        if (window.innerWidth <= 768 || 'ontouchstart' in window) {
            window.gestureManager = new TouchGestureManager();
        }

        // Initialize when page loads
        window.addEventListener('load', initialize);

        // Accessibility: Focus management
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Tab') {
                // Allow normal tab navigation
                return;
            }
            if (e.key === ' ' || e.key === 'Enter') {
                const activeElement = document.activeElement;
                if (activeElement.classList.contains('glitch-title') || 
                    activeElement.classList.contains('spark-magic')) {
                    e.preventDefault();
                    changeEverything();
                }
            }
        });

        // Performance optimization: Pause animations when page is not visible
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                // Page is hidden, consider pausing heavy animations
                console.log('Page hidden - animations continue for demo purposes');
            } else {
                // Page is visible again
                console.log('Page visible - all animations active');
            }
        });

        // Error boundary for global errors
        window.addEventListener('error', (e) => {
            console.warn('Global error caught:', e.error);
            // Could implement fallback here
        });

        // Service worker registration (commented out for demo)
        /*
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/sw.js').catch(console.error);
        }
        */

        // Terminal Experience Integration
        let terminalQuestionnaire = null;
        
        // Global chat variables - reuse same instance
        let globalChatUI = null;
        let globalConversationManager = null;
        let chatInitialized = false;
        
        // Global character terminal - reuse same instance
        let globalCharacterTerminal = null;
        
        // Single function to initialize character terminal
        function ensureCharacterTerminalInitialized() {
            if (globalCharacterTerminal) {
                return globalCharacterTerminal;
            }
            
            if (window.CharacterTerminal) {
                console.log('🖥️ Initializing global character terminal...');
                globalCharacterTerminal = new CharacterTerminal();
                console.log('✅ Global character terminal initialized');
                return globalCharacterTerminal;
            }
            
            console.warn('⚠️ CharacterTerminal class not available yet');
            return null;
        }
        
        // Expose globally for other scripts
        window.ensureCharacterTerminalInitialized = ensureCharacterTerminalInitialized;
        
        // Single function to initialize chat system
        function ensureChatInitialized() {
            if (chatInitialized && globalChatUI && globalConversationManager) {
                return { chatUI: globalChatUI, conversationManager: globalConversationManager };
            }
            
            if (window.ConversationManager && window.ChatUI) {
                console.log('🔧 Initializing global chat system...');
                globalChatUI = new ChatUI();
                globalConversationManager = new ConversationManager();
                
                globalChatUI.initialize();
                globalConversationManager.initialize(globalChatUI);
                globalConversationManager.loadStoredApiKey();
                
                chatInitialized = true;
                console.log('✅ Global chat system initialized');
                
                return { chatUI: globalChatUI, conversationManager: globalConversationManager };
            }
            
            console.warn('⚠️ Chat classes not available yet');
            return null;
        }

        function initializeTerminalExperience() {
            if (TerminalQuestionnaire.hasCompletedExperience()) {
                // User has already completed the experience, go directly to chat
                initializeConversation();
            } else {
                // Show terminal questionnaire
                terminalQuestionnaire = new TerminalQuestionnaire();
                terminalQuestionnaire.show();
            }
        }

        function initializeConversation() {
            // Use centralized chat initialization
            const chat = ensureChatInitialized();
            if (!chat) return;
            
            // Show the chat UI
            chat.chatUI.show();
            
            // Get user data for personalized greeting
            const userData = TerminalQuestionnaire.getUserData();
            if (userData && userData.userName) {
                // Add a personalized welcome message with safe property access
                let welcomeMessage = `Welcome back, ${userData.userName}! 🌟`;
                
                if (userData.analysis && userData.analysis.dominantTrait) {
                    welcomeMessage += ` Based on our chat, I know you're ${userData.analysis.dominantTrait}. What would you like to explore today?`;
                } else {
                    welcomeMessage += ` What would you like to explore today?`;
                }
                
                chatUI.addMessage(welcomeMessage, true);
            }
        }

        // Navigation handlers
        document.addEventListener('DOMContentLoaded', function() {

            // Meet Your El button handler
            const meetYourElBtn = document.getElementById('meetYourElBtn');
            if (meetYourElBtn) {
                meetYourElBtn.addEventListener('click', function(e) {
                    e.preventDefault();
                    initializeTerminalExperience();
                });
            }
        });

        // Development helpers and shortcuts
        document.addEventListener('keydown', function(e) {
            // Reset user data (Ctrl+Shift+R)
            if (e.ctrlKey && e.shiftKey && e.key === 'R') {
                if (confirm('Reset terminal experience data? This will clear all stored user information.')) {
                    TerminalQuestionnaire.clearUserData();
                    location.reload();
                }
            }
            
            // Quick avatar test (Ctrl+Shift+T)
            if (e.ctrlKey && e.shiftKey && e.key === 'T') {
                e.preventDefault();
                showQuickAvatarTest();
            }
            
            // Quick chat reset (Ctrl+Shift+C) 
            if (e.ctrlKey && e.shiftKey && e.key === 'C') {
                e.preventDefault();
                if (confirm('Reset chat and start fresh conversation?')) {
                    resetChatExperience();
                }
            }
            
            // Debug API connection (Ctrl+Shift+D)
            if (e.ctrlKey && e.shiftKey && e.key === 'D') {
                e.preventDefault();
                debugApiConnection();
            }
        });

        function showQuickAvatarTest() {
            const testKeywords = prompt(`Quick Avatar Test - Enter keywords separated by commas:
            
Examples:
• technical, leadership, startup
• creative, innovation, design  
• collaborative, team, communication
• adventure, risk, exploration

Your keywords:`);
            
            if (!testKeywords) return;
            
            generateQuickAvatar(testKeywords);
        }

        async function generateQuickAvatar(keywords) {
            try {
                // Create mock responses based on keywords
                const mockResponses = generateMockResponses(keywords);
                
                // Initialize components if needed
                if (!window.testAnalyzer) {
                    window.testAnalyzer = new AdvancedPersonalityAnalyzer();
                    window.testAvatarService = new ClaudeAvatarService();
                    window.testAvatarDisplay = new AvatarDisplay();
                    
                    // Server-side API key handling - no client setup needed
                }
                
                // Generate personality analysis
                const personalityData = window.testAnalyzer.generatePersonalityInsights(mockResponses, 'QuickTest');
                
                // Debug: Log personality analysis results
                console.log('Personality Analysis Debug:', {
                    keywords: keywords,
                    responses: mockResponses,
                    scores: personalityData.scores,
                    archetype: personalityData.archetype.archetype.name,
                    confidence: personalityData.archetype.confidence,
                    reasoning: personalityData.archetype.reasoning
                });
                
                // API key is now handled server-side, so we can proceed directly
                
                // Show loading indicator
                showQuickLoadingIndicator();
                
                // Generate avatar with Claude
                const avatarData = await window.testAvatarService.generateAvatar(
                    personalityData,
                    { responses: mockResponses },
                    personalityData.archetype
                );
                
                // Hide loading indicator
                hideQuickLoadingIndicator();
                
                // Set the avatar for chat conversations
                window.setGeneratedAvatarForChat(avatarData);
                
                // Show avatar results
                window.testAvatarDisplay.show(avatarData, personalityData, () => {
                    console.log('Quick test avatar closed');
                });
                
            } catch (error) {
                hideQuickLoadingIndicator();
                console.error('Quick avatar test failed:', error);
                alert(`Avatar generation failed: ${error.message}`);
            }
        }

        function generateMockResponses(keywords) {
            const keywordList = keywords.toLowerCase().split(',').map(k => k.trim());
            
            // Generate responses that include the keywords naturally
            const responses = {
                question_0: `I'm a professional who works with ${keywordList.slice(0, 2).join(' and ')} in my daily role`,
                question_1: `I'm passionate about ${keywordList.slice(0, 3).join(', ')} and building solutions that incorporate these elements`,
                question_2: `I'd love to meet someone who revolutionized ${keywordList[0] || 'technology'} and discuss ${keywordList.slice(1, 3).join(' and ')}`,
                question_3: `I want to make an impact through ${keywordList.join(', ')} and help others succeed in these areas`
            };
            
            return responses;
        }

        function showQuickPersonalityResults(personalityData, keywords) {
            const archetype = personalityData.archetype.archetype;
            const message = `Quick Test Results for keywords: "${keywords}"

🎭 Archetype: ${archetype.name}
🎯 Confidence: ${Math.round(archetype.confidence * 100)}%
📊 Top Traits: ${personalityData.dominantTraits.map(t => t.trait).join(', ')}

${personalityData.personalityOverview}

To generate full Claude avatar, set up API key in the terminal experience or test suite.`;

            alert(message);
        }

        function showQuickLoadingIndicator() {
            if (document.getElementById('quickTestLoader')) return;
            
            const loader = document.createElement('div');
            loader.id = 'quickTestLoader';
            loader.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: #1a1a1a;
                color: #00ff88;
                padding: 15px 25px;
                border-radius: 8px;
                font-family: 'Courier New', monospace;
                font-size: 14px;
                z-index: 10001;
                border: 2px solid #00ff88;
                box-shadow: 0 4px 12px rgba(0, 255, 136, 0.3);
            `;
            loader.innerHTML = `
                🤖 Generating Avatar...
                <div style="font-size: 12px; color: #666; margin-top: 5px;">
                    Quick Test Mode (Ctrl+Shift+T)
                </div>
            `;
            
            document.body.appendChild(loader);
        }

        function hideQuickLoadingIndicator() {
            const loader = document.getElementById('quickTestLoader');
            if (loader) {
                loader.remove();
            }
        }

        function resetChatExperience() {
            // Clear all stored data
            localStorage.removeItem('terminal_user_data');
            sessionStorage.removeItem('terminal_session');
            localStorage.removeItem('terminal_analytics');
            
            // Close any open terminals or avatars
            const existingTerminal = document.querySelector('.terminal-questionnaire');
            if (existingTerminal) {
                existingTerminal.remove();
            }
            
            const existingAvatar = document.querySelector('.avatar-display-overlay');
            if (existingAvatar) {
                existingAvatar.remove();
            }
            
            // Close any chat interfaces
            if (window.chatUI && typeof window.chatUI.hide === 'function') {
                window.chatUI.hide();
            }
            
            // Show success message
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                left: 50%;
                transform: translateX(-50%);
                background: #00ff88;
                color: #1a1a1a;
                padding: 12px 24px;
                border-radius: 6px;
                font-family: 'Courier New', monospace;
                font-weight: bold;
                z-index: 10002;
                box-shadow: 0 4px 12px rgba(0, 255, 136, 0.3);
            `;
            notification.textContent = '✅ Chat experience reset - Ready for fresh start!';
            
            document.body.appendChild(notification);
            setTimeout(() => {
                notification.remove();
            }, 3000);
            
            console.log('Chat experience reset completed');
        }

        async function debugApiConnection() {
            if (!confirm('Test avatar generation system? This will verify the local template-based generation.')) {
                return;
            }
            
            try {
                showQuickLoadingIndicator();
                
                // Test local avatar generation instead of API
                const testService = new ClaudeAvatarService();
                const data = await testService.testConnection();
                hideQuickLoadingIndicator();
                
                if (data.success) {
                    alert(`✅ Connection Successful!

Message: ${data.message}
Model: ${data.model}
Response: ${data.response}

Your API key is working correctly!`);
                } else {
                    alert(`❌ Connection Failed

Error: ${data.error}
Details: ${data.details || 'No additional details'}

Debug Info:
${JSON.stringify(data.debug || {}, null, 2)}`);
                }
                
            } catch (error) {
                hideQuickLoadingIndicator();
                alert(`❌ Network Error: ${error.message}`);
            }
        }

        // Show keyboard shortcuts on load (development mode)
        if (window.location.hostname === 'localhost' || window.location.hostname.includes('127.0.0.1') || window.location.hostname.includes('vercel.app')) {
            setTimeout(() => {
                console.log(`
🚀 Development Shortcuts Available:
• Ctrl+Shift+R - Reset terminal experience data
• Ctrl+Shift+C - Reset chat and start fresh
• Ctrl+Shift+T - Quick avatar test with keywords (local generation)
• Ctrl+Shift+D - Test avatar generation system

Example quick test keywords:
- technical, leadership, startup
- creative, innovation, design
- collaborative, team, communication
- adventure, risk, exploration

Avatar generation now uses reliable local templates - no API needed!
                `);
            }, 2000);
        }

        // Function to set generated avatar for chat conversations
        window.setGeneratedAvatarForChat = function(avatarData) {
            try {
                // Use centralized chat initialization
                const chat = ensureChatInitialized();
                if (!chat) return;
                
                const { chatUI, conversationManager } = chat;
                
                // Set the avatar data in the Claude client
                conversationManager.client.setAvatarData(avatarData);
                
                // Update chat UI to show avatar
                chatUI.updateAvatarDisplay(avatarData);
                
                console.log(`🎭 Avatar "${avatarData.name}" is now active for chat conversations!`);
                
                // Show notification to user
                const notification = document.createElement('div');
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    background: var(--accent-color);
                    color: white;
                    padding: 12px 20px;
                    border-radius: 8px;
                    z-index: 10000;
                    font-size: 14px;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                `;
                notification.textContent = `🎭 ${avatarData.name} is ready to chat!`;
                document.body.appendChild(notification);
                
                // Fade in and out
                setTimeout(() => notification.style.opacity = '1', 100);
                setTimeout(() => {
                    notification.style.opacity = '0';
                    setTimeout(() => document.body.removeChild(notification), 300);
                }, 3000);
                
            } catch (error) {
                console.error('Failed to set avatar for chat:', error);
            }
        };

        // Load stored avatar on page load
        window.addEventListener('load', function() {
            // Use centralized chat initialization and load stored avatar
            const chat = ensureChatInitialized();
            if (chat) {
                const { conversationManager } = chat;
                if (conversationManager.client.loadStoredAvatar()) {
                    console.log('🎭 Stored avatar loaded for chat conversations');
                }
            }
        });

        // Chat circle functionality
        function initializeChatCircle() {
            const chatCircle = document.querySelector('.chat-circle');
            if (chatCircle) {
                chatCircle.addEventListener('click', function() {
                    initializeTerminalExperience();
                });
            }
        }

        // Initialize chat circle when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            initializeChatCircle();
        });
    </script>

    <!-- Chat Circle -->
    <div class="chat-circle" title="Start Chat Experience">
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M8 12H16M8 8H16M8 16H13M7 4V2.5C7 2.22386 7.22386 2 7.5 2H16.5C16.7761 2 17 2.22386 17 2.5V4M7 4H17M7 4C5.89543 4 5 4.89543 5 6V18C5 19.1046 5.89543 20 7 20H17C18.1046 20 19 19.1046 19 18V6C19 4.89543 18.1046 4 17 4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
    </div>

    <style>
        .chat-circle {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            background: var(--accent-color);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            transition: all var(--transition-speed) ease;
            z-index: 1000;
            color: white;
        }

        .chat-circle:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 25px rgba(0, 0, 0, 0.2);
            background: var(--text-color);
        }

        .chat-circle svg {
            transition: transform var(--transition-speed) ease;
        }

        .chat-circle:hover svg {
            transform: scale(1.1);
        }

        /* Pulse animation for attention */
        .chat-circle::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            border-radius: 50%;
            background: var(--accent-color);
            animation: pulse-ring 2s infinite;
            z-index: -1;
        }

        @keyframes pulse-ring {
            0% {
                transform: scale(1);
                opacity: 0.7;
            }
            70% {
                transform: scale(1.3);
                opacity: 0;
            }
            100% {
                transform: scale(1.3);
                opacity: 0;
            }
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .chat-circle {
                bottom: 20px;
                right: 20px;
                width: 60px;
                height: 60px;
                touch-action: manipulation;
                -webkit-tap-highlight-color: transparent;
            }
            
            .chat-circle svg {
                width: 28px;
                height: 28px;
            }
            
            /* Ensure better touch targets */
            .chat-circle::before {
                animation: pulse-ring 3s infinite;
            }
        }
        
        @media (max-width: 480px) {
            .chat-circle {
                bottom: 16px;
                right: 16px;
                width: 56px;
                height: 56px;
            }
        }
    </style>
</body>
</html>